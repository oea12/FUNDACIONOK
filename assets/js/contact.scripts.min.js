"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(r){var t={};function o(e){if(t[e])return t[e].exports;var n=t[e]={i:e,l:!1,exports:{}};return r[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=r,o.c=t,o.d=function(e,n,r){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"===_typeof(n)&&n&&n.__esModule)return n;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var t in n)o.d(r,t,function(e){return n[e]}.bind(null,t));return r},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/scripts/contact.js")}({"./node_modules/core-js/es/array/from.js":function node_modulesCoreJsEsArrayFromJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\n__webpack_require__(/*! ../../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Array.from;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/array/from.js?')},"./node_modules/core-js/es/map/index.js":function node_modulesCoreJsEsMapIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.map */ "./node_modules/core-js/modules/es.map.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Map;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/map/index.js?')},"./node_modules/core-js/es/object/assign.js":function node_modulesCoreJsEsObjectAssignJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Object.assign;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/object/assign.js?')},"./node_modules/core-js/es/set/index.js":function node_modulesCoreJsEsSetIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.set */ "./node_modules/core-js/modules/es.set.js");\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Set;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/set/index.js?')},"./node_modules/core-js/es/weak-map/index.js":function node_modulesCoreJsEsWeakMapIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.WeakMap;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/weak-map/index.js?')},"./node_modules/core-js/internals/a-callable.js":function node_modulesCoreJsInternalsACallableJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + \' is not a function\');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/a-callable.js?')},"./node_modules/core-js/internals/a-possible-prototype.js":function node_modulesCoreJsInternalsAPossiblePrototypeJs(module,exports,__webpack_require__){eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument) {\n  if (typeof argument == 'object' || isCallable(argument)) return argument;\n  throw $TypeError(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/a-possible-prototype.js?")},"./node_modules/core-js/internals/add-to-unscopables.js":function node_modulesCoreJsInternalsAddToUnscopablesJs(module,exports,__webpack_require__){eval('var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\n\nvar UNSCOPABLES = wellKnownSymbol(\'unscopables\');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/add-to-unscopables.js?')},"./node_modules/core-js/internals/an-instance.js":function node_modulesCoreJsInternalsAnInstanceJs(module,exports,__webpack_require__){eval("var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ \"./node_modules/core-js/internals/object-is-prototype-of.js\");\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (it, Prototype) {\n  if (isPrototypeOf(Prototype, it)) return it;\n  throw $TypeError('Incorrect invocation');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/an-instance.js?")},"./node_modules/core-js/internals/an-object.js":function node_modulesCoreJsInternalsAnObjectJs(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/an-object.js?")},"./node_modules/core-js/internals/array-buffer-non-extensible.js":function node_modulesCoreJsInternalsArrayBufferNonExtensibleJs(module,exports,__webpack_require__){eval("// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = fails(function () {\n  if (typeof ArrayBuffer == 'function') {\n    var buffer = new ArrayBuffer(8);\n    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe\n    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-buffer-non-extensible.js?")},"./node_modules/core-js/internals/array-from.js":function node_modulesCoreJsInternalsArrayFromJs(module,exports,__webpack_require__){eval('\nvar bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\nvar getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\nvar $Array = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it\'s an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-from.js?')},"./node_modules/core-js/internals/array-includes.js":function node_modulesCoreJsInternalsArrayIncludesJs(module,exports,__webpack_require__){eval('var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-includes.js?')},"./node_modules/core-js/internals/array-iteration.js":function node_modulesCoreJsInternalsArrayIterationJs(module,exports,__webpack_require__){eval('var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");\n\nvar push = uncurryThis([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-iteration.js?')},"./node_modules/core-js/internals/array-slice-simple.js":function node_modulesCoreJsInternalsArraySliceSimpleJs(module,exports,__webpack_require__){eval('var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\n\nvar $Array = Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-slice-simple.js?')},"./node_modules/core-js/internals/array-species-constructor.js":function node_modulesCoreJsInternalsArraySpeciesConstructorJs(module,exports,__webpack_require__){eval('var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");\nvar isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar SPECIES = wellKnownSymbol(\'species\');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-species-constructor.js?')},"./node_modules/core-js/internals/array-species-create.js":function node_modulesCoreJsInternalsArraySpeciesCreateJs(module,exports,__webpack_require__){eval('var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-species-create.js?')},"./node_modules/core-js/internals/call-with-safe-iteration-closing.js":function node_modulesCoreJsInternalsCallWithSafeIterationClosingJs(module,exports,__webpack_require__){eval('var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator, \'throw\', error);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/call-with-safe-iteration-closing.js?')},"./node_modules/core-js/internals/check-correctness-of-iteration.js":function node_modulesCoreJsInternalsCheckCorrectnessOfIterationJs(module,exports,__webpack_require__){eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/check-correctness-of-iteration.js?")},"./node_modules/core-js/internals/classof-raw.js":function node_modulesCoreJsInternalsClassofRawJs(module,exports,__webpack_require__){eval("var uncurryThisRaw = __webpack_require__(/*! ../internals/function-uncurry-this-raw */ \"./node_modules/core-js/internals/function-uncurry-this-raw.js\");\n\nvar toString = uncurryThisRaw({}.toString);\nvar stringSlice = uncurryThisRaw(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/classof-raw.js?")},"./node_modules/core-js/internals/classof.js":function node_modulesCoreJsInternalsClassofJs(module,exports,__webpack_require__){eval("var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/classof.js?")},"./node_modules/core-js/internals/collection-strong.js":function node_modulesCoreJsInternalsCollectionStrongJs(module,exports,__webpack_require__){eval('\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");\nvar setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fastKey = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey;\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS) that.size = 0;\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== \'F\') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== \'F\') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    defineBuiltIns(Prototype, {\n      // `{ Map, Set }.prototype.clear()` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.clear\n      // https://tc39.es/ecma262/#sec-set.prototype.clear\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS) state.size = 0;\n        else that.size = 0;\n      },\n      // `{ Map, Set }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.delete\n      // https://tc39.es/ecma262/#sec-set.prototype.delete\n      \'delete\': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.foreach\n      // https://tc39.es/ecma262/#sec-set.prototype.foreach\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // `{ Map, Set}.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.has\n      // https://tc39.es/ecma262/#sec-set.prototype.has\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    defineBuiltIns(Prototype, IS_MAP ? {\n      // `Map.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.get\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // `Map.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.set\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // `Set.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-set.prototype.add\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS) defineProperty(Prototype, \'size\', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return Constructor;\n  },\n  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + \' Iterator\';\n    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods\n    // https://tc39.es/ecma262/#sec-map.prototype.entries\n    // https://tc39.es/ecma262/#sec-map.prototype.keys\n    // https://tc39.es/ecma262/#sec-map.prototype.values\n    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator\n    // https://tc39.es/ecma262/#sec-set.prototype.entries\n    // https://tc39.es/ecma262/#sec-set.prototype.keys\n    // https://tc39.es/ecma262/#sec-set.prototype.values\n    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator\n    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return createIterResultObject(undefined, true);\n      }\n      // return step by kind\n      if (kind == \'keys\') return createIterResultObject(entry.key, false);\n      if (kind == \'values\') return createIterResultObject(entry.value, false);\n      return createIterResultObject([entry.key, entry.value], false);\n    }, IS_MAP ? \'entries\' : \'values\', !IS_MAP, true);\n\n    // `{ Map, Set }.prototype[@@species]` accessors\n    // https://tc39.es/ecma262/#sec-get-map-@@species\n    // https://tc39.es/ecma262/#sec-get-set-@@species\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection-strong.js?')},"./node_modules/core-js/internals/collection-weak.js":function node_modulesCoreJsInternalsCollectionWeakJs(module,exports,__webpack_require__){eval('\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar getWeakData = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData;\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar splice = uncurryThis([].splice);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (store) {\n  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.entries.push([key, value]);\n  },\n  \'delete\': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) splice(this.entries, index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id++,\n        frozen: undefined\n      });\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);\n      else data[state.id] = value;\n      return that;\n    };\n\n    defineBuiltIns(Prototype, {\n      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n      \'delete\': function (key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)[\'delete\'](key);\n        return data && hasOwn(data, state.id) && delete data[state.id];\n      },\n      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n      has: function has(key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && hasOwn(data, state.id);\n      }\n    });\n\n    defineBuiltIns(Prototype, IS_MAP ? {\n      // `WeakMap.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n      get: function get(key) {\n        var state = getInternalState(this);\n        if (isObject(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // `WeakMap.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // `WeakSet.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n\n    return Constructor;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection-weak.js?')},"./node_modules/core-js/internals/collection.js":function node_modulesCoreJsInternalsCollectionJs(module,exports,__webpack_require__){eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");\n\nmodule.exports = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf(\'Map\') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf(\'Weak\') !== -1;\n  var ADDER = IS_MAP ? \'set\' : \'add\';\n  var NativeConstructor = global[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var Constructor = NativeConstructor;\n  var exported = {};\n\n  var fixMethod = function (KEY) {\n    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);\n    defineBuiltIn(NativePrototype, KEY,\n      KEY == \'add\' ? function add(value) {\n        uncurriedNativeMethod(this, value === 0 ? 0 : value);\n        return this;\n      } : KEY == \'delete\' ? function (key) {\n        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : KEY == \'get\' ? function get(key) {\n        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : KEY == \'has\' ? function has(key) {\n        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : function set(key, value) {\n        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);\n        return this;\n      }\n    );\n  };\n\n  var REPLACE = isForced(\n    CONSTRUCTOR_NAME,\n    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n      new NativeConstructor().entries().next();\n    }))\n  );\n\n  if (REPLACE) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule.enable();\n  } else if (isForced(CONSTRUCTOR_NAME, true)) {\n    var instance = new Constructor();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn\'t supports iterables, most modern - not close it correctly\n    // eslint-disable-next-line no-new -- required for testing\n    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new NativeConstructor();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n\n    if (!ACCEPT_ITERABLES) {\n      Constructor = wrapper(function (dummy, iterable) {\n        anInstance(dummy, NativePrototype);\n        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n        return that;\n      });\n      Constructor.prototype = NativePrototype;\n      NativePrototype.constructor = Constructor;\n    }\n\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod(\'delete\');\n      fixMethod(\'has\');\n      IS_MAP && fixMethod(\'get\');\n    }\n\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n    // weak collections should not contains .clear method\n    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n  }\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection.js?')},"./node_modules/core-js/internals/copy-constructor-properties.js":function node_modulesCoreJsInternalsCopyConstructorPropertiesJs(module,exports,__webpack_require__){eval('var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/copy-constructor-properties.js?')},"./node_modules/core-js/internals/correct-prototype-getter.js":function node_modulesCoreJsInternalsCorrectPrototypeGetterJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/correct-prototype-getter.js?')},"./node_modules/core-js/internals/create-iter-result-object.js":function node_modulesCoreJsInternalsCreateIterResultObjectJs(module,exports){eval("// `CreateIterResultObject` abstract operation\n// https://tc39.es/ecma262/#sec-createiterresultobject\nmodule.exports = function (value, done) {\n  return { value: value, done: done };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-iter-result-object.js?")},"./node_modules/core-js/internals/create-non-enumerable-property.js":function node_modulesCoreJsInternalsCreateNonEnumerablePropertyJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-non-enumerable-property.js?')},"./node_modules/core-js/internals/create-property-descriptor.js":function node_modulesCoreJsInternalsCreatePropertyDescriptorJs(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-property-descriptor.js?")},"./node_modules/core-js/internals/create-property.js":function node_modulesCoreJsInternalsCreatePropertyJs(module,exports,__webpack_require__){eval('\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-property.js?')},"./node_modules/core-js/internals/define-built-in.js":function node_modulesCoreJsInternalsDefineBuiltInJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-built-in.js?')},"./node_modules/core-js/internals/define-built-ins.js":function node_modulesCoreJsInternalsDefineBuiltInsJs(module,exports,__webpack_require__){eval('var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\n\nmodule.exports = function (target, src, options) {\n  for (var key in src) defineBuiltIn(target, key, src[key], options);\n  return target;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-built-ins.js?')},"./node_modules/core-js/internals/define-global-property.js":function node_modulesCoreJsInternalsDefineGlobalPropertyJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-global-property.js?')},"./node_modules/core-js/internals/descriptors.js":function node_modulesCoreJsInternalsDescriptorsJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Detect IE8\'s incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/descriptors.js?')},"./node_modules/core-js/internals/document-all.js":function node_modulesCoreJsInternalsDocumentAllJs(module,exports){eval("var documentAll = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;\n\nmodule.exports = {\n  all: documentAll,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/document-all.js?")},"./node_modules/core-js/internals/document-create-element.js":function node_modulesCoreJsInternalsDocumentCreateElementJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/document-create-element.js?')},"./node_modules/core-js/internals/engine-user-agent.js":function node_modulesCoreJsInternalsEngineUserAgentJs(module,exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/engine-user-agent.js?")},"./node_modules/core-js/internals/engine-v8-version.js":function node_modulesCoreJsInternalsEngineV8VersionJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split(\'.\');\n  // in old Chrome, versions of V8 isn\'t V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/engine-v8-version.js?')},"./node_modules/core-js/internals/enum-bug-keys.js":function node_modulesCoreJsInternalsEnumBugKeysJs(module,exports){eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/enum-bug-keys.js?")},"./node_modules/core-js/internals/export.js":function node_modulesCoreJsInternalsExportJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, \'sham\', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/export.js?')},"./node_modules/core-js/internals/fails.js":function node_modulesCoreJsInternalsFailsJs(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/fails.js?")},"./node_modules/core-js/internals/freezing.js":function node_modulesCoreJsInternalsFreezingJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/freezing.js?')},"./node_modules/core-js/internals/function-bind-context.js":function node_modulesCoreJsInternalsFunctionBindContextJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar bind = uncurryThis(uncurryThis.bind);\n\n// optional / simple context binding\nmodule.exports = function (fn, that) {\n  aCallable(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-bind-context.js?')},"./node_modules/core-js/internals/function-bind-native.js":function node_modulesCoreJsInternalsFunctionBindNativeJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-bind-native.js?")},"./node_modules/core-js/internals/function-call.js":function node_modulesCoreJsInternalsFunctionCallJs(module,exports,__webpack_require__){eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-call.js?')},"./node_modules/core-js/internals/function-name.js":function node_modulesCoreJsInternalsFunctionNameJs(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-name.js?")},"./node_modules/core-js/internals/function-uncurry-this-raw.js":function node_modulesCoreJsInternalsFunctionUncurryThisRawJs(module,exports,__webpack_require__){eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-uncurry-this-raw.js?')},"./node_modules/core-js/internals/function-uncurry-this.js":function node_modulesCoreJsInternalsFunctionUncurryThisJs(module,exports,__webpack_require__){eval('var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar uncurryThisRaw = __webpack_require__(/*! ../internals/function-uncurry-this-raw */ "./node_modules/core-js/internals/function-uncurry-this-raw.js");\n\nmodule.exports = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw(fn) === \'Function\') return uncurryThisRaw(fn);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-uncurry-this.js?')},"./node_modules/core-js/internals/get-built-in.js":function node_modulesCoreJsInternalsGetBuiltInJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-built-in.js?')},"./node_modules/core-js/internals/get-iterator-method.js":function node_modulesCoreJsInternalsGetIteratorMethodJs(module,exports,__webpack_require__){eval('var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\n\nmodule.exports = function (it) {\n  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)\n    || getMethod(it, \'@@iterator\')\n    || Iterators[classof(it)];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-iterator-method.js?')},"./node_modules/core-js/internals/get-iterator.js":function node_modulesCoreJsInternalsGetIteratorJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n  throw $TypeError(tryToString(argument) + \' is not iterable\');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-iterator.js?')},"./node_modules/core-js/internals/get-method.js":function node_modulesCoreJsInternalsGetMethodJs(module,exports,__webpack_require__){eval('var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-method.js?')},"./node_modules/core-js/internals/global.js":function node_modulesCoreJsInternalsGlobalJs(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/global.js?")},"./node_modules/core-js/internals/has-own-property.js":function node_modulesCoreJsInternalsHasOwnPropertyJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/has-own-property.js?')},"./node_modules/core-js/internals/hidden-keys.js":function node_modulesCoreJsInternalsHiddenKeysJs(module,exports){eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/hidden-keys.js?")},"./node_modules/core-js/internals/html.js":function node_modulesCoreJsInternalsHtmlJs(module,exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/html.js?")},"./node_modules/core-js/internals/ie8-dom-define.js":function node_modulesCoreJsInternalsIe8DomDefineJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/ie8-dom-define.js?')},"./node_modules/core-js/internals/indexed-object.js":function node_modulesCoreJsInternalsIndexedObjectJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/indexed-object.js?")},"./node_modules/core-js/internals/inherit-if-required.js":function node_modulesCoreJsInternalsInheritIfRequiredJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven\'t completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/inherit-if-required.js?')},"./node_modules/core-js/internals/inspect-source.js":function node_modulesCoreJsInternalsInspectSourceJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can\'t use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/inspect-source.js?')},"./node_modules/core-js/internals/internal-metadata.js":function node_modulesCoreJsInternalsInternalMetadataJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");\nvar isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");\n\nvar REQUIRED = false;\nvar METADATA = uid(\'meta\');\nvar id = 0;\n\nvar setMetadata = function (it) {\n  defineProperty(it, METADATA, { value: {\n    objectID: \'O\' + id++, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject(it)) return typeof it == \'symbol\' ? it : (typeof it == \'string\' ? \'S\' : \'P\') + it;\n  if (!hasOwn(it, METADATA)) {\n    // can\'t set metadata to uncaught frozen object\n    if (!isExtensible(it)) return \'F\';\n    // not necessary to add metadata\n    if (!create) return \'E\';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData = function (it, create) {\n  if (!hasOwn(it, METADATA)) {\n    // can\'t set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar enable = function () {\n  meta.enable = function () { /* empty */ };\n  REQUIRED = true;\n  var getOwnPropertyNames = getOwnPropertyNamesModule.f;\n  var splice = uncurryThis([].splice);\n  var test = {};\n  test[METADATA] = 1;\n\n  // prevent exposing of metadata key\n  if (getOwnPropertyNames(test).length) {\n    getOwnPropertyNamesModule.f = function (it) {\n      var result = getOwnPropertyNames(it);\n      for (var i = 0, length = result.length; i < length; i++) {\n        if (result[i] === METADATA) {\n          splice(result, i, 1);\n          break;\n        }\n      } return result;\n    };\n\n    $({ target: \'Object\', stat: true, forced: true }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f\n    });\n  }\n};\n\nvar meta = module.exports = {\n  enable: enable,\n  fastKey: fastKey,\n  getWeakData: getWeakData,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/internal-metadata.js?')},"./node_modules/core-js/internals/internal-state.js":function node_modulesCoreJsInternalsInternalStateJs(module,exports,__webpack_require__){eval('var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar OBJECT_ALREADY_INITIALIZED = \'Object already initialized\';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/internal-state.js?')},"./node_modules/core-js/internals/is-array-iterator-method.js":function node_modulesCoreJsInternalsIsArrayIteratorMethodJs(module,exports,__webpack_require__){eval('var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-array-iterator-method.js?')},"./node_modules/core-js/internals/is-array.js":function node_modulesCoreJsInternalsIsArrayJs(module,exports,__webpack_require__){eval("var classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-array.js?")},"./node_modules/core-js/internals/is-callable.js":function node_modulesCoreJsInternalsIsCallableJs(module,exports,__webpack_require__){eval("var $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = $documentAll.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-callable.js?")},"./node_modules/core-js/internals/is-constructor.js":function node_modulesCoreJsInternalsIsConstructorJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nmodule.exports = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-constructor.js?")},"./node_modules/core-js/internals/is-forced.js":function node_modulesCoreJsInternalsIsForcedJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-forced.js?")},"./node_modules/core-js/internals/is-null-or-undefined.js":function node_modulesCoreJsInternalsIsNullOrUndefinedJs(module,exports){eval("// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-null-or-undefined.js?")},"./node_modules/core-js/internals/is-object.js":function node_modulesCoreJsInternalsIsObjectJs(module,exports,__webpack_require__){eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\nmodule.exports = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-object.js?")},"./node_modules/core-js/internals/is-pure.js":function node_modulesCoreJsInternalsIsPureJs(module,exports){eval("module.exports = false;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-pure.js?")},"./node_modules/core-js/internals/is-symbol.js":function node_modulesCoreJsInternalsIsSymbolJs(module,exports,__webpack_require__){eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == \'symbol\';\n} : function (it) {\n  var $Symbol = getBuiltIn(\'Symbol\');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-symbol.js?')},"./node_modules/core-js/internals/iterate.js":function node_modulesCoreJsInternalsIterateJs(module,exports,__webpack_require__){eval('var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");\nvar getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\nvar iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nmodule.exports = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_RECORD = !!(options && options.IS_RECORD);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, \'normal\', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_RECORD) {\n    iterator = iterable.iterator;\n  } else if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + \' is not iterable\');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = IS_RECORD ? iterable.next : iterator.next;\n  while (!(step = call(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, \'throw\', error);\n    }\n    if (typeof result == \'object\' && result && isPrototypeOf(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterate.js?')},"./node_modules/core-js/internals/iterator-close.js":function node_modulesCoreJsInternalsIteratorCloseJs(module,exports,__webpack_require__){eval("var call = __webpack_require__(/*! ../internals/function-call */ \"./node_modules/core-js/internals/function-call.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ \"./node_modules/core-js/internals/get-method.js\");\n\nmodule.exports = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject(innerResult);\n  return value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-close.js?")},"./node_modules/core-js/internals/iterator-create-constructor.js":function node_modulesCoreJsInternalsIteratorCreateConstructorJs(module,exports,__webpack_require__){eval('\nvar IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-create-constructor.js?')},"./node_modules/core-js/internals/iterator-define.js":function node_modulesCoreJsInternalsIteratorDefineJs(module,exports,__webpack_require__){eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\nvar FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar KEYS = \'keys\';\nvar VALUES = \'values\';\nvar ENTRIES = \'entries\';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype[\'@@iterator\']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \'Array\' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {\n          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty(IterablePrototype, \'name\', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });\n  }\n  Iterators[NAME] = defaultIterator;\n\n  return methods;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-define.js?')},"./node_modules/core-js/internals/iterators-core.js":function node_modulesCoreJsInternalsIteratorsCoreJs(module,exports,__webpack_require__){eval('\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar BUGGY_SAFARI_ITERATORS = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!(\'next\' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype[ITERATOR].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\nelse if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable(IteratorPrototype[ITERATOR])) {\n  defineBuiltIn(IteratorPrototype, ITERATOR, function () {\n    return this;\n  });\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators-core.js?')},"./node_modules/core-js/internals/iterators.js":function node_modulesCoreJsInternalsIteratorsJs(module,exports){eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators.js?")},"./node_modules/core-js/internals/length-of-array-like.js":function node_modulesCoreJsInternalsLengthOfArrayLikeJs(module,exports,__webpack_require__){eval('var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/length-of-array-like.js?')},"./node_modules/core-js/internals/make-built-in.js":function node_modulesCoreJsInternalsMakeBuiltInJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar CONFIGURABLE_FUNCTION_NAME = __webpack_require__(/*! ../internals/function-name */ \"./node_modules/core-js/internals/function-name.js\").CONFIGURABLE;\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/make-built-in.js?")},"./node_modules/core-js/internals/math-trunc.js":function node_modulesCoreJsInternalsMathTruncJs(module,exports){eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/math-trunc.js?")},"./node_modules/core-js/internals/object-assign.js":function node_modulesCoreJsInternalsObjectAssignJs(module,exports,__webpack_require__){eval('\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, \'a\', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, \'b\', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = \'abcdefghijklmnopqrst\';\n  A[symbol] = 7;\n  alphabet.split(\'\').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\'\') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-assign.js?')},"./node_modules/core-js/internals/object-create.js":function node_modulesCoreJsInternalsObjectCreateJs(module,exports,__webpack_require__){eval("/* global ActiveXObject -- old IE, WSH */\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\nvar html = __webpack_require__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-create.js?")},"./node_modules/core-js/internals/object-define-properties.js":function node_modulesCoreJsInternalsObjectDefinePropertiesJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nexports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var props = toIndexedObject(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-properties.js?')},"./node_modules/core-js/internals/object-define-property.js":function node_modulesCoreJsInternalsObjectDefinePropertyJs(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ \"./node_modules/core-js/internals/v8-prototype-define-bug.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-property.js?")},"./node_modules/core-js/internals/object-get-own-property-descriptor.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyDescriptorJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-descriptor.js?')},"./node_modules/core-js/internals/object-get-own-property-names-external.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesExternalJs(module,exports,__webpack_require__){eval('/* eslint-disable es/no-object-getownpropertynames -- safe */\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar $getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;\nvar arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");\n\nvar windowNames = typeof window == \'object\' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return $getOwnPropertyNames(it);\n  } catch (error) {\n    return arraySlice(windowNames);\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && classof(it) == \'Window\'\n    ? getWindowNames(it)\n    : $getOwnPropertyNames(toIndexedObject(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-names-external.js?')},"./node_modules/core-js/internals/object-get-own-property-names.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesJs(module,exports,__webpack_require__){eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-names.js?")},"./node_modules/core-js/internals/object-get-own-property-symbols.js":function node_modulesCoreJsInternalsObjectGetOwnPropertySymbolsJs(module,exports){eval("// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-symbols.js?")},"./node_modules/core-js/internals/object-get-prototype-of.js":function node_modulesCoreJsInternalsObjectGetPrototypeOfJs(module,exports,__webpack_require__){eval('var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");\n\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype : null;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-prototype-of.js?')},"./node_modules/core-js/internals/object-is-extensible.js":function node_modulesCoreJsInternalsObjectIsExtensibleJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");\n\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar $isExtensible = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });\n\n// `Object.isExtensible` method\n// https://tc39.es/ecma262/#sec-object.isextensible\nmodule.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {\n  if (!isObject(it)) return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == \'ArrayBuffer\') return false;\n  return $isExtensible ? $isExtensible(it) : true;\n} : $isExtensible;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-is-extensible.js?')},"./node_modules/core-js/internals/object-is-prototype-of.js":function node_modulesCoreJsInternalsObjectIsPrototypeOfJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-is-prototype-of.js?')},"./node_modules/core-js/internals/object-keys-internal.js":function node_modulesCoreJsInternalsObjectKeysInternalJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys-internal.js?')},"./node_modules/core-js/internals/object-keys.js":function node_modulesCoreJsInternalsObjectKeysJs(module,exports,__webpack_require__){eval('var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys.js?')},"./node_modules/core-js/internals/object-property-is-enumerable.js":function node_modulesCoreJsInternalsObjectPropertyIsEnumerableJs(module,exports,__webpack_require__){eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-property-is-enumerable.js?")},"./node_modules/core-js/internals/object-set-prototype-of.js":function node_modulesCoreJsInternalsObjectSetPrototypeOfJs(module,exports,__webpack_require__){eval('/* eslint-disable no-proto -- safe */\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || (\'__proto__\' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, \'__proto__\').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-set-prototype-of.js?')},"./node_modules/core-js/internals/object-to-string.js":function node_modulesCoreJsInternalsObjectToStringJs(module,exports,__webpack_require__){eval("\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-to-string.js?")},"./node_modules/core-js/internals/ordinary-to-primitive.js":function node_modulesCoreJsInternalsOrdinaryToPrimitiveJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError("Can\'t convert object to primitive value");\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/ordinary-to-primitive.js?')},"./node_modules/core-js/internals/own-keys.js":function node_modulesCoreJsInternalsOwnKeysJs(module,exports,__webpack_require__){eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn(\'Reflect\', \'ownKeys\') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/own-keys.js?')},"./node_modules/core-js/internals/path.js":function node_modulesCoreJsInternalsPathJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nmodule.exports = global;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/path.js?')},"./node_modules/core-js/internals/require-object-coercible.js":function node_modulesCoreJsInternalsRequireObjectCoercibleJs(module,exports,__webpack_require__){eval('var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw $TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/require-object-coercible.js?')},"./node_modules/core-js/internals/set-species.js":function node_modulesCoreJsInternalsSetSpeciesJs(module,exports,__webpack_require__){eval('\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\n\nvar SPECIES = wellKnownSymbol(\'species\');\n\nmodule.exports = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n    defineProperty(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-species.js?')},"./node_modules/core-js/internals/set-to-string-tag.js":function node_modulesCoreJsInternalsSetToStringTagJs(module,exports,__webpack_require__){eval('var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n\nmodule.exports = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn(target, TO_STRING_TAG)) {\n    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-to-string-tag.js?')},"./node_modules/core-js/internals/shared-key.js":function node_modulesCoreJsInternalsSharedKeyJs(module,exports,__webpack_require__){eval('var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared-key.js?')},"./node_modules/core-js/internals/shared-store.js":function node_modulesCoreJsInternalsSharedStoreJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared-store.js?')},"./node_modules/core-js/internals/shared.js":function node_modulesCoreJsInternalsSharedJs(module,exports,__webpack_require__){eval("var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.26.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared.js?")},"./node_modules/core-js/internals/string-multibyte.js":function node_modulesCoreJsInternalsStringMultibyteJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\nvar toString = __webpack_require__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\nvar charAt = uncurryThis(''.charAt);\nvar charCodeAt = uncurryThis(''.charCodeAt);\nvar stringSlice = uncurryThis(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString(requireObjectCoercible($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/string-multibyte.js?")},"./node_modules/core-js/internals/symbol-constructor-detection.js":function node_modulesCoreJsInternalsSymbolConstructorDetectionJs(module,exports,__webpack_require__){eval('/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/symbol-constructor-detection.js?')},"./node_modules/core-js/internals/to-absolute-index.js":function node_modulesCoreJsInternalsToAbsoluteIndexJs(module,exports,__webpack_require__){eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-absolute-index.js?')},"./node_modules/core-js/internals/to-indexed-object.js":function node_modulesCoreJsInternalsToIndexedObjectJs(module,exports,__webpack_require__){eval('// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-indexed-object.js?')},"./node_modules/core-js/internals/to-integer-or-infinity.js":function node_modulesCoreJsInternalsToIntegerOrInfinityJs(module,exports,__webpack_require__){eval('var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-integer-or-infinity.js?')},"./node_modules/core-js/internals/to-length.js":function node_modulesCoreJsInternalsToLengthJs(module,exports,__webpack_require__){eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-length.js?')},"./node_modules/core-js/internals/to-object.js":function node_modulesCoreJsInternalsToObjectJs(module,exports,__webpack_require__){eval('var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-object.js?')},"./node_modules/core-js/internals/to-primitive.js":function node_modulesCoreJsInternalsToPrimitiveJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");\nvar ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol(\'toPrimitive\');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = \'default\';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError("Can\'t convert object to primitive value");\n  }\n  if (pref === undefined) pref = \'number\';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-primitive.js?')},"./node_modules/core-js/internals/to-property-key.js":function node_modulesCoreJsInternalsToPropertyKeyJs(module,exports,__webpack_require__){eval("var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-property-key.js?")},"./node_modules/core-js/internals/to-string-tag-support.js":function node_modulesCoreJsInternalsToStringTagSupportJs(module,exports,__webpack_require__){eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-string-tag-support.js?")},"./node_modules/core-js/internals/to-string.js":function node_modulesCoreJsInternalsToStringJs(module,exports,__webpack_require__){eval("var classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-string.js?")},"./node_modules/core-js/internals/try-to-string.js":function node_modulesCoreJsInternalsTryToStringJs(module,exports){eval("var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/try-to-string.js?")},"./node_modules/core-js/internals/uid.js":function node_modulesCoreJsInternalsUidJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/uid.js?")},"./node_modules/core-js/internals/use-symbol-as-uid.js":function node_modulesCoreJsInternalsUseSymbolAsUidJs(module,exports,__webpack_require__){eval("/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ \"./node_modules/core-js/internals/symbol-constructor-detection.js\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/use-symbol-as-uid.js?")},"./node_modules/core-js/internals/v8-prototype-define-bug.js":function node_modulesCoreJsInternalsV8PrototypeDefineBugJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, \'prototype\', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/v8-prototype-define-bug.js?')},"./node_modules/core-js/internals/weak-map-basic-detection.js":function node_modulesCoreJsInternalsWeakMapBasicDetectionJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/weak-map-basic-detection.js?')},"./node_modules/core-js/internals/well-known-symbol.js":function node_modulesCoreJsInternalsWellKnownSymbolJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar WellKnownSymbolsStore = shared(\'wks\');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol[\'for\'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \'string\')) {\n    var description = \'Symbol.\' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/well-known-symbol.js?')},"./node_modules/core-js/modules/es.array.from.js":function node_modulesCoreJsModulesEsArrayFromJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$({ target: \'Array\', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.array.from.js?')},"./node_modules/core-js/modules/es.array.iterator.js":function node_modulesCoreJsModulesEsArrayIteratorJs(module,exports,__webpack_require__){eval("\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ \"./node_modules/core-js/internals/iterator-define.js\");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ \"./node_modules/core-js/internals/create-iter-result-object.js\");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return createIterResultObject(undefined, true);\n  }\n  if (kind == 'keys') return createIterResultObject(index, false);\n  if (kind == 'values') return createIterResultObject(target[index], false);\n  return createIterResultObject([index, target[index]], false);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {\n  defineProperty(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.array.iterator.js?")},"./node_modules/core-js/modules/es.map.constructor.js":function node_modulesCoreJsModulesEsMapConstructorJs(module,exports,__webpack_require__){eval('\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");\n\n// `Map` constructor\n// https://tc39.es/ecma262/#sec-map-objects\ncollection(\'Map\', function (init) {\n  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.map.constructor.js?')},"./node_modules/core-js/modules/es.map.js":function node_modulesCoreJsModulesEsMapJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.map.constructor */ "./node_modules/core-js/modules/es.map.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.map.js?')},"./node_modules/core-js/modules/es.object.assign.js":function node_modulesCoreJsModulesEsObjectAssignJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: \'Object\', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.object.assign.js?')},"./node_modules/core-js/modules/es.object.to-string.js":function node_modulesCoreJsModulesEsObjectToStringJs(module,exports,__webpack_require__){eval('var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");\n\n// `Object.prototype.toString` method\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nif (!TO_STRING_TAG_SUPPORT) {\n  defineBuiltIn(Object.prototype, \'toString\', toString, { unsafe: true });\n}\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.object.to-string.js?')},"./node_modules/core-js/modules/es.set.constructor.js":function node_modulesCoreJsModulesEsSetConstructorJs(module,exports,__webpack_require__){eval('\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");\n\n// `Set` constructor\n// https://tc39.es/ecma262/#sec-set-objects\ncollection(\'Set\', function (init) {\n  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.set.constructor.js?')},"./node_modules/core-js/modules/es.set.js":function node_modulesCoreJsModulesEsSetJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.set.constructor */ "./node_modules/core-js/modules/es.set.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.set.js?')},"./node_modules/core-js/modules/es.string.iterator.js":function node_modulesCoreJsModulesEsStringIteratorJs(module,exports,__webpack_require__){eval('\nvar charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;\nvar toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");\n\nvar STRING_ITERATOR = \'String Iterator\';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, \'String\', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: toString(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return createIterResultObject(undefined, true);\n  point = charAt(string, index);\n  state.index += point.length;\n  return createIterResultObject(point, false);\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.string.iterator.js?')},"./node_modules/core-js/modules/es.weak-map.constructor.js":function node_modulesCoreJsModulesEsWeakMapConstructorJs(module,exports,__webpack_require__){eval('\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");\nvar enforceInternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce;\nvar NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");\n\nvar IS_IE11 = !global.ActiveXObject && \'ActiveXObject\' in global;\nvar InternalWeakMap;\n\nvar wrapper = function (init) {\n  return function WeakMap() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n};\n\n// `WeakMap` constructor\n// https://tc39.es/ecma262/#sec-weakmap-constructor\nvar $WeakMap = collection(\'WeakMap\', wrapper, collectionWeak);\n\n// IE11 WeakMap frozen keys fix\n// We can\'t use feature detection because it crash some old IE builds\n// https://github.com/zloirock/core-js/issues/485\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, \'WeakMap\', true);\n  InternalMetadataModule.enable();\n  var WeakMapPrototype = $WeakMap.prototype;\n  var nativeDelete = uncurryThis(WeakMapPrototype[\'delete\']);\n  var nativeHas = uncurryThis(WeakMapPrototype.has);\n  var nativeGet = uncurryThis(WeakMapPrototype.get);\n  var nativeSet = uncurryThis(WeakMapPrototype.set);\n  defineBuiltIns(WeakMapPrototype, {\n    \'delete\': function (key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeDelete(this, key) || state.frozen[\'delete\'](key);\n      } return nativeDelete(this, key);\n    },\n    has: function has(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) || state.frozen.has(key);\n      } return nativeHas(this, key);\n    },\n    get: function get(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n      } return nativeGet(this, key);\n    },\n    set: function set(key, value) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n      } else nativeSet(this, key, value);\n      return this;\n    }\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.weak-map.constructor.js?')},"./node_modules/core-js/modules/es.weak-map.js":function node_modulesCoreJsModulesEsWeakMapJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.weak-map.constructor */ "./node_modules/core-js/modules/es.weak-map.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.weak-map.js?')},"./node_modules/lodash.clamp/index.js":function node_modulesLodashClampIndexJs(module,exports){eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n\n\n//# sourceURL=webpack:///./node_modules/lodash.clamp/index.js?")},"./node_modules/lodash.debounce/index.js":function node_modulesLodashDebounceIndexJs(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/lodash.debounce/index.js?")},"./node_modules/smooth-scrollbar/decorators/boolean.js":function node_modulesSmoothScrollbarDecoratorsBooleanJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boolean", function() { return boolean; });\nfunction boolean(proto, key) {\n    var alias = "_" + key;\n    Object.defineProperty(proto, key, {\n        get: function () {\n            return this[alias];\n        },\n        set: function (val) {\n            Object.defineProperty(this, alias, {\n                value: !!val,\n                enumerable: false,\n                writable: true,\n                configurable: true,\n            });\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n//# sourceMappingURL=boolean.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/boolean.js?')},"./node_modules/smooth-scrollbar/decorators/debounce.js":function node_modulesSmoothScrollbarDecoratorsDebounceJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction debounce() {\n    var options = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        options[_i] = arguments[_i];\n    }\n    return function (_proto, key, descriptor) {\n        var fn = descriptor.value;\n        return {\n            get: function () {\n                if (!this.hasOwnProperty(key)) {\n                    Object.defineProperty(this, key, {\n                        value: lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default.a.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])([fn], options)),\n                    });\n                }\n                return this[key];\n            },\n        };\n    };\n}\n//# sourceMappingURL=debounce.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/debounce.js?')},"./node_modules/smooth-scrollbar/decorators/index.js":function node_modulesSmoothScrollbarDecoratorsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./range */ "./node_modules/smooth-scrollbar/decorators/range.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_0__["range"]; });\n\n/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boolean */ "./node_modules/smooth-scrollbar/decorators/boolean.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "boolean", function() { return _boolean__WEBPACK_IMPORTED_MODULE_1__["boolean"]; });\n\n/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce */ "./node_modules/smooth-scrollbar/decorators/debounce.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _debounce__WEBPACK_IMPORTED_MODULE_2__["debounce"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/index.js?')},"./node_modules/smooth-scrollbar/decorators/range.js":function node_modulesSmoothScrollbarDecoratorsRangeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction range(min, max) {\n    if (min === void 0) { min = -Infinity; }\n    if (max === void 0) { max = Infinity; }\n    return function (proto, key) {\n        var alias = "_" + key;\n        Object.defineProperty(proto, key, {\n            get: function () {\n                return this[alias];\n            },\n            set: function (val) {\n                Object.defineProperty(this, alias, {\n                    value: lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(val, min, max),\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                });\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/range.js?')},"./node_modules/smooth-scrollbar/events/index.js":function node_modulesSmoothScrollbarEventsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyboard */ "./node_modules/smooth-scrollbar/events/keyboard.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keyboardHandler", function() { return _keyboard__WEBPACK_IMPORTED_MODULE_0__["keyboardHandler"]; });\n\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouse */ "./node_modules/smooth-scrollbar/events/mouse.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouseHandler", function() { return _mouse__WEBPACK_IMPORTED_MODULE_1__["mouseHandler"]; });\n\n/* harmony import */ var _resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resize */ "./node_modules/smooth-scrollbar/events/resize.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeHandler", function() { return _resize__WEBPACK_IMPORTED_MODULE_2__["resizeHandler"]; });\n\n/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./select */ "./node_modules/smooth-scrollbar/events/select.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectHandler", function() { return _select__WEBPACK_IMPORTED_MODULE_3__["selectHandler"]; });\n\n/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./touch */ "./node_modules/smooth-scrollbar/events/touch.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touchHandler", function() { return _touch__WEBPACK_IMPORTED_MODULE_4__["touchHandler"]; });\n\n/* harmony import */ var _wheel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wheel */ "./node_modules/smooth-scrollbar/events/wheel.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wheelHandler", function() { return _wheel__WEBPACK_IMPORTED_MODULE_5__["wheelHandler"]; });\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/index.js?')},"./node_modules/smooth-scrollbar/events/keyboard.js":function node_modulesSmoothScrollbarEventsKeyboardJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyboardHandler", function() { return keyboardHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\nvar KEY_CODE;\n(function (KEY_CODE) {\n    KEY_CODE[KEY_CODE["TAB"] = 9] = "TAB";\n    KEY_CODE[KEY_CODE["SPACE"] = 32] = "SPACE";\n    KEY_CODE[KEY_CODE["PAGE_UP"] = 33] = "PAGE_UP";\n    KEY_CODE[KEY_CODE["PAGE_DOWN"] = 34] = "PAGE_DOWN";\n    KEY_CODE[KEY_CODE["END"] = 35] = "END";\n    KEY_CODE[KEY_CODE["HOME"] = 36] = "HOME";\n    KEY_CODE[KEY_CODE["LEFT"] = 37] = "LEFT";\n    KEY_CODE[KEY_CODE["UP"] = 38] = "UP";\n    KEY_CODE[KEY_CODE["RIGHT"] = 39] = "RIGHT";\n    KEY_CODE[KEY_CODE["DOWN"] = 40] = "DOWN";\n})(KEY_CODE || (KEY_CODE = {}));\nfunction keyboardHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__["eventScope"])(scrollbar);\n    var container = scrollbar.containerEl;\n    addEvent(container, \'keydown\', function (evt) {\n        var activeElement = document.activeElement;\n        if (activeElement !== container && !container.contains(activeElement)) {\n            return;\n        }\n        if (isEditable(activeElement)) {\n            return;\n        }\n        var delta = getKeyDelta(scrollbar, evt.keyCode || evt.which);\n        if (!delta) {\n            return;\n        }\n        var x = delta[0], y = delta[1];\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll) {\n                evt.preventDefault();\n            }\n            else {\n                scrollbar.containerEl.blur();\n                if (scrollbar.parent) {\n                    scrollbar.parent.containerEl.focus();\n                }\n            }\n        });\n    });\n}\nfunction getKeyDelta(scrollbar, keyCode) {\n    var size = scrollbar.size, limit = scrollbar.limit, offset = scrollbar.offset;\n    switch (keyCode) {\n        case KEY_CODE.TAB:\n            return handleTabKey(scrollbar);\n        case KEY_CODE.SPACE:\n            return [0, 200];\n        case KEY_CODE.PAGE_UP:\n            return [0, -size.container.height + 40];\n        case KEY_CODE.PAGE_DOWN:\n            return [0, size.container.height - 40];\n        case KEY_CODE.END:\n            return [0, limit.y - offset.y];\n        case KEY_CODE.HOME:\n            return [0, -offset.y];\n        case KEY_CODE.LEFT:\n            return [-40, 0];\n        case KEY_CODE.UP:\n            return [0, -40];\n        case KEY_CODE.RIGHT:\n            return [40, 0];\n        case KEY_CODE.DOWN:\n            return [0, 40];\n        default:\n            return null;\n    }\n}\nfunction handleTabKey(scrollbar) {\n    // handle in next frame\n    requestAnimationFrame(function () {\n        scrollbar.scrollIntoView(document.activeElement, {\n            offsetTop: scrollbar.size.container.height / 2,\n            offsetLeft: scrollbar.size.container.width / 2,\n            onlyScrollIfNeeded: true,\n        });\n    });\n}\nfunction isEditable(elem) {\n    if (elem.tagName === \'INPUT\' ||\n        elem.tagName === \'SELECT\' ||\n        elem.tagName === \'TEXTAREA\' ||\n        elem.isContentEditable) {\n        return !elem.disabled;\n    }\n    return false;\n}\n//# sourceMappingURL=keyboard.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/keyboard.js?')},"./node_modules/smooth-scrollbar/events/mouse.js":function node_modulesSmoothScrollbarEventsMouseJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseHandler", function() { return mouseHandler; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar Direction;\n(function (Direction) {\n    Direction[Direction["X"] = 0] = "X";\n    Direction[Direction["Y"] = 1] = "Y";\n})(Direction || (Direction = {}));\nfunction mouseHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["eventScope"])(scrollbar);\n    var container = scrollbar.containerEl;\n    var _a = scrollbar.track, xAxis = _a.xAxis, yAxis = _a.yAxis;\n    function calcMomentum(direction, clickPosition) {\n        var size = scrollbar.size, limit = scrollbar.limit, offset = scrollbar.offset;\n        if (direction === Direction.X) {\n            var totalWidth = size.container.width + (xAxis.thumb.realSize - xAxis.thumb.displaySize);\n            return lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(clickPosition / totalWidth * size.content.width, 0, limit.x) - offset.x;\n        }\n        if (direction === Direction.Y) {\n            var totalHeight = size.container.height + (yAxis.thumb.realSize - yAxis.thumb.displaySize);\n            return lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(clickPosition / totalHeight * size.content.height, 0, limit.y) - offset.y;\n        }\n        return 0;\n    }\n    function getTrackDirection(elem) {\n        if (Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(elem, [xAxis.element, xAxis.thumb.element])) {\n            return Direction.X;\n        }\n        if (Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(elem, [yAxis.element, yAxis.thumb.element])) {\n            return Direction.Y;\n        }\n        return void 0;\n    }\n    var isMouseDown;\n    var isMouseMoving;\n    var startOffsetToThumb;\n    var trackDirection;\n    var containerRect;\n    addEvent(container, \'click\', function (evt) {\n        if (isMouseMoving || !Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(evt.target, [xAxis.element, yAxis.element])) {\n            return;\n        }\n        var track = evt.target;\n        var direction = getTrackDirection(track);\n        var rect = track.getBoundingClientRect();\n        var clickPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        if (direction === Direction.X) {\n            var offsetOnTrack = clickPos.x - rect.left - xAxis.thumb.displaySize / 2;\n            scrollbar.setMomentum(calcMomentum(direction, offsetOnTrack), 0);\n        }\n        if (direction === Direction.Y) {\n            var offsetOnTrack = clickPos.y - rect.top - yAxis.thumb.displaySize / 2;\n            scrollbar.setMomentum(0, calcMomentum(direction, offsetOnTrack));\n        }\n    });\n    addEvent(container, \'mousedown\', function (evt) {\n        if (!Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(evt.target, [xAxis.thumb.element, yAxis.thumb.element])) {\n            return;\n        }\n        isMouseDown = true;\n        var thumb = evt.target;\n        var cursorPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        var thumbRect = thumb.getBoundingClientRect();\n        trackDirection = getTrackDirection(thumb);\n        // pointer offset to thumb\n        startOffsetToThumb = {\n            x: cursorPos.x - thumbRect.left,\n            y: cursorPos.y - thumbRect.top,\n        };\n        // container bounding rectangle\n        containerRect = container.getBoundingClientRect();\n        // prevent selection, see:\n        // https://github.com/idiotWu/smooth-scrollbar/issues/48\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(scrollbar.containerEl, {\n            \'-user-select\': \'none\',\n        });\n    });\n    addEvent(window, \'mousemove\', function (evt) {\n        if (!isMouseDown)\n            return;\n        isMouseMoving = true;\n        var cursorPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        if (trackDirection === Direction.X) {\n            // get percentage of pointer position in track\n            // then tranform to px\n            // don\'t need easing\n            var offsetOnTrack = cursorPos.x - startOffsetToThumb.x - containerRect.left;\n            scrollbar.setMomentum(calcMomentum(trackDirection, offsetOnTrack), 0);\n        }\n        if (trackDirection === Direction.Y) {\n            var offsetOnTrack = cursorPos.y - startOffsetToThumb.y - containerRect.top;\n            scrollbar.setMomentum(0, calcMomentum(trackDirection, offsetOnTrack));\n        }\n    });\n    addEvent(window, \'mouseup blur\', function () {\n        isMouseDown = isMouseMoving = false;\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(scrollbar.containerEl, {\n            \'-user-select\': \'\',\n        });\n    });\n}\n//# sourceMappingURL=mouse.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/mouse.js?')},"./node_modules/smooth-scrollbar/events/resize.js":function node_modulesSmoothScrollbarEventsResizeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeHandler", function() { return resizeHandler; });\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nfunction resizeHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["eventScope"])(scrollbar);\n    addEvent(window, \'resize\', lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(scrollbar.update.bind(scrollbar), 300));\n}\n//# sourceMappingURL=resize.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/resize.js?')},"./node_modules/smooth-scrollbar/events/select.js":function node_modulesSmoothScrollbarEventsSelectJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectHandler\", function() { return selectHandler; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ \"./node_modules/lodash.clamp/index.js\");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ \"./node_modules/smooth-scrollbar/utils/index.js\");\n\n\nfunction selectHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__[\"eventScope\"])(scrollbar);\n    var containerEl = scrollbar.containerEl, contentEl = scrollbar.contentEl;\n    var isSelected = false;\n    var isContextMenuOpened = false; // flag to prevent selection when context menu is opened\n    var animationID;\n    function scroll(_a) {\n        var x = _a.x, y = _a.y;\n        if (!x && !y)\n            return;\n        var offset = scrollbar.offset, limit = scrollbar.limit;\n        // DISALLOW delta transformation\n        scrollbar.setMomentum(lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(offset.x + x, 0, limit.x) - offset.x, lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(offset.y + y, 0, limit.y) - offset.y);\n        animationID = requestAnimationFrame(function () {\n            scroll({ x: x, y: y });\n        });\n    }\n    addEvent(window, 'mousemove', function (evt) {\n        if (!isSelected)\n            return;\n        cancelAnimationFrame(animationID);\n        var dir = calcMomentum(scrollbar, evt);\n        scroll(dir);\n    });\n    // prevent scrolling when context menu is opened\n    // NOTE: `contextmenu` event may be fired\n    //          1. BEFORE `selectstart`: when user right-clicks on the text content -> prevent future scrolling,\n    //          2. AFTER `selectstart`: when user right-clicks on the blank area -> cancel current scrolling,\n    //        so we need to both set the flag and cancel current scrolling\n    addEvent(contentEl, 'contextmenu', function () {\n        // set the flag to prevent future scrolling\n        isContextMenuOpened = true;\n        // stop current scrolling\n        cancelAnimationFrame(animationID);\n        isSelected = false;\n    });\n    // reset context menu flag on mouse down\n    // to ensure the scrolling is allowed in the next selection\n    addEvent(contentEl, 'mousedown', function () {\n        isContextMenuOpened = false;\n    });\n    addEvent(contentEl, 'selectstart', function () {\n        if (isContextMenuOpened) {\n            return;\n        }\n        cancelAnimationFrame(animationID);\n        isSelected = true;\n    });\n    addEvent(window, 'mouseup blur', function () {\n        cancelAnimationFrame(animationID);\n        isSelected = false;\n        isContextMenuOpened = false;\n    });\n    // patch for touch devices\n    addEvent(containerEl, 'scroll', function (evt) {\n        evt.preventDefault();\n        containerEl.scrollTop = containerEl.scrollLeft = 0;\n    });\n}\nfunction calcMomentum(scrollbar, evt) {\n    var _a = scrollbar.bounding, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\n    var _b = Object(_utils___WEBPACK_IMPORTED_MODULE_1__[\"getPosition\"])(evt), x = _b.x, y = _b.y;\n    var res = {\n        x: 0,\n        y: 0,\n    };\n    var padding = 20;\n    if (x === 0 && y === 0)\n        return res;\n    if (x > right - padding) {\n        res.x = (x - right + padding);\n    }\n    else if (x < left + padding) {\n        res.x = (x - left - padding);\n    }\n    if (y > bottom - padding) {\n        res.y = (y - bottom + padding);\n    }\n    else if (y < top + padding) {\n        res.y = (y - top - padding);\n    }\n    res.x *= 2;\n    res.y *= 2;\n    return res;\n}\n//# sourceMappingURL=select.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/select.js?")},"./node_modules/smooth-scrollbar/events/touch.js":function node_modulesSmoothScrollbarEventsTouchJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchHandler", function() { return touchHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\nvar activeScrollbar;\nfunction touchHandler(scrollbar) {\n    var target = scrollbar.options.delegateTo || scrollbar.containerEl;\n    var touchRecord = new _utils___WEBPACK_IMPORTED_MODULE_0__["TouchRecord"]();\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__["eventScope"])(scrollbar);\n    var damping;\n    var pointerCount = 0;\n    addEvent(target, \'touchstart\', function (evt) {\n        // start records\n        touchRecord.track(evt);\n        // stop scrolling\n        scrollbar.setMomentum(0, 0);\n        // save damping\n        if (pointerCount === 0) {\n            damping = scrollbar.options.damping;\n            scrollbar.options.damping = Math.max(damping, 0.5); // less frames on touchmove\n        }\n        pointerCount++;\n    });\n    addEvent(target, \'touchmove\', function (evt) {\n        if (activeScrollbar && activeScrollbar !== scrollbar)\n            return;\n        touchRecord.update(evt);\n        var _a = touchRecord.getDelta(), x = _a.x, y = _a.y;\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll && evt.cancelable) {\n                evt.preventDefault();\n                activeScrollbar = scrollbar;\n            }\n        });\n    });\n    addEvent(target, \'touchcancel touchend\', function (evt) {\n        var delta = touchRecord.getEasingDistance(damping);\n        scrollbar.addTransformableMomentum(delta.x, delta.y, evt);\n        pointerCount--;\n        // restore damping\n        if (pointerCount === 0) {\n            scrollbar.options.damping = damping;\n        }\n        touchRecord.release(evt);\n        activeScrollbar = null;\n    });\n}\n//# sourceMappingURL=touch.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/touch.js?')},"./node_modules/smooth-scrollbar/events/wheel.js":function node_modulesSmoothScrollbarEventsWheelJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wheelHandler\", function() { return wheelHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ \"./node_modules/smooth-scrollbar/utils/index.js\");\n\nfunction wheelHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__[\"eventScope\"])(scrollbar);\n    var target = scrollbar.options.delegateTo || scrollbar.containerEl;\n    var eventName = ('onwheel' in window || document.implementation.hasFeature('Events.wheel', '3.0')) ? 'wheel' : 'mousewheel';\n    addEvent(target, eventName, function (evt) {\n        var _a = normalizeDelta(evt), x = _a.x, y = _a.y;\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll) {\n                evt.preventDefault();\n            }\n        });\n    });\n}\n// Normalizing wheel delta\nvar DELTA_SCALE = {\n    STANDARD: 1,\n    OTHERS: -3,\n};\nvar DELTA_MODE = [1.0, 28.0, 500.0];\nvar getDeltaMode = function (mode) { return DELTA_MODE[mode] || DELTA_MODE[0]; };\nfunction normalizeDelta(evt) {\n    if ('deltaX' in evt) {\n        var mode = getDeltaMode(evt.deltaMode);\n        return {\n            x: evt.deltaX / DELTA_SCALE.STANDARD * mode,\n            y: evt.deltaY / DELTA_SCALE.STANDARD * mode,\n        };\n    }\n    if ('wheelDeltaX' in evt) {\n        return {\n            x: evt.wheelDeltaX / DELTA_SCALE.OTHERS,\n            y: evt.wheelDeltaY / DELTA_SCALE.OTHERS,\n        };\n    }\n    // ie with touchpad\n    return {\n        x: 0,\n        y: evt.wheelDelta / DELTA_SCALE.OTHERS,\n    };\n}\n//# sourceMappingURL=wheel.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/wheel.js?")},"./node_modules/smooth-scrollbar/geometry/get-size.js":function node_modulesSmoothScrollbarGeometryGetSizeJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSize\", function() { return getSize; });\nfunction getSize(scrollbar) {\n    var containerEl = scrollbar.containerEl, contentEl = scrollbar.contentEl;\n    var containerStyles = getComputedStyle(containerEl);\n    var paddings = [\n        'paddingTop',\n        'paddingBottom',\n        'paddingLeft',\n        'paddingRight',\n    ].map(function (prop) {\n        return containerStyles[prop] ? parseFloat(containerStyles[prop]) : 0;\n    });\n    var verticalPadding = paddings[0] + paddings[1];\n    var horizontalPadding = paddings[2] + paddings[3];\n    return {\n        container: {\n            // requires `overflow: hidden`\n            width: containerEl.clientWidth,\n            height: containerEl.clientHeight,\n        },\n        content: {\n            // border width and paddings should be included\n            width: contentEl.offsetWidth - contentEl.clientWidth + contentEl.scrollWidth + horizontalPadding,\n            height: contentEl.offsetHeight - contentEl.clientHeight + contentEl.scrollHeight + verticalPadding,\n        },\n    };\n}\n//# sourceMappingURL=get-size.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/get-size.js?")},"./node_modules/smooth-scrollbar/geometry/index.js":function node_modulesSmoothScrollbarGeometryIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _get_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-size */ "./node_modules/smooth-scrollbar/geometry/get-size.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return _get_size__WEBPACK_IMPORTED_MODULE_0__["getSize"]; });\n\n/* harmony import */ var _is_visible__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-visible */ "./node_modules/smooth-scrollbar/geometry/is-visible.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isVisible", function() { return _is_visible__WEBPACK_IMPORTED_MODULE_1__["isVisible"]; });\n\n/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./update */ "./node_modules/smooth-scrollbar/geometry/update.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "update", function() { return _update__WEBPACK_IMPORTED_MODULE_2__["update"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/index.js?')},"./node_modules/smooth-scrollbar/geometry/is-visible.js":function node_modulesSmoothScrollbarGeometryIsVisibleJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVisible", function() { return isVisible; });\nfunction isVisible(scrollbar, elem) {\n    var bounding = scrollbar.bounding;\n    var targetBounding = elem.getBoundingClientRect();\n    // check overlapping\n    var top = Math.max(bounding.top, targetBounding.top);\n    var left = Math.max(bounding.left, targetBounding.left);\n    var right = Math.min(bounding.right, targetBounding.right);\n    var bottom = Math.min(bounding.bottom, targetBounding.bottom);\n    return top < bottom && left < right;\n}\n//# sourceMappingURL=is-visible.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/is-visible.js?')},"./node_modules/smooth-scrollbar/geometry/update.js":function node_modulesSmoothScrollbarGeometryUpdateJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });\nfunction update(scrollbar) {\n    var newSize = scrollbar.getSize();\n    var limit = {\n        x: Math.max(newSize.content.width - newSize.container.width, 0),\n        y: Math.max(newSize.content.height - newSize.container.height, 0),\n    };\n    // metrics\n    var containerBounding = scrollbar.containerEl.getBoundingClientRect();\n    var bounding = {\n        top: Math.max(containerBounding.top, 0),\n        right: Math.min(containerBounding.right, window.innerWidth),\n        bottom: Math.min(containerBounding.bottom, window.innerHeight),\n        left: Math.max(containerBounding.left, 0),\n    };\n    // assign props\n    scrollbar.size = newSize;\n    scrollbar.limit = limit;\n    scrollbar.bounding = bounding;\n    // update tracks\n    scrollbar.track.update();\n    // re-positioning\n    scrollbar.setPosition();\n}\n//# sourceMappingURL=update.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/update.js?')},"./node_modules/smooth-scrollbar/index.js":function node_modulesSmoothScrollbarIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfills */ "./node_modules/smooth-scrollbar/polyfills.js");\n/* harmony import */ var _scrollbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scrollbar */ "./node_modules/smooth-scrollbar/scrollbar.js");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugin */ "./node_modules/smooth-scrollbar/plugin.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScrollbarPlugin", function() { return _plugin__WEBPACK_IMPORTED_MODULE_3__["ScrollbarPlugin"]; });\n\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ "./node_modules/smooth-scrollbar/style.js");\n\n\n\n\n\n\n/**\n * cast `I.Scrollbar` to `Scrollbar` to avoid error\n *\n * `I.Scrollbar` is not assignable to `Scrollbar`:\n *     "privateProp" is missing in `I.Scrollbar`\n *\n * @see https://github.com/Microsoft/TypeScript/issues/2672\n */\nvar SmoothScrollbar = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(SmoothScrollbar, _super);\n    function SmoothScrollbar() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Initializes a scrollbar on the given element.\n     *\n     * @param elem The DOM element that you want to initialize scrollbar to\n     * @param [options] Initial options\n     */\n    SmoothScrollbar.init = function (elem, options) {\n        if (!elem || elem.nodeType !== 1) {\n            throw new TypeError("expect element to be DOM Element, but got " + elem);\n        }\n        // attach stylesheet\n        Object(_style__WEBPACK_IMPORTED_MODULE_4__["attachStyle"])();\n        if (_scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].has(elem)) {\n            return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n        }\n        return new _scrollbar__WEBPACK_IMPORTED_MODULE_2__["Scrollbar"](elem, options);\n    };\n    /**\n     * Automatically init scrollbar on all elements base on the selector `[data-scrollbar]`\n     *\n     * @param options Initial options\n     */\n    SmoothScrollbar.initAll = function (options) {\n        return Array.from(document.querySelectorAll(\'[data-scrollbar]\'), function (elem) {\n            return SmoothScrollbar.init(elem, options);\n        });\n    };\n    /**\n     * Check if there is a scrollbar on given element\n     *\n     * @param elem The DOM element that you want to check\n     */\n    SmoothScrollbar.has = function (elem) {\n        return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].has(elem);\n    };\n    /**\n     * Gets scrollbar on the given element.\n     * If no scrollbar instance exsits, returns `undefined`\n     *\n     * @param elem The DOM element that you want to check.\n     */\n    SmoothScrollbar.get = function (elem) {\n        return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n    };\n    /**\n     * Returns an array that contains all scrollbar instances\n     */\n    SmoothScrollbar.getAll = function () {\n        return Array.from(_scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].values());\n    };\n    /**\n     * Removes scrollbar on the given element\n     */\n    SmoothScrollbar.destroy = function (elem) {\n        var scrollbar = _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n        if (scrollbar) {\n            scrollbar.destroy();\n        }\n    };\n    /**\n     * Removes all scrollbar instances from current document\n     */\n    SmoothScrollbar.destroyAll = function () {\n        _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].forEach(function (scrollbar) {\n            scrollbar.destroy();\n        });\n    };\n    /**\n     * Attaches plugins to scrollbars\n     *\n     * @param ...Plugins Scrollbar plugin classes\n     */\n    SmoothScrollbar.use = function () {\n        var Plugins = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            Plugins[_i] = arguments[_i];\n        }\n        return _plugin__WEBPACK_IMPORTED_MODULE_3__["addPlugins"].apply(void 0, Plugins);\n    };\n    /**\n     * Attaches default style sheets to current document.\n     * You don\'t need to call this method manually unless\n     * you removed the default styles via `Scrollbar.detachStyle()`\n     */\n    SmoothScrollbar.attachStyle = function () {\n        return Object(_style__WEBPACK_IMPORTED_MODULE_4__["attachStyle"])();\n    };\n    /**\n     * Removes default styles from current document.\n     * Use this method when you want to use your own css for scrollbars.\n     */\n    SmoothScrollbar.detachStyle = function () {\n        return Object(_style__WEBPACK_IMPORTED_MODULE_4__["detachStyle"])();\n    };\n    SmoothScrollbar.version = "8.8.1";\n    SmoothScrollbar.ScrollbarPlugin = _plugin__WEBPACK_IMPORTED_MODULE_3__["ScrollbarPlugin"];\n    return SmoothScrollbar;\n}(_scrollbar__WEBPACK_IMPORTED_MODULE_2__["Scrollbar"]));\n/* harmony default export */ __webpack_exports__["default"] = (SmoothScrollbar);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/index.js?')},"./node_modules/smooth-scrollbar/options.js":function node_modulesSmoothScrollbarOptionsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Options", function() { return Options; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n\n\nvar Options = /** @class */ (function () {\n    function Options(config) {\n        var _this = this;\n        if (config === void 0) { config = {}; }\n        /**\n         * Momentum reduction damping factor, a float value between `(0, 1)`.\n         * The lower the value is, the more smooth the scrolling will be\n         * (also the more paint frames).\n         */\n        this.damping = 0.1;\n        /**\n         * Minimal size for scrollbar thumbs.\n         */\n        this.thumbMinSize = 20;\n        /**\n         * Render every frame in integer pixel values\n         * set to `true` to improve scrolling performance.\n         */\n        this.renderByPixels = true;\n        /**\n         * Keep scrollbar tracks visible\n         */\n        this.alwaysShowTracks = false;\n        /**\n         * Set to `true` to allow outer scrollbars continue scrolling\n         * when current scrollbar reaches edge.\n         */\n        this.continuousScrolling = true;\n        /**\n         * Delegate wheel events and touch events to the given element.\n         * By default, the container element is used.\n         * This option will be useful for dealing with fixed elements.\n         */\n        this.delegateTo = null;\n        /**\n         * Options for plugins. Syntax:\n         *   plugins[pluginName] = pluginOptions: any\n         */\n        this.plugins = {};\n        Object.keys(config).forEach(function (prop) {\n            _this[prop] = config[prop];\n        });\n    }\n    Object.defineProperty(Options.prototype, "wheelEventTarget", {\n        get: function () {\n            return this.delegateTo;\n        },\n        set: function (el) {\n            console.warn(\'[smooth-scrollbar]: `options.wheelEventTarget` is deprecated and will be removed in the future, use `options.delegateTo` instead.\');\n            this.delegateTo = el;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_1__["range"])(0, 1)\n    ], Options.prototype, "damping", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_1__["range"])(0, Infinity)\n    ], Options.prototype, "thumbMinSize", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "renderByPixels", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "alwaysShowTracks", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "continuousScrolling", void 0);\n    return Options;\n}());\n\n//# sourceMappingURL=options.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/options.js?')},"./node_modules/smooth-scrollbar/plugin.js":function node_modulesSmoothScrollbarPluginJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarPlugin", function() { return ScrollbarPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalPlugins", function() { return globalPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPlugins", function() { return addPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initPlugins", function() { return initPlugins; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n\nvar ScrollbarPlugin = /** @class */ (function () {\n    function ScrollbarPlugin(scrollbar, options) {\n        var _newTarget = this.constructor;\n        this.scrollbar = scrollbar;\n        this.name = _newTarget.pluginName;\n        this.options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, _newTarget.defaultOptions), options);\n    }\n    ScrollbarPlugin.prototype.onInit = function () { };\n    ScrollbarPlugin.prototype.onDestroy = function () { };\n    ScrollbarPlugin.prototype.onUpdate = function () { };\n    ScrollbarPlugin.prototype.onRender = function (_remainMomentum) { };\n    ScrollbarPlugin.prototype.transformDelta = function (delta, _evt) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, delta);\n    };\n    ScrollbarPlugin.pluginName = \'\';\n    ScrollbarPlugin.defaultOptions = {};\n    return ScrollbarPlugin;\n}());\n\nvar globalPlugins = {\n    order: new Set(),\n    constructors: {},\n};\nfunction addPlugins() {\n    var Plugins = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Plugins[_i] = arguments[_i];\n    }\n    Plugins.forEach(function (P) {\n        var pluginName = P.pluginName;\n        if (!pluginName) {\n            throw new TypeError("plugin name is required");\n        }\n        globalPlugins.order.add(pluginName);\n        globalPlugins.constructors[pluginName] = P;\n    });\n}\nfunction initPlugins(scrollbar, options) {\n    return Array.from(globalPlugins.order)\n        .filter(function (pluginName) {\n        return options[pluginName] !== false;\n    })\n        .map(function (pluginName) {\n        var Plugin = globalPlugins.constructors[pluginName];\n        var instance = new Plugin(scrollbar, options[pluginName]);\n        // bind plugin options to `scrollbar.options`\n        options[pluginName] = instance.options;\n        return instance;\n    });\n}\n//# sourceMappingURL=plugin.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/plugin.js?')},"./node_modules/smooth-scrollbar/polyfills.js":function node_modulesSmoothScrollbarPolyfillsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_es_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es/map */ "./node_modules/core-js/es/map/index.js");\n/* harmony import */ var core_js_es_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_es_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/es/set */ "./node_modules/core-js/es/set/index.js");\n/* harmony import */ var core_js_es_set__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_es_set__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/es/weak-map */ "./node_modules/core-js/es/weak-map/index.js");\n/* harmony import */ var core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/es/array/from */ "./node_modules/core-js/es/array/from.js");\n/* harmony import */ var core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/es/object/assign */ "./node_modules/core-js/es/object/assign.js");\n/* harmony import */ var core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n//# sourceMappingURL=polyfills.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/polyfills.js?')},"./node_modules/smooth-scrollbar/scrollbar.js":function node_modulesSmoothScrollbarScrollbarJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollbarMap", function() { return scrollbarMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scrollbar", function() { return Scrollbar; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options */ "./node_modules/smooth-scrollbar/options.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n/* harmony import */ var _track___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./track/ */ "./node_modules/smooth-scrollbar/track/index.js");\n/* harmony import */ var _geometry___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geometry/ */ "./node_modules/smooth-scrollbar/geometry/index.js");\n/* harmony import */ var _scrolling___WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scrolling/ */ "./node_modules/smooth-scrollbar/scrolling/index.js");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugin */ "./node_modules/smooth-scrollbar/plugin.js");\n/* harmony import */ var _events___WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events/ */ "./node_modules/smooth-scrollbar/events/index.js");\n\n\n\n\n\n\n\n\n\n\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nvar scrollbarMap = new Map();\nvar Scrollbar = /** @class */ (function () {\n    function Scrollbar(containerEl, options) {\n        var _this = this;\n        /**\n         * Current scrolling offsets\n         */\n        this.offset = {\n            x: 0,\n            y: 0,\n        };\n        /**\n         * Max-allowed scrolling offsets\n         */\n        this.limit = {\n            x: Infinity,\n            y: Infinity,\n        };\n        /**\n         * Container bounding rect\n         */\n        this.bounding = {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n        };\n        // private _observer: ResizeObserver;\n        this._plugins = [];\n        this._momentum = { x: 0, y: 0 };\n        this._listeners = new Set();\n        this.containerEl = containerEl;\n        var contentEl = this.contentEl = document.createElement(\'div\');\n        this.options = new _options__WEBPACK_IMPORTED_MODULE_2__["Options"](options);\n        // mark as a scroll element\n        containerEl.setAttribute(\'data-scrollbar\', \'true\');\n        // make container focusable\n        containerEl.setAttribute(\'tabindex\', \'-1\');\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["setStyle"])(containerEl, {\n            overflow: \'hidden\',\n            outline: \'none\',\n        });\n        // enable touch event capturing in IE, see:\n        // https://github.com/idiotWu/smooth-scrollbar/issues/39\n        if (window.navigator.msPointerEnabled) {\n            containerEl.style.msTouchAction = \'none\';\n        }\n        // mount content\n        contentEl.className = \'scroll-content\';\n        Array.from(containerEl.childNodes).forEach(function (node) {\n            contentEl.appendChild(node);\n        });\n        containerEl.appendChild(contentEl);\n        // attach track\n        this.track = new _track___WEBPACK_IMPORTED_MODULE_5__["TrackController"](this);\n        // initial measuring\n        this.size = this.getSize();\n        // init plugins\n        this._plugins = Object(_plugin__WEBPACK_IMPORTED_MODULE_8__["initPlugins"])(this, this.options.plugins);\n        // preserve scroll offset\n        var scrollLeft = containerEl.scrollLeft, scrollTop = containerEl.scrollTop;\n        containerEl.scrollLeft = containerEl.scrollTop = 0;\n        this.setPosition(scrollLeft, scrollTop, {\n            withoutCallbacks: true,\n        });\n        // FIXME: update typescript\n        var ResizeObserver = window.ResizeObserver;\n        // observe\n        if (typeof ResizeObserver === \'function\') {\n            this._observer = new ResizeObserver(function () {\n                _this.update();\n            });\n            this._observer.observe(contentEl);\n        }\n        scrollbarMap.set(containerEl, this);\n        // wait for DOM ready\n        requestAnimationFrame(function () {\n            _this._init();\n        });\n    }\n    Object.defineProperty(Scrollbar.prototype, "parent", {\n        /**\n         * Parent scrollbar\n         */\n        get: function () {\n            var elem = this.containerEl.parentElement;\n            while (elem) {\n                var parentScrollbar = scrollbarMap.get(elem);\n                if (parentScrollbar) {\n                    return parentScrollbar;\n                }\n                elem = elem.parentElement;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Scrollbar.prototype, "scrollTop", {\n        /**\n         * Gets or sets `scrollbar.offset.y`\n         */\n        get: function () {\n            return this.offset.y;\n        },\n        set: function (y) {\n            this.setPosition(this.scrollLeft, y);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Scrollbar.prototype, "scrollLeft", {\n        /**\n         * Gets or sets `scrollbar.offset.x`\n         */\n        get: function () {\n            return this.offset.x;\n        },\n        set: function (x) {\n            this.setPosition(x, this.scrollTop);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the size of the scrollbar container element\n     * and the content wrapper element\n     */\n    Scrollbar.prototype.getSize = function () {\n        return Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["getSize"])(this);\n    };\n    /**\n     * Forces scrollbar to update geometry infomation.\n     *\n     * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n     * You can call this method to force an update when you modified contents\n     */\n    Scrollbar.prototype.update = function () {\n        Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["update"])(this);\n        this._plugins.forEach(function (plugin) {\n            plugin.onUpdate();\n        });\n    };\n    /**\n     * Checks if an element is visible in the current view area\n     */\n    Scrollbar.prototype.isVisible = function (elem) {\n        return Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["isVisible"])(this, elem);\n    };\n    /**\n     * Sets the scrollbar to the given offset without easing\n     */\n    Scrollbar.prototype.setPosition = function (x, y, options) {\n        var _this = this;\n        if (x === void 0) { x = this.offset.x; }\n        if (y === void 0) { y = this.offset.y; }\n        if (options === void 0) { options = {}; }\n        var status = Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["setPosition"])(this, x, y);\n        if (!status || options.withoutCallbacks) {\n            return;\n        }\n        this._listeners.forEach(function (fn) {\n            fn.call(_this, status);\n        });\n    };\n    /**\n     * Scrolls to given position with easing function\n     */\n    Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n        if (x === void 0) { x = this.offset.x; }\n        if (y === void 0) { y = this.offset.y; }\n        if (duration === void 0) { duration = 0; }\n        if (options === void 0) { options = {}; }\n        Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["scrollTo"])(this, x, y, duration, options);\n    };\n    /**\n     * Scrolls the target element into visible area of scrollbar,\n     * likes the DOM method `element.scrollIntoView().\n     */\n    Scrollbar.prototype.scrollIntoView = function (elem, options) {\n        if (options === void 0) { options = {}; }\n        Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["scrollIntoView"])(this, elem, options);\n    };\n    /**\n     * Adds scrolling listener\n     */\n    Scrollbar.prototype.addListener = function (fn) {\n        if (typeof fn !== \'function\') {\n            throw new TypeError(\'[smooth-scrollbar] scrolling listener should be a function\');\n        }\n        this._listeners.add(fn);\n    };\n    /**\n     * Removes listener previously registered with `scrollbar.addListener()`\n     */\n    Scrollbar.prototype.removeListener = function (fn) {\n        this._listeners.delete(fn);\n    };\n    /**\n     * Adds momentum and applys delta transformers.\n     */\n    Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n        this._updateDebounced();\n        var finalDelta = this._plugins.reduce(function (delta, plugin) {\n            return plugin.transformDelta(delta, fromEvent) || delta;\n        }, { x: x, y: y });\n        var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n        if (willScroll) {\n            this.addMomentum(finalDelta.x, finalDelta.y);\n        }\n        if (callback) {\n            callback.call(this, willScroll);\n        }\n    };\n    /**\n     * Increases scrollbar\'s momentum\n     */\n    Scrollbar.prototype.addMomentum = function (x, y) {\n        this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n    };\n    /**\n     * Sets scrollbar\'s momentum to given value\n     */\n    Scrollbar.prototype.setMomentum = function (x, y) {\n        if (this.limit.x === 0) {\n            x = 0;\n        }\n        if (this.limit.y === 0) {\n            y = 0;\n        }\n        if (this.options.renderByPixels) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        this._momentum.x = x;\n        this._momentum.y = y;\n    };\n    /**\n     * Update options for specific plugin\n     *\n     * @param pluginName Name of the plugin\n     * @param [options] An object includes the properties that you want to update\n     */\n    Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n        this._plugins.forEach(function (plugin) {\n            if (plugin.name === pluginName) {\n                Object.assign(plugin.options, options);\n            }\n        });\n    };\n    Scrollbar.prototype.destroy = function () {\n        var _a = this, containerEl = _a.containerEl, contentEl = _a.contentEl;\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["clearEventsOn"])(this);\n        this._listeners.clear();\n        this.setMomentum(0, 0);\n        cancelAnimationFrame(this._renderID);\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n        scrollbarMap.delete(this.containerEl);\n        // restore contents\n        var childNodes = Array.from(contentEl.childNodes);\n        while (containerEl.firstChild) {\n            containerEl.removeChild(containerEl.firstChild);\n        }\n        childNodes.forEach(function (el) {\n            containerEl.appendChild(el);\n        });\n        // reset scroll position\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["setStyle"])(containerEl, {\n            overflow: \'\',\n        });\n        containerEl.scrollTop = this.scrollTop;\n        containerEl.scrollLeft = this.scrollLeft;\n        // invoke plugin.onDestroy\n        this._plugins.forEach(function (plugin) {\n            plugin.onDestroy();\n        });\n        this._plugins.length = 0;\n    };\n    Scrollbar.prototype._init = function () {\n        var _this = this;\n        this.update();\n        // init evet handlers\n        Object.keys(_events___WEBPACK_IMPORTED_MODULE_9__).forEach(function (prop) {\n            _events___WEBPACK_IMPORTED_MODULE_9__[prop](_this);\n        });\n        // invoke `plugin.onInit`\n        this._plugins.forEach(function (plugin) {\n            plugin.onInit();\n        });\n        this._render();\n    };\n    Scrollbar.prototype._updateDebounced = function () {\n        this.update();\n    };\n    // check whether to propagate monmentum to parent scrollbar\n    // the following situations are considered as `true`:\n    //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n    //         2. scrollbar reaches one side and is not about to scroll on the other direction\n    Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n        if (deltaX === void 0) { deltaX = 0; }\n        if (deltaY === void 0) { deltaY = 0; }\n        var _a = this, options = _a.options, offset = _a.offset, limit = _a.limit;\n        if (!options.continuousScrolling)\n            return false;\n        // force an update when scrollbar is "unscrollable", see #106\n        if (limit.x === 0 && limit.y === 0) {\n            this._updateDebounced();\n        }\n        var destX = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(deltaX + offset.x, 0, limit.x);\n        var destY = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(deltaY + offset.y, 0, limit.y);\n        var res = true;\n        // offsets are not about to change\n        // `&=` operator is not allowed for boolean types\n        res = res && (destX === offset.x);\n        res = res && (destY === offset.y);\n        // current offsets are on the edge\n        res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n        return res;\n    };\n    Scrollbar.prototype._render = function () {\n        var _momentum = this._momentum;\n        if (_momentum.x || _momentum.y) {\n            var nextX = this._nextTick(\'x\');\n            var nextY = this._nextTick(\'y\');\n            _momentum.x = nextX.momentum;\n            _momentum.y = nextY.momentum;\n            this.setPosition(nextX.position, nextY.position);\n        }\n        var remain = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, this._momentum);\n        this._plugins.forEach(function (plugin) {\n            plugin.onRender(remain);\n        });\n        this._renderID = requestAnimationFrame(this._render.bind(this));\n    };\n    Scrollbar.prototype._nextTick = function (direction) {\n        var _a = this, options = _a.options, offset = _a.offset, _momentum = _a._momentum;\n        var current = offset[direction];\n        var remain = _momentum[direction];\n        if (Math.abs(remain) <= 0.1) {\n            return {\n                momentum: 0,\n                position: current + remain,\n            };\n        }\n        var nextMomentum = remain * (1 - options.damping);\n        if (options.renderByPixels) {\n            nextMomentum |= 0;\n        }\n        return {\n            momentum: nextMomentum,\n            position: current + remain - nextMomentum,\n        };\n    };\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_4__["debounce"])(100, { leading: true })\n    ], Scrollbar.prototype, "_updateDebounced", null);\n    return Scrollbar;\n}());\n\n//# sourceMappingURL=scrollbar.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrollbar.js?')},"./node_modules/smooth-scrollbar/scrolling/index.js":function node_modulesSmoothScrollbarScrollingIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _set_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set-position */ "./node_modules/smooth-scrollbar/scrolling/set-position.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPosition", function() { return _set_position__WEBPACK_IMPORTED_MODULE_0__["setPosition"]; });\n\n/* harmony import */ var _scroll_to__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scroll-to */ "./node_modules/smooth-scrollbar/scrolling/scroll-to.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scrollTo", function() { return _scroll_to__WEBPACK_IMPORTED_MODULE_1__["scrollTo"]; });\n\n/* harmony import */ var _scroll_into_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scroll-into-view */ "./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scrollIntoView", function() { return _scroll_into_view__WEBPACK_IMPORTED_MODULE_2__["scrollIntoView"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/index.js?')},"./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js":function node_modulesSmoothScrollbarScrollingScrollIntoViewJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollIntoView", function() { return scrollIntoView; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction scrollIntoView(scrollbar, elem, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.alignToTop, alignToTop = _c === void 0 ? true : _c, _d = _b.onlyScrollIfNeeded, onlyScrollIfNeeded = _d === void 0 ? false : _d, _e = _b.offsetTop, offsetTop = _e === void 0 ? 0 : _e, _f = _b.offsetLeft, offsetLeft = _f === void 0 ? 0 : _f, _g = _b.offsetBottom, offsetBottom = _g === void 0 ? 0 : _g;\n    var containerEl = scrollbar.containerEl, bounding = scrollbar.bounding, offset = scrollbar.offset, limit = scrollbar.limit;\n    if (!elem || !containerEl.contains(elem))\n        return;\n    var targetBounding = elem.getBoundingClientRect();\n    if (onlyScrollIfNeeded && scrollbar.isVisible(elem))\n        return;\n    var delta = alignToTop ? targetBounding.top - bounding.top - offsetTop : targetBounding.bottom - bounding.bottom + offsetBottom;\n    scrollbar.setMomentum(targetBounding.left - bounding.left - offsetLeft, lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(delta, -offset.y, limit.y - offset.y));\n}\n//# sourceMappingURL=scroll-into-view.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js?')},"./node_modules/smooth-scrollbar/scrolling/scroll-to.js":function node_modulesSmoothScrollbarScrollingScrollToJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollTo", function() { return scrollTo; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nvar animationIDStorage = new WeakMap();\nfunction scrollTo(scrollbar, x, y, duration, _a) {\n    if (duration === void 0) { duration = 0; }\n    var _b = _a === void 0 ? {} : _a, _c = _b.easing, easing = _c === void 0 ? defaultEasing : _c, callback = _b.callback;\n    var options = scrollbar.options, offset = scrollbar.offset, limit = scrollbar.limit;\n    if (options.renderByPixels) {\n        // ensure resolved with integer\n        x = Math.round(x);\n        y = Math.round(y);\n    }\n    var startX = offset.x;\n    var startY = offset.y;\n    var disX = lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(x, 0, limit.x) - startX;\n    var disY = lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(y, 0, limit.y) - startY;\n    var start = Date.now();\n    function scroll() {\n        var elapse = Date.now() - start;\n        var progress = duration ? easing(Math.min(elapse / duration, 1)) : 1;\n        scrollbar.setPosition(startX + disX * progress, startY + disY * progress);\n        if (elapse >= duration) {\n            if (typeof callback === \'function\') {\n                callback.call(scrollbar);\n            }\n        }\n        else {\n            var animationID = requestAnimationFrame(scroll);\n            animationIDStorage.set(scrollbar, animationID);\n        }\n    }\n    cancelAnimationFrame(animationIDStorage.get(scrollbar));\n    scroll();\n}\n/**\n * easeOutCubic\n */\nfunction defaultEasing(t) {\n    return Math.pow((t - 1), 3) + 1;\n}\n//# sourceMappingURL=scroll-to.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/scroll-to.js?')},"./node_modules/smooth-scrollbar/scrolling/set-position.js":function node_modulesSmoothScrollbarScrollingSetPositionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPosition", function() { return setPosition; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\n\nfunction setPosition(scrollbar, x, y) {\n    var options = scrollbar.options, offset = scrollbar.offset, limit = scrollbar.limit, track = scrollbar.track, contentEl = scrollbar.contentEl;\n    if (options.renderByPixels) {\n        x = Math.round(x);\n        y = Math.round(y);\n    }\n    x = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(x, 0, limit.x);\n    y = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(y, 0, limit.y);\n    // position changed -> show track for 300ms\n    if (x !== offset.x)\n        track.xAxis.show();\n    if (y !== offset.y)\n        track.yAxis.show();\n    if (!options.alwaysShowTracks) {\n        track.autoHideOnIdle();\n    }\n    if (x === offset.x && y === offset.y) {\n        return null;\n    }\n    offset.x = x;\n    offset.y = y;\n    Object(_utils___WEBPACK_IMPORTED_MODULE_2__["setStyle"])(contentEl, {\n        \'-transform\': "translate3d(" + -x + "px, " + -y + "px, 0)",\n    });\n    track.update();\n    return {\n        offset: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, offset),\n        limit: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, limit),\n    };\n}\n//# sourceMappingURL=set-position.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/set-position.js?')},"./node_modules/smooth-scrollbar/style.js":function node_modulesSmoothScrollbarStyleJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachStyle\", function() { return attachStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detachStyle\", function() { return detachStyle; });\nvar TRACK_BG = 'rgba(222, 222, 222, .75)';\nvar THUMB_BG = 'rgba(0, 0, 0, .5)';\n// sets content's display type to `flow-root` to suppress margin collapsing\nvar SCROLLBAR_STYLE = \"\\n[data-scrollbar] {\\n  display: block;\\n  position: relative;\\n}\\n\\n.scroll-content {\\n  display: flow-root;\\n  -webkit-transform: translate3d(0, 0, 0);\\n          transform: translate3d(0, 0, 0);\\n}\\n\\n.scrollbar-track {\\n  position: absolute;\\n  opacity: 0;\\n  z-index: 1;\\n  background: \" + TRACK_BG + \";\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  -webkit-transition: opacity 0.5s 0.5s ease-out;\\n          transition: opacity 0.5s 0.5s ease-out;\\n}\\n.scrollbar-track.show,\\n.scrollbar-track:hover {\\n  opacity: 1;\\n  -webkit-transition-delay: 0s;\\n          transition-delay: 0s;\\n}\\n\\n.scrollbar-track-x {\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 8px;\\n}\\n.scrollbar-track-y {\\n  top: 0;\\n  right: 0;\\n  width: 8px;\\n  height: 100%;\\n}\\n.scrollbar-thumb {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 8px;\\n  height: 8px;\\n  background: \" + THUMB_BG + \";\\n  border-radius: 4px;\\n}\\n\";\nvar STYLE_ID = 'smooth-scrollbar-style';\nvar isStyleAttached = false;\nfunction attachStyle() {\n    if (isStyleAttached || typeof window === 'undefined') {\n        return;\n    }\n    var styleEl = document.createElement('style');\n    styleEl.id = STYLE_ID;\n    styleEl.textContent = SCROLLBAR_STYLE;\n    if (document.head) {\n        document.head.appendChild(styleEl);\n    }\n    isStyleAttached = true;\n}\nfunction detachStyle() {\n    if (!isStyleAttached || typeof window === 'undefined') {\n        return;\n    }\n    var styleEl = document.getElementById(STYLE_ID);\n    if (!styleEl || !styleEl.parentNode) {\n        return;\n    }\n    styleEl.parentNode.removeChild(styleEl);\n    isStyleAttached = false;\n}\n//# sourceMappingURL=style.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/style.js?")},"./node_modules/smooth-scrollbar/track/direction.js":function node_modulesSmoothScrollbarTrackDirectionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackDirection", function() { return TrackDirection; });\nvar TrackDirection;\n(function (TrackDirection) {\n    TrackDirection["X"] = "x";\n    TrackDirection["Y"] = "y";\n})(TrackDirection || (TrackDirection = {}));\n//# sourceMappingURL=direction.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/direction.js?')},"./node_modules/smooth-scrollbar/track/index.js":function node_modulesSmoothScrollbarTrackIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackController", function() { return TrackController; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _track__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track */ "./node_modules/smooth-scrollbar/track/track.js");\n/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./direction */ "./node_modules/smooth-scrollbar/track/direction.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n\n\n\n\nvar TrackController = /** @class */ (function () {\n    function TrackController(_scrollbar) {\n        this._scrollbar = _scrollbar;\n        var thumbMinSize = _scrollbar.options.thumbMinSize;\n        this.xAxis = new _track__WEBPACK_IMPORTED_MODULE_1__["ScrollbarTrack"](_direction__WEBPACK_IMPORTED_MODULE_2__["TrackDirection"].X, thumbMinSize);\n        this.yAxis = new _track__WEBPACK_IMPORTED_MODULE_1__["ScrollbarTrack"](_direction__WEBPACK_IMPORTED_MODULE_2__["TrackDirection"].Y, thumbMinSize);\n        this.xAxis.attachTo(_scrollbar.containerEl);\n        this.yAxis.attachTo(_scrollbar.containerEl);\n        if (_scrollbar.options.alwaysShowTracks) {\n            this.xAxis.show();\n            this.yAxis.show();\n        }\n    }\n    /**\n     * Updates track appearance\n     */\n    TrackController.prototype.update = function () {\n        var _a = this._scrollbar, size = _a.size, offset = _a.offset;\n        this.xAxis.update(offset.x, size.container.width, size.content.width);\n        this.yAxis.update(offset.y, size.container.height, size.content.height);\n    };\n    /**\n     * Automatically hide tracks when scrollbar is in idle state\n     */\n    TrackController.prototype.autoHideOnIdle = function () {\n        if (this._scrollbar.options.alwaysShowTracks) {\n            return;\n        }\n        this.xAxis.hide();\n        this.yAxis.hide();\n    };\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_3__["debounce"])(300)\n    ], TrackController.prototype, "autoHideOnIdle", null);\n    return TrackController;\n}());\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/index.js?')},"./node_modules/smooth-scrollbar/track/thumb.js":function node_modulesSmoothScrollbarTrackThumbJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarThumb", function() { return ScrollbarThumb; });\n/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./direction */ "./node_modules/smooth-scrollbar/track/direction.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar ScrollbarThumb = /** @class */ (function () {\n    function ScrollbarThumb(_direction, _minSize) {\n        if (_minSize === void 0) { _minSize = 0; }\n        this._direction = _direction;\n        this._minSize = _minSize;\n        /**\n         * Thumb element\n         */\n        this.element = document.createElement(\'div\');\n        /**\n         * Display size of the thumb\n         * will always be greater than `scrollbar.options.thumbMinSize`\n         */\n        this.displaySize = 0;\n        /**\n         * Actual size of the thumb\n         */\n        this.realSize = 0;\n        /**\n         * Thumb offset to the top\n         */\n        this.offset = 0;\n        this.element.className = "scrollbar-thumb scrollbar-thumb-" + _direction;\n    }\n    /**\n     * Attach to track element\n     *\n     * @param trackEl Track element\n     */\n    ScrollbarThumb.prototype.attachTo = function (trackEl) {\n        trackEl.appendChild(this.element);\n    };\n    ScrollbarThumb.prototype.update = function (scrollOffset, containerSize, pageSize) {\n        // calculate thumb size\n        // pageSize > containerSize -> scrollable\n        this.realSize = Math.min(containerSize / pageSize, 1) * containerSize;\n        this.displaySize = Math.max(this.realSize, this._minSize);\n        // calculate thumb offset\n        this.offset = scrollOffset / pageSize * (containerSize + (this.realSize - this.displaySize));\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(this.element, this._getStyle());\n    };\n    ScrollbarThumb.prototype._getStyle = function () {\n        switch (this._direction) {\n            case _direction__WEBPACK_IMPORTED_MODULE_0__["TrackDirection"].X:\n                return {\n                    width: this.displaySize + "px",\n                    \'-transform\': "translate3d(" + this.offset + "px, 0, 0)",\n                };\n            case _direction__WEBPACK_IMPORTED_MODULE_0__["TrackDirection"].Y:\n                return {\n                    height: this.displaySize + "px",\n                    \'-transform\': "translate3d(0, " + this.offset + "px, 0)",\n                };\n            default:\n                return null;\n        }\n    };\n    return ScrollbarThumb;\n}());\n\n//# sourceMappingURL=thumb.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/thumb.js?')},"./node_modules/smooth-scrollbar/track/track.js":function node_modulesSmoothScrollbarTrackTrackJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarTrack", function() { return ScrollbarTrack; });\n/* harmony import */ var _thumb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thumb */ "./node_modules/smooth-scrollbar/track/thumb.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar ScrollbarTrack = /** @class */ (function () {\n    function ScrollbarTrack(direction, thumbMinSize) {\n        if (thumbMinSize === void 0) { thumbMinSize = 0; }\n        /**\n         * Track element\n         */\n        this.element = document.createElement(\'div\');\n        this._isShown = false;\n        this.element.className = "scrollbar-track scrollbar-track-" + direction;\n        this.thumb = new _thumb__WEBPACK_IMPORTED_MODULE_0__["ScrollbarThumb"](direction, thumbMinSize);\n        this.thumb.attachTo(this.element);\n    }\n    /**\n     * Attach to scrollbar container element\n     *\n     * @param scrollbarContainer Scrollbar container element\n     */\n    ScrollbarTrack.prototype.attachTo = function (scrollbarContainer) {\n        scrollbarContainer.appendChild(this.element);\n    };\n    /**\n     * Show track immediately\n     */\n    ScrollbarTrack.prototype.show = function () {\n        if (this._isShown) {\n            return;\n        }\n        this._isShown = true;\n        this.element.classList.add(\'show\');\n    };\n    /**\n     * Hide track immediately\n     */\n    ScrollbarTrack.prototype.hide = function () {\n        if (!this._isShown) {\n            return;\n        }\n        this._isShown = false;\n        this.element.classList.remove(\'show\');\n    };\n    ScrollbarTrack.prototype.update = function (scrollOffset, containerSize, pageSize) {\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(this.element, {\n            display: pageSize <= containerSize ? \'none\' : \'block\',\n        });\n        this.thumb.update(scrollOffset, containerSize, pageSize);\n    };\n    return ScrollbarTrack;\n}());\n\n//# sourceMappingURL=track.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/track.js?')},"./node_modules/smooth-scrollbar/utils/event-hub.js":function node_modulesSmoothScrollbarUtilsEventHubJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eventScope\", function() { return eventScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearEventsOn\", function() { return clearEventsOn; });\nvar eventListenerOptions;\nvar eventMap = new WeakMap();\nfunction getOptions() {\n    if (eventListenerOptions !== undefined) {\n        return eventListenerOptions;\n    }\n    var supportPassiveEvent = false;\n    try {\n        var noop = function () { };\n        var options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                supportPassiveEvent = true;\n            },\n        });\n        window.addEventListener('testPassive', noop, options);\n        window.removeEventListener('testPassive', noop, options);\n    }\n    catch (e) { }\n    eventListenerOptions = supportPassiveEvent ? { passive: false } : false;\n    return eventListenerOptions;\n}\nfunction eventScope(scrollbar) {\n    var configs = eventMap.get(scrollbar) || [];\n    eventMap.set(scrollbar, configs);\n    return function addEvent(elem, events, fn) {\n        function handler(event) {\n            // ignore default prevented events\n            if (event.defaultPrevented) {\n                return;\n            }\n            fn(event);\n        }\n        events.split(/\\s+/g).forEach(function (eventName) {\n            configs.push({ elem: elem, eventName: eventName, handler: handler });\n            elem.addEventListener(eventName, handler, getOptions());\n        });\n    };\n}\nfunction clearEventsOn(scrollbar) {\n    var configs = eventMap.get(scrollbar);\n    if (!configs) {\n        return;\n    }\n    configs.forEach(function (_a) {\n        var elem = _a.elem, eventName = _a.eventName, handler = _a.handler;\n        elem.removeEventListener(eventName, handler, getOptions());\n    });\n    eventMap.delete(scrollbar);\n}\n//# sourceMappingURL=event-hub.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/event-hub.js?")},"./node_modules/smooth-scrollbar/utils/get-pointer-data.js":function node_modulesSmoothScrollbarUtilsGetPointerDataJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointerData", function() { return getPointerData; });\n/**\n * Get pointer/touch data\n */\nfunction getPointerData(evt) {\n    // if is touch event, return last item in touchList\n    // else return original event\n    return evt.touches ? evt.touches[evt.touches.length - 1] : evt;\n}\n//# sourceMappingURL=get-pointer-data.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/get-pointer-data.js?')},"./node_modules/smooth-scrollbar/utils/get-position.js":function node_modulesSmoothScrollbarUtilsGetPositionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return getPosition; });\n/* harmony import */ var _get_pointer_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-pointer-data */ "./node_modules/smooth-scrollbar/utils/get-pointer-data.js");\n\n/**\n * Get pointer/finger position\n */\nfunction getPosition(evt) {\n    var data = Object(_get_pointer_data__WEBPACK_IMPORTED_MODULE_0__["getPointerData"])(evt);\n    return {\n        x: data.clientX,\n        y: data.clientY,\n    };\n}\n//# sourceMappingURL=get-position.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/get-position.js?')},"./node_modules/smooth-scrollbar/utils/index.js":function node_modulesSmoothScrollbarUtilsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _event_hub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-hub */ "./node_modules/smooth-scrollbar/utils/event-hub.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventScope", function() { return _event_hub__WEBPACK_IMPORTED_MODULE_0__["eventScope"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearEventsOn", function() { return _event_hub__WEBPACK_IMPORTED_MODULE_0__["clearEventsOn"]; });\n\n/* harmony import */ var _get_pointer_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-pointer-data */ "./node_modules/smooth-scrollbar/utils/get-pointer-data.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPointerData", function() { return _get_pointer_data__WEBPACK_IMPORTED_MODULE_1__["getPointerData"]; });\n\n/* harmony import */ var _get_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-position */ "./node_modules/smooth-scrollbar/utils/get-position.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return _get_position__WEBPACK_IMPORTED_MODULE_2__["getPosition"]; });\n\n/* harmony import */ var _is_one_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-one-of */ "./node_modules/smooth-scrollbar/utils/is-one-of.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isOneOf", function() { return _is_one_of__WEBPACK_IMPORTED_MODULE_3__["isOneOf"]; });\n\n/* harmony import */ var _set_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./set-style */ "./node_modules/smooth-scrollbar/utils/set-style.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setStyle", function() { return _set_style__WEBPACK_IMPORTED_MODULE_4__["setStyle"]; });\n\n/* harmony import */ var _touch_record__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./touch-record */ "./node_modules/smooth-scrollbar/utils/touch-record.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tracker", function() { return _touch_record__WEBPACK_IMPORTED_MODULE_5__["Tracker"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TouchRecord", function() { return _touch_record__WEBPACK_IMPORTED_MODULE_5__["TouchRecord"]; });\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/index.js?')},"./node_modules/smooth-scrollbar/utils/is-one-of.js":function node_modulesSmoothScrollbarUtilsIsOneOfJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOneOf", function() { return isOneOf; });\n/**\n * Check if `a` is one of `[...b]`\n */\nfunction isOneOf(a, b) {\n    if (b === void 0) { b = []; }\n    return b.some(function (v) { return a === v; });\n}\n//# sourceMappingURL=is-one-of.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/is-one-of.js?')},"./node_modules/smooth-scrollbar/utils/set-style.js":function node_modulesSmoothScrollbarUtilsSetStyleJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setStyle\", function() { return setStyle; });\nvar VENDOR_PREFIX = [\n    'webkit',\n    'moz',\n    'ms',\n    'o',\n];\nvar RE = new RegExp(\"^-(?!(?:\" + VENDOR_PREFIX.join('|') + \")-)\");\nfunction autoPrefix(styles) {\n    var res = {};\n    Object.keys(styles).forEach(function (prop) {\n        if (!RE.test(prop)) {\n            res[prop] = styles[prop];\n            return;\n        }\n        var val = styles[prop];\n        prop = prop.replace(/^-/, '');\n        res[prop] = val;\n        VENDOR_PREFIX.forEach(function (prefix) {\n            res[\"-\" + prefix + \"-\" + prop] = val;\n        });\n    });\n    return res;\n}\nfunction setStyle(elem, styles) {\n    styles = autoPrefix(styles);\n    Object.keys(styles).forEach(function (prop) {\n        var cssProp = prop.replace(/^-/, '').replace(/-([a-z])/g, function (_, $1) { return $1.toUpperCase(); });\n        elem.style[cssProp] = styles[prop];\n    });\n}\n//# sourceMappingURL=set-style.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/set-style.js?")},"./node_modules/smooth-scrollbar/utils/touch-record.js":function node_modulesSmoothScrollbarUtilsTouchRecordJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tracker", function() { return Tracker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchRecord", function() { return TouchRecord; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _get_position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-position */ "./node_modules/smooth-scrollbar/utils/get-position.js");\n\n\nvar Tracker = /** @class */ (function () {\n    function Tracker(touch) {\n        this.velocityMultiplier = window.devicePixelRatio;\n        this.updateTime = Date.now();\n        this.delta = { x: 0, y: 0 };\n        this.velocity = { x: 0, y: 0 };\n        this.lastPosition = { x: 0, y: 0 };\n        this.lastPosition = Object(_get_position__WEBPACK_IMPORTED_MODULE_1__["getPosition"])(touch);\n    }\n    Tracker.prototype.update = function (touch) {\n        var _a = this, velocity = _a.velocity, updateTime = _a.updateTime, lastPosition = _a.lastPosition;\n        var now = Date.now();\n        var position = Object(_get_position__WEBPACK_IMPORTED_MODULE_1__["getPosition"])(touch);\n        var delta = {\n            x: -(position.x - lastPosition.x),\n            y: -(position.y - lastPosition.y),\n        };\n        var duration = (now - updateTime) || 16.7;\n        var vx = delta.x / duration * 16.7;\n        var vy = delta.y / duration * 16.7;\n        velocity.x = vx * this.velocityMultiplier;\n        velocity.y = vy * this.velocityMultiplier;\n        this.delta = delta;\n        this.updateTime = now;\n        this.lastPosition = position;\n    };\n    return Tracker;\n}());\n\nvar TouchRecord = /** @class */ (function () {\n    function TouchRecord() {\n        this._touchList = {};\n    }\n    Object.defineProperty(TouchRecord.prototype, "_primitiveValue", {\n        get: function () {\n            return { x: 0, y: 0 };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TouchRecord.prototype.isActive = function () {\n        return this._activeTouchID !== undefined;\n    };\n    TouchRecord.prototype.getDelta = function () {\n        var tracker = this._getActiveTracker();\n        if (!tracker) {\n            return this._primitiveValue;\n        }\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, tracker.delta);\n    };\n    TouchRecord.prototype.getVelocity = function () {\n        var tracker = this._getActiveTracker();\n        if (!tracker) {\n            return this._primitiveValue;\n        }\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, tracker.velocity);\n    };\n    TouchRecord.prototype.getEasingDistance = function (damping) {\n        var deAcceleration = 1 - damping;\n        var distance = {\n            x: 0,\n            y: 0,\n        };\n        var vel = this.getVelocity();\n        Object.keys(vel).forEach(function (dir) {\n            // ignore small velocity\n            var v = Math.abs(vel[dir]) <= 10 ? 0 : vel[dir];\n            while (v !== 0) {\n                distance[dir] += v;\n                v = (v * deAcceleration) | 0;\n            }\n        });\n        return distance;\n    };\n    TouchRecord.prototype.track = function (evt) {\n        var _this = this;\n        var targetTouches = evt.targetTouches;\n        Array.from(targetTouches).forEach(function (touch) {\n            _this._add(touch);\n        });\n        return this._touchList;\n    };\n    TouchRecord.prototype.update = function (evt) {\n        var _this = this;\n        var touches = evt.touches, changedTouches = evt.changedTouches;\n        Array.from(touches).forEach(function (touch) {\n            _this._renew(touch);\n        });\n        this._setActiveID(changedTouches);\n        return this._touchList;\n    };\n    TouchRecord.prototype.release = function (evt) {\n        var _this = this;\n        delete this._activeTouchID;\n        Array.from(evt.changedTouches).forEach(function (touch) {\n            _this._delete(touch);\n        });\n    };\n    TouchRecord.prototype._add = function (touch) {\n        if (this._has(touch)) {\n            // reset tracker\n            this._delete(touch);\n        }\n        var tracker = new Tracker(touch);\n        this._touchList[touch.identifier] = tracker;\n    };\n    TouchRecord.prototype._renew = function (touch) {\n        if (!this._has(touch)) {\n            return;\n        }\n        var tracker = this._touchList[touch.identifier];\n        tracker.update(touch);\n    };\n    TouchRecord.prototype._delete = function (touch) {\n        delete this._touchList[touch.identifier];\n    };\n    TouchRecord.prototype._has = function (touch) {\n        return this._touchList.hasOwnProperty(touch.identifier);\n    };\n    TouchRecord.prototype._setActiveID = function (touches) {\n        this._activeTouchID = touches[touches.length - 1].identifier;\n    };\n    TouchRecord.prototype._getActiveTracker = function () {\n        var _a = this, _touchList = _a._touchList, _activeTouchID = _a._activeTouchID;\n        return _touchList[_activeTouchID];\n    };\n    return TouchRecord;\n}());\n\n//# sourceMappingURL=touch-record.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/touch-record.js?')},"./node_modules/tslib/tslib.es6.js":function node_modulesTslibTslibEs6Js(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to get private field on non-instance");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to set private field on non-instance");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/tslib/tslib.es6.js?')},"./node_modules/webpack/buildin/global.js":function node_modulesWebpackBuildinGlobalJs(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./src/scripts/contact.js":function srcScriptsContactJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./general */ \"./src/scripts/general.js\");\n/* harmony import */ var smooth_scrollbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! smooth-scrollbar */ \"./node_modules/smooth-scrollbar/index.js\");\n\r\n\r\n\r\n\r\nclass ContactClass extends _general__WEBPACK_IMPORTED_MODULE_0__[\"GeneralClass\"] {\r\n  constructor() {\r\n    super();\r\n    this.LaunchContact();\r\n  }\r\n\r\n  async LaunchContact() {\r\n    const hamburger_btn = document.getElementsByClassName('js-hamburger')[0];\r\n    const header_nav = document.querySelector('.navigation-nav');\r\n    const contactForm = document.querySelector('.form-contact');\r\n    const main = document.querySelector('#main-scrollbar');\r\n    const lat = 16.9682597;\r\n    const lng = -96.4863537;\r\n    const zoom = 11;\r\n    let map;\r\n    let scrollbar = null;\r\n\r\n    window.scrollTo(0, 0);\r\n\r\n    setTimeout(() => {\r\n      scrollbar = smooth_scrollbar__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init(main, {\r\n        damping: 0.2,\r\n      });\r\n    }, 100);\r\n\r\n    hamburger_btn.addEventListener('click', (e) => {\r\n      e.preventDefault();\r\n\r\n      hamburger_btn.classList.toggle('is-active');\r\n      header_nav.classList.toggle('shown');\r\n      //document.body.classList.toggle('ov-hidden');\r\n    });\r\n    // const { ValidateForm, CleanFormInfo } = new GeneralClass();\r\n    // const contact_btn = document.querySelector('.js-contact-send');\r\n\r\n    map = new google.maps.Map(document.getElementById('map'), {\r\n      center: { lat, lng },\r\n      scrollwheel: true,\r\n      mapTypeControl: false,\r\n      zoom\r\n    });\r\n\r\n    this.SetIsActiveSec();\r\n\r\n    contactForm.addEventListener('keyup', function (e) {\r\n      if (e.target.matches('.form-contact [required]')) {\r\n        var input = e.target,\r\n          pattern = input.pattern || input.dataset.pattern;\r\n\r\n        if (pattern && input.value !== '') {\r\n          var regex = new RegExp(pattern);\r\n          return !regex.exec(input.value);\r\n        }\r\n\r\n        if (!pattern) {\r\n          return input.value === '';\r\n        }\r\n      }\r\n    });\r\n    contactForm.addEventListener('submit', function (e) {\r\n      e.preventDefault();\r\n      var response = document.querySelector('.form-contact__response'),\r\n        loader = document.querySelector('.form-contact__loader');\r\n      loader.classList.remove('d-none');\r\n      fetch('../assets/php/contact.php', {\r\n        method: 'POST',\r\n        body: new FormData(e.target)\r\n      }).then(function (res) {\r\n        return res.ok ? res.json() : Promise.reject(res);\r\n      }).then(function (json) {\r\n        console.log(json);\r\n        loader.classList.add('d-none');\r\n        response.classList.remove('d-none');\r\n        response.innerHTML = \"<p>\".concat(json.message, \"</p>\");\r\n        contactForm.reset();\r\n        window.dataLayer.push({\r\n          'event': 'thankyoupage',\r\n          'eventCategory': 'contacto',\r\n          'eventAction': 'click_boton_enviar',\r\n          'eventLabel': 'Contactanos'\r\n        });\r\n      })[\"catch\"](function (err) {\r\n        console.log(err);\r\n        var message = err.statusText || 'Ocurrio un error al enviar tus datos, intenta nuevamente';\r\n        response.innerHTML = \"<p>Error \".concat(err.statusText, \": \").concat(message, \"</p>\");\r\n      })[\"finally\"](function () {\r\n        return setTimeout(function () {\r\n          response.classList.add('d-none');\r\n          response.innerHTML = '';\r\n        }, 4000);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n\r\n  SetIsActiveSec() {\r\n    const location = window.location.href;\r\n    const hash = window.location.hash;\r\n    const loc = location.split('/');\r\n    const lastItem = hash ? loc[loc.length - 2] : location.replace(/.*\\/(\\w+)\\/?$/, '$1');\r\n    const anchor_inv = document.querySelectorAll('.navigation__link');\r\n\r\n    for (const link of anchor_inv) {\r\n      if (window.location.pathname === '/' ||\r\n        window.location.pathname.indexOf('index') > -1) {\r\n        anchor_inv[0].parentElement.classList.add('current');\r\n      } else if (link.href.includes(lastItem)) {\r\n        link.parentElement.classList.add('current');\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /*async SendContact() {\r\n    const { RemoveAllErrors, RequestData, GetLanguage, ShowModal } = new GeneralClass();\r\n    const form = document.querySelector('.contact-form');\r\n    const { error, message, fieldErrors } = await RequestData({ service: 'contactUs', form })/*,\r\n      messages = document.querySelector('.js-contact-messages'),\r\n      form_wrp = document.querySelector('.contact-form-wrp')\r\n    const language = GetLanguage();\r\n\r\n    RemoveAllErrors();\r\n\r\n    window.dataLayer.push({\r\n      'event': 'thankyoupage',\r\n      'eventCategory': 'contacto',\r\n      'eventAction': 'click_boton_enviar',\r\n      'eventLabel': 'Contactanos'\r\n    });\r\n\r\n    if (error === '0') {\r\n      form.reset();\r\n      /*messages.classList.add('successful');\r\n      messages.classList.remove('hidden');\r\n      form_wrp.classList.add('hidden');\r\n      messages.innerHTML = message;\r\n\r\n      setTimeout(() => {\r\n        messages.innerHTML = '';\r\n        form_wrp.classList.remove('hidden');\r\n        messages.classList.add('hidden');\r\n\r\n      }, 6200);\r\n\r\n      const modal_message = language === 'es' ? 'Gracias por compartirnos tus datos, en breve nos pondremos en contacto contigo.' : 'We received your request, we will contact you shortly.';\r\n      const children = `<div class=\"message-content\"><button class=\"ol-close-box icon icon-cross\"></button><p>${modal_message}</p></div>`;\r\n      ShowModal({ children });\r\n\r\n      window.dataLayer.push({\r\n        'event': 'successcontactpage',\r\n      });\r\n\r\n    } else {\r\n      let p = document.createElement('p');\r\n      p.classList.add('error');\r\n      p.innerHTML = message;\r\n      form.parentNode.appendChild(p);\r\n\r\n      /*arr.forEach(item => {\r\n\r\n      fieldErrors && Object.entries(fieldErrors).forEach(([key, value]) => {\r\n        let pc = document.createElement('p');\r\n        pc.classList.add('error');\r\n\r\n        if (document.querySelector(`input[name=\"${key}\"]`)) {\r\n          pc.innerHTML = value;\r\n          document.querySelector(`input[name=\"${key}\"]`).parentNode.appendChild(pc);\r\n        }\r\n\r\n      });\r\n      form.parentNode.appendChild(p);\r\n      if (fieldErrors) {\r\n        for (let n in fieldErrors) {\r\n          let p = document.createElement('p');\r\n          p.classList.add('error');\r\n          p.innerHTML = fieldErrors[n];\r\n          form.appendChild(p);\r\n        }\r\n      }\r\n    }\r\n  }*/\r\n}\r\nlet main;\r\ndocument.addEventListener(\r\n  'DOMContentLoaded',\r\n  () => {\r\n    main = new ContactClass();\r\n    window.main = main;\r\n  },\r\n  false\r\n);\r\n\n\n//# sourceURL=webpack:///./src/scripts/contact.js?")},"./src/scripts/general.js":function srcScriptsGeneralJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneralClass\", function() { return GeneralClass; });\n\r\n\r\nclass GeneralClass {\r\n\r\n    SetIsMobile() {\r\n        if (typeof window.orientation !== 'undefined') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    async RequestData({ form, service }) {\r\n        const formData = new FormData(form);\r\n        const { GetLanguage } = new GeneralClass();\r\n        const language = GetLanguage();\r\n        const dataToSend = {language};\r\n        const url = window.location.href.includes('devsite') || window.location.href.includes('local') ? 'https://services.stg.mubaro.mx/services/mubaro/' : 'https://services.mubaro.mx/services/mubaro/';\r\n\r\n        for (const [name, value] of formData) {\r\n            dataToSend[name] = value;\r\n        }\r\n\r\n        const formBody = Object.keys(dataToSend)\r\n            .map(\r\n                (key) =>\r\n                    encodeURIComponent(key) + '=' + encodeURIComponent(dataToSend[key])\r\n            )\r\n            .join('&'),\r\n            response = await fetch(`${url}${service}.php`, {\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\r\n                },\r\n                method: 'POST',\r\n                body: formBody,\r\n            })\r\n                .then((response) => {\r\n                    if (response.ok) {\r\n                        return response.json();\r\n                    }\r\n                    throw new Error('Algo sali mal. Verifica los datos y vuelve a intentarlo.');\r\n                })\r\n                .catch((error) => {\r\n                    console.error('Error:', error);\r\n                    return error;\r\n                });\r\n        if (!response) return;\r\n        return response;\r\n    }\r\n\r\n    SetCookie() {\r\n        const disclaimer = localStorage.getItem('disclaimer');\r\n        const { GetLanguage } = new GeneralClass();\r\n        const language = GetLanguage();\r\n        const message = language === 'en' ? `You are browsing a website with its own and third-party cookies to offer you an optimal experience. To continue browsing, click Accept. If you want more information enter our Privacy Policy`: `Ests navegando en un sitio con cookies propias y de terceros, para ofrecerte una experiencia ptima. <br/>Para continuar navegando, dale Aceptar. <br/>Si deseas ms informacin entra a nuestra poltica de privacidad. `;\r\n        const denyText = language === 'en' ? 'Deny' : 'No acepto';\r\n        const acceptText = language === 'en' ? 'Accept' : 'Acepto';\r\n\r\n        if (!disclaimer) {\r\n            const cookie_wrp = document.createElement('div'),\r\n                cookie_markup = `\r\n                <div class=\"cookies-container\">\r\n                    <div class=\"cookies-wrp text-center\">\r\n                        <p>${message}</p>\r\n                        <div class=\"row justify-content-between cookies-btn-wrp mx-auto\">\r\n                            <button type=\"button\" data-type=\"yes\" class=\"btn btn-blue btn-cookie\">${acceptText}</button>\r\n                            <button type=\"button\" data-type=\"no\" class=\"btn btn-blue btn-cookie btn\">${denyText}</button>\r\n                        </div>\r\n                    </div>\r\n                </div>`;\r\n            cookie_wrp.classList.add('cookies-disclaim');\r\n            cookie_wrp.innerHTML = cookie_markup;\r\n\r\n            document.body.appendChild(cookie_wrp);\r\n\r\n            const cookie_btn = document.querySelectorAll('.btn-cookie');\r\n\r\n            [].forEach.call(cookie_btn, (c) => {\r\n                c.addEventListener('click', (e) => {\r\n                    e.preventDefault();\r\n                    let tgt = e.currentTarget,\r\n                        type = tgt.getAttribute('data-type');\r\n\r\n                    if (type === 'yes') {\r\n                        localStorage.setItem('disclaimer', true);\r\n                    }\r\n\r\n                    document.querySelector('.cookies-disclaim').remove();\r\n                });\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    GetQueryString(name, url) {\r\n        if (!url) url = window.location.href;\r\n        name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\r\n            results = regex.exec(url);\r\n        if (!results) return null;\r\n        if (!results[2]) return '';\r\n        return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n    }\r\n\r\n    Decode(str) {\r\n\r\n        str = str.replace('', 'a');\r\n        str = str.replace('', 'A');\r\n        str = str.replace('', 'e');\r\n        str = str.replace('', 'E');\r\n        str = str.replace('', 'i');\r\n        str = str.replace('', 'I');\r\n        str = str.replace('', 'o');\r\n        str = str.replace('', 'O');\r\n        str = str.replace('', 'u');\r\n        str = str.replace('', 'U');\r\n        str = str.replace('', 'n');\r\n        str = str.replace('', 'N');\r\n        str = str.replace('', '');\r\n\r\n        return str;\r\n    }\r\n\r\n    async GetData(path) {\r\n        const SERVICES_URL = window.location.href.includes('devsite') || window.location.href.includes('local') ? '' : '';\r\n        const url = SERVICES_URL + '/' + path,\r\n            response = await fetch(url),\r\n            data = await response.json();\r\n\r\n        if (!data) return;\r\n        return data;\r\n    }\r\n\r\n    CharsAllowed(value) {\r\n        const allowedChars = new RegExp(/^[a-zA-Z\\s]+$/)\r\n        return allowedChars.test(value);\r\n    }\r\n\r\n    CleanFormInfo() {\r\n\r\n        const fields = document.querySelectorAll('.required-field');\r\n        const self = new GeneralClass();\r\n\r\n        const { GetLanguage, RemoveAllErrors } = new GeneralClass();\r\n\r\n        const lang = GetLanguage();\r\n\r\n        [].forEach.call(fields, (e, index) => {\r\n\r\n            let tgt = e;\r\n\r\n            tgt.addEventListener('change', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n            tgt.addEventListener('keyup', ($e) => {\r\n                const val = tgt.value;\r\n                const name = tgt.getAttribute('name');\r\n                const maxlength = 10;\r\n                if (name === 'phone') {\r\n                    if (val.length > maxlength) {\r\n                        tgt.value = val.substr(0, maxlength);\r\n                    }\r\n                }\r\n            });\r\n\r\n            tgt.addEventListener('input', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n            tgt.addEventListener('focusout', (e) => {\r\n                RemoveAllErrors();\r\n                const name = tgt.getAttribute('name');\r\n\r\n                let p = document.createElement('p');\r\n                let error_message = name === 'phone' ? lang === 'es' ? 'Solo se admiten nmeros' : 'Only numbers' : name === 'email' ? lang === 'es' ? 'Ingresa un correo electrnico vlido' : 'Email' : lang === 'es' ? 'Solo se admiten letras' : 'Only letters';\r\n                let regex = name === 'phone' ? /^[0-9]+$/ : name === 'email' ? /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}/gi : /^[A-Za-z---\\s]*$/\r\n\r\n                //Validate TextBox value against the Regex.\r\n                const isValid = tgt.value ? regex.test(tgt.value) : true;\r\n\r\n                if (!isValid && !name.toLowerCase().includes('date')) {\r\n                    p.innerHTML = error_message;\r\n                    p.classList.add('error');\r\n                    tgt.parentNode.appendChild(p);\r\n                } else {\r\n                    RemoveAllErrors();\r\n                }\r\n\r\n\r\n                return isValid;\r\n            });\r\n\r\n            tgt.addEventListener('paste', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n\r\n        });\r\n\r\n    }\r\n\r\n    RemoveAllErrors() {\r\n        // const removeErrors = () => {\r\n        const errors = document.querySelectorAll('.error');\r\n\r\n        [].forEach.call(errors, (e, index) => {\r\n            e.remove();\r\n        });\r\n        //}\r\n    }\r\n\r\n    ValidateForm() {\r\n        const labels = document.querySelectorAll('.label'),\r\n            errors = document.querySelectorAll('.error'),\r\n            email = document.querySelector('.js-email'),\r\n            phone = document.querySelector('.js-phone'),\r\n            emailVal = email ? email.value.search(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}/gi) > -1 : null,\r\n            phoneVal = phone ? phone.value.search(/\\[0-9]/) : null,\r\n            fields = document.querySelectorAll('.required-field');\r\n\r\n        const { GetLanguage } = new GeneralClass();\r\n\r\n        const lang = GetLanguage();\r\n\r\n        let required = fields.length,\r\n            fieldError = [],\r\n            filled = [],\r\n            eml = 0,\r\n            phn = 0;\r\n\r\n        [].forEach.call(fields, (f, index) => {\r\n\r\n            let tgt = f,\r\n                val,\r\n                title;\r\n\r\n            val = f.value;\r\n\r\n            if (val === '' || val === '-1') {\r\n                const msj = labels[index].innerHTML.replace(':', '').toLowerCase();\r\n                const parsed = msj.normalize('NFD').replace(/([\\u0300-\\u036f]|[^0-9a-zA-Z])/g, '').replace(/([^\\w]+|\\s+)/g, '-');\r\n                let p = document.createElement('p');\r\n                p.classList.add('error');\r\n                p.classList.add(`error-${parsed}`);\r\n                title = lang === 'es' ? `Por favor, ingresa correctamente ${msj}.` : `Fill correctly ${msj}.`;\r\n                p.innerHTML = title;\r\n\r\n                [].forEach.call(errors, (e, index) => {\r\n                    e.remove();\r\n                });\r\n\r\n                tgt.parentNode.appendChild(p);\r\n                fieldError.push(title);\r\n\r\n            } else {\r\n                filled.push(tgt);\r\n            }\r\n\r\n        });\r\n\r\n        if (email && !emailVal) {\r\n            let p = document.createElement('p');\r\n            p.classList.add('error');\r\n            p.innerHTML = lang === 'es' ? 'Por favor, ingresa correctamente tu correo electrnico.' : 'Please, fill your email';\r\n            if (!document.body.contains(document.querySelector('.error-correoelectronico') || document.querySelector('.error-email'))) {\r\n                document.querySelector('.js-email-wrp').appendChild(p);\r\n            }\r\n            eml = 0;\r\n        } else {\r\n            eml = 1;\r\n        }\r\n\r\n        if (phone && !phoneVal) {\r\n            let p = document.createElement('p');\r\n            p.classList.add('error');\r\n            p.innerHTML = lang === 'es' ? 'Por favor, ingresa correctamente tu telfono.' : 'Please fill your phone correctly';\r\n            if (!document.body.contains(document.querySelector('.error-telefono') || document.querySelector('.error-phonenumber'))) {\r\n                document.querySelector('.js-phone-wrp').appendChild(p);\r\n            }\r\n            phn = 0;\r\n        } else {\r\n            phn = 1;\r\n        }\r\n\r\n        return required === filled.length && eml === 1 && phn === 1;\r\n\r\n    }\r\n\r\n    GetLanguage() {\r\n        let lang;\r\n        if (window.location.href.includes('/en/')) {\r\n            lang = 'en';\r\n        } else {\r\n            lang = 'es';\r\n        }\r\n        if (!localStorage.getItem('lang')) localStorage.setItem('lang', lang);\r\n        return lang;\r\n    }\r\n\r\n    SetAnimation() {\r\n        const boxes = document.querySelectorAll('.box');\r\n        if (boxes) {\r\n          const triggerBottom = (window.innerHeight / 5) * 4;\r\n    \r\n          if (document.querySelector('.box.init')) document.querySelector('.box.init').classList.add('show');\r\n    \r\n          boxes.forEach((box) => {\r\n            const boxTop = box.getBoundingClientRect().top;\r\n            // For checking when to show and hide the box\r\n            if (boxTop < triggerBottom) {\r\n              box.classList.add('show');\r\n            } \r\n          });\r\n        }\r\n      }\r\n\r\n      ShowModal({ children, onOpen, onAccept, onCancel }) {\r\n\r\n        const ol = document.querySelector('#ol-main');\r\n        const self = new GeneralClass();\r\n\r\n        if (ol) {\r\n            ol.remove();\r\n        }\r\n\r\n        let ol_div = document.createElement('div');\r\n\r\n        ol_div.id = 'ol-main';\r\n\r\n        ol_div.innerHTML = `<div class=\"ol-modal-wrapper ol-modal-cont\" >\r\n            <div class=\"ol-modal-container ol-modal-cont\">\r\n                <div class=\"ol-modal-panel-box\">\r\n                    <div class=\"modal-container\">\r\n                        ${children}\r\n                    </div>\r\n                </div>\r\n            </div>`;\r\n\r\n        document.body.appendChild(ol_div);\r\n\r\n        const cancel_btn = document.querySelector('.ol-cancel-box') || document.querySelector('.ol-close-box');\r\n        const accept_btn = document.querySelector('.ol-accept-box');\r\n\r\n        if (onOpen) {\r\n            onOpen();\r\n        }\r\n\r\n        cancel_btn && cancel_btn.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n            if (onCancel) {\r\n                onCancel();\r\n            }\r\n            self.CloseModal();\r\n        });\r\n\r\n        accept_btn && accept_btn.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n\r\n            if (onAccept) {\r\n                onAccept();\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n    CloseModal() {\r\n        const ol_wrp = document.querySelector('.ol-modal-wrapper');\r\n        ol_wrp.remove();\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack:///./src/scripts/general.js?")}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRhY3Quc2NyaXB0cy5taW4uanMiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0VzQXJyYXlGcm9tSnMiLCJldmFsIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc01hcEluZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc09iamVjdEFzc2lnbkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9zZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc1NldEluZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3dlYWstbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzRXNXZWFrTWFwSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBQ2FsbGFibGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQVBvc3NpYmxlUHJvdG90eXBlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBZGRUb1Vuc2NvcGFibGVzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FuSW5zdGFuY2VKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FuT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUJ1ZmZlck5vbkV4dGVuc2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUZyb21KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJbmNsdWRlc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJdGVyYXRpb25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U2xpY2VTaW1wbGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheVNwZWNpZXNDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheVNwZWNpZXNDcmVhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZ0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NsYXNzb2ZSYXdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25TdHJvbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25XZWFrSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29sbGVjdGlvbkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29weUNvbnN0cnVjdG9yUHJvcGVydGllc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29ycmVjdFByb3RvdHlwZUdldHRlckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZUl0ZXJSZXN1bHRPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZVByb3BlcnR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVCdWlsdEluSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRGVmaW5lQnVpbHRJbnNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVHbG9iYWxQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZXNjcmlwdG9yc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRG9jdW1lbnRBbGxKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRG9jdW1lbnRDcmVhdGVFbGVtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVVzZXJBZ2VudEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbmdpbmVWOFZlcnNpb25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbnVtQnVnS2V5c0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRXhwb3J0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZhaWxzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZyZWV6aW5nSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmRDb250ZXh0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uQmluZE5hdGl2ZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uQ2FsbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uTmFtZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLXJhdy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNSYXdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dldEJ1aWx0SW5KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRJdGVyYXRvck1ldGhvZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2V0SXRlcmF0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRNZXRob2RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dsb2JhbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hhc093blByb3BlcnR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hpZGRlbktleXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIdG1sSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0llOERvbURlZmluZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbmRleGVkT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5oZXJpdElmUmVxdWlyZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5zcGVjdFNvdXJjZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbE1ldGFkYXRhSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ludGVybmFsU3RhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQXJyYXlJdGVyYXRvck1ldGhvZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0FycmF5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQ2FsbGFibGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNGb3JjZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNOdWxsT3JVbmRlZmluZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNQdXJlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1N5bWJvbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDbG9zZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDcmVhdGVDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JEZWZpbmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JzQ29yZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0xlbmd0aE9mQXJyYXlMaWtlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzTWFrZUJ1aWx0SW5KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNNYXRoVHJ1bmNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RBc3NpZ25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RDcmVhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdERlZmluZVByb3BlcnRpZXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3REZWZpbmVQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5U3ltYm9sc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRQcm90b3R5cGVPZkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc0V4dGVuc2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc1Byb3RvdHlwZU9mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEtleXNJbnRlcm5hbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RLZXlzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFNldFByb3RvdHlwZU9mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09yZGluYXJ5VG9QcmltaXRpdmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3duS2V5c0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1BhdGhKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1JlcXVpcmVPYmplY3RDb2VyY2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2V0U3BlY2llc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNTZXRUb1N0cmluZ1RhZ0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZEtleUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkU3RvcmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N0cmluZ011bHRpYnl0ZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvQWJzb2x1dGVJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0luZGV4ZWRPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0ludGVnZXJPckluZmluaXR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0xlbmd0aEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9PYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvUHJpbWl0aXZlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb1Byb3BlcnR5S2V5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb1N0cmluZ1RhZ1N1cHBvcnRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvU3RyaW5nSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVHJ5VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1VpZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNVc2VTeW1ib2xBc1VpZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNWOFByb3RvdHlwZURlZmluZUJ1Z0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzV2Vha01hcEJhc2ljRGV0ZWN0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlbGxLbm93blN5bWJvbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNBcnJheUZyb21KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc0FycmF5SXRlcmF0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNNYXBDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc01hcEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNPYmplY3RBc3NpZ25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzT2JqZWN0VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTZXRDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1NldEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1N0cmluZ0l0ZXJhdG9ySnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNXZWFrTWFwQ29uc3RydWN0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1dlYWtNYXBKcyIsIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0xvZGFzaENsYW1wSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0xvZGFzaERlYm91bmNlSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9ib29sZWFuLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0Jvb2xlYW5KcyIsIl9fd2VicGFja19leHBvcnRzX18iLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvZGVib3VuY2UuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJEZWNvcmF0b3JzRGVib3VuY2VKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckRlY29yYXRvcnNJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc1JhbmdlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c0luZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9rZXlib2FyZC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c0tleWJvYXJkSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9tb3VzZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c01vdXNlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9yZXNpemUuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNSZXNpemVKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c1NlbGVjdEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvdG91Y2guanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNUb3VjaEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNXaGVlbEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9nZXQtc2l6ZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5R2V0U2l6ZUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvaXMtdmlzaWJsZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SXNWaXNpYmxlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5VXBkYXRlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFySW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhck9wdGlvbnNKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvcGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUGx1Z2luSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclBvbHlmaWxsc0pzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxiYXJKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxpbmdTY3JvbGxJbnRvVmlld0pzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nU2Nyb2xsVG9KcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1NldFBvc2l0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU3R5bGVKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svZGlyZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tEaXJlY3Rpb25KcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svaW5kZXguanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja0luZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RodW1iLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tUaHVtYkpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90cmFjay5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclRyYWNrVHJhY2tKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZXZlbnQtaHViLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNFdmVudEh1YkpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNHZXRQb2ludGVyRGF0YUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9zaXRpb24uanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0dldFBvc2l0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pcy1vbmUtb2YuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0lzT25lT2ZKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvc2V0LXN0eWxlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNTZXRTdHlsZUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc1RvdWNoUmVjb3JkSnMiLCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJub2RlX21vZHVsZXNUc2xpYlRzbGliRXM2SnMiLCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzV2VicGFja0J1aWxkaW5HbG9iYWxKcyIsIi4vc3JjL3NjcmlwdHMvY29udGFjdC5qcyIsInNyY1NjcmlwdHNDb250YWN0SnMiLCIuL3NyYy9zY3JpcHRzL2dlbmVyYWwuanMiLCJzcmNTY3JpcHRzR2VuZXJhbEpzIl0sIm1hcHBpbmdzIjoiQUFBQSxhQUVBLFNBQVNBLFFBQVFDLEdBQWtDLE9BQU9ELFFBQVUsbUJBQXFCRSxRQUFVLGlCQUFtQkEsT0FBT0MsU0FBVyxTQUFVRixHQUFPLGNBQWNBLEdBQVMsU0FBVUEsR0FBTyxPQUFPQSxHQUFPLG1CQUFxQkMsUUFBVUQsRUFBSUcsY0FBZ0JGLFFBQVVELElBQVFDLE9BQU9HLFVBQVksZ0JBQWtCSixJQUFnQkEsSUFDalUsU0FBV0ssR0FJakIsSUFBSUMsRUFBbUIsR0FJdkIsU0FBU0MsRUFBb0JDLEdBR25CLEdBQUlGLEVBQWlCRSxHQUNuQixPQUFPRixFQUFpQkUsR0FBVUMsUUFLNUMsSUFBSUMsRUFBU0osRUFBaUJFLEdBQVksQ0FDaENHLEVBQUdILEVBQ0hJLEdBQUcsRUFDSEgsUUFBUyxJQWNuQixPQVJBSixFQUFRRyxHQUFVSyxLQUFLSCxFQUFPRCxRQUFTQyxFQUFRQSxFQUFPRCxRQUFTRixHQUkvREcsRUFBT0UsR0FBSSxFQUlKRixFQUFPRCxRQU9oQkYsRUFBb0JPLEVBQUlULEVBSXhCRSxFQUFvQlEsRUFBSVQsRUFJeEJDLEVBQW9CUyxFQUFJLFNBQVVQLEVBQVNRLEVBQU1DLEdBQ2xDWCxFQUFvQlksRUFBRVYsRUFBU1EsSUFDbENHLE9BQU9DLGVBQWVaLEVBQVNRLEVBQU0sQ0FDM0NLLFlBQVksRUFDWkMsSUFBS0wsS0FTWFgsRUFBb0JpQixFQUFJLFNBQVVmLEdBQ0Ysb0JBQVhSLFFBQTBCQSxPQUFPd0IsYUFDMUNMLE9BQU9DLGVBQWVaLEVBQVNSLE9BQU93QixZQUFhLENBQ3pEQyxNQUFPLFdBS1hOLE9BQU9DLGVBQWVaLEVBQVMsYUFBYyxDQUMzQ2lCLE9BQU8sS0FXWG5CLEVBQW9Cb0IsRUFBSSxTQUFVRCxFQUFPRSxHQUd2QyxHQUZtQixFQUFQQSxJQUFVRixFQUFRbkIsRUFBb0JtQixJQUV2QyxFQUFQRSxFQUFVLE9BQU9GLEVBRXJCLEdBQVcsRUFBUEUsR0FBK0IsV0FBbkI3QixRQUFRMkIsSUFBdUJBLEdBQVNBLEVBQU1HLFdBQVksT0FBT0gsRUFFakYsSUFBSUksRUFBS1YsT0FBT1csT0FBTyxNQVN2QixHQVBBeEIsRUFBb0JpQixFQUFFTSxHQUV0QlYsT0FBT0MsZUFBZVMsRUFBSSxVQUFXLENBQ25DUixZQUFZLEVBQ1pJLE1BQU9BLElBR0UsRUFBUEUsR0FBNEIsaUJBQVRGLEVBQW1CLElBQUssSUFBSU0sS0FBT04sRUFDeERuQixFQUFvQlMsRUFBRWMsRUFBSUUsRUFBSyxTQUFVQSxHQUN2QyxPQUFPTixFQUFNTSxJQUNiQyxLQUFLLEtBQU1ELElBR2YsT0FBT0YsR0FNVHZCLEVBQW9CMkIsRUFBSSxTQUFVeEIsR0FDeEIsSUFBSVEsRUFBU1IsR0FBVUEsRUFBT21CLFdBQXFCLFdBQ3pELE9BQU9uQixFQUFnQixTQUNiLFdBQ1YsT0FBT0EsR0FLVCxPQUZBSCxFQUFvQlMsRUFBRUUsRUFBUSxJQUFLQSxHQUU1QkEsR0FNVFgsRUFBb0JZLEVBQUksU0FBVWdCLEVBQVFDLEdBQ3hDLE9BQU9oQixPQUFPaEIsVUFBVWlDLGVBQWV4QixLQUFLc0IsRUFBUUMsSUFLdEQ3QixFQUFvQitCLEVBQUksR0FLakIvQixFQUFvQkEsRUFBb0JnQyxFQUFJLDRCQXhJN0MsQ0E0SUUsQ0FDSEMsMENBTUwsU0FBU0MsZ0NBQWdDL0IsT0FBUUQsUUFBU0YscUJBQ3hEbUMsS0FBSywwYkFLRkMseUNBTUwsU0FBU0MsK0JBQStCbEMsT0FBUUQsUUFBU0YscUJBQ3ZEbUMsS0FBSyxncEJBS0ZHLDZDQU1MLFNBQVNDLG1DQUFtQ3BDLE9BQVFELFFBQVNGLHFCQUMzRG1DLEtBQUssZ1ZBS0ZLLHlDQU1MLFNBQVNDLCtCQUErQnRDLE9BQVFELFFBQVNGLHFCQUN2RG1DLEtBQUssZ3BCQUtGTyw4Q0FNTCxTQUFTQyxtQ0FBbUN4QyxPQUFRRCxRQUFTRixxQkFDM0RtQyxLQUFLLDZpQkFLRlMsaURBTUwsU0FBU0MsdUNBQXVDMUMsT0FBUUQsUUFBU0YscUJBQy9EbUMsS0FBSyxxakJBS0ZXLDJEQU1MLFNBQVNDLGdEQUFnRDVDLE9BQVFELFFBQVNGLHFCQUN4RW1DLEtBQUsscWRBS0ZhLHlEQU1MLFNBQVNDLDhDQUE4QzlDLE9BQVFELFFBQVNGLHFCQUN0RW1DLEtBQUsseTlCQUtGZSxrREFNTCxTQUFTQyx3Q0FBd0NoRCxPQUFRRCxRQUFTRixxQkFDaEVtQyxLQUFLLHNaQUtGaUIsZ0RBTUwsU0FBU0Msc0NBQXNDbEQsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSywyYkFLRm1CLGtFQU1MLFNBQVNDLHNEQUFzRHBELE9BQVFELFFBQVNGLHFCQUM5RW1DLEtBQUssbW1CQUtGcUIsaURBTUwsU0FBU0MsdUNBQXVDdEQsT0FBUUQsUUFBU0YscUJBRy9EbUMsS0FBSyx1NEZBS0Z1QixxREFNTCxTQUFTQywyQ0FBMkN4RCxPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLHduREFLRnlCLHNEQU1MLFNBQVNDLDRDQUE0QzFELE9BQVFELFFBQVNGLHFCQUNwRW1DLEtBQUsscTdHQUtGMkIseURBTUwsU0FBU0MsOENBQThDNUQsT0FBUUQsUUFBU0YscUJBQ3RFbUMsS0FBSyw2NEJBS0Y2QixnRUFNTCxTQUFTQyxxREFBcUQ5RCxPQUFRRCxRQUFTRixxQkFDN0VtQyxLQUFLLCtuQ0FLRitCLDJEQU1MLFNBQVNDLGdEQUFnRGhFLE9BQVFELFFBQVNGLHFCQUN4RW1DLEtBQUssNGVBS0ZpQyx1RUFNTCxTQUFTQywwREFBMERsRSxPQUFRRCxRQUFTRixxQkFDbEZtQyxLQUFLLHNuQkFLRm1DLHFFQU1MLFNBQVNDLHlEQUF5RHBFLE9BQVFELFFBQVNGLHFCQUNqRm1DLEtBQUssd3FDQUtGcUMsa0RBTUwsU0FBU0Msd0NBQXdDdEUsT0FBUUQsUUFBU0YscUJBQ2hFbUMsS0FBSyw4WkFLRnVDLDhDQU1MLFNBQVNDLHFDQUFxQ3hFLE9BQVFELFFBQVNGLHFCQUM3RG1DLEtBQUsscThDQUtGeUMsd0RBTUwsU0FBU0MsOENBQThDMUUsT0FBUUQsUUFBU0YscUJBR3RFbUMsS0FBSyxraFNBS0YyQyxzREFNTCxTQUFTQyw0Q0FBNEM1RSxPQUFRRCxRQUFTRixxQkFHcEVtQyxLQUFLLDIzS0FLRjZDLGlEQU1MLFNBQVNDLHdDQUF3QzlFLE9BQVFELFFBQVNGLHFCQUdoRW1DLEtBQUssNHJMQUtGK0Msa0VBTUwsU0FBU0MsdURBQXVEaEYsT0FBUUQsUUFBU0YscUJBQy9FbUMsS0FBSyxtbUNBS0ZpRCwrREFNTCxTQUFTQyxvREFBb0RsRixPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLHNjQUtGbUQsZ0VBTUwsU0FBU0Msb0RBQW9EcEYsT0FBUUQsU0FDbkVpQyxLQUFLLCtSQUtGcUQscUVBTUwsU0FBU0MseURBQXlEdEYsT0FBUUQsUUFBU0YscUJBQ2pGbUMsS0FBSyx3d0JBS0Z1RCxpRUFNTCxTQUFTQyxzREFBc0R4RixPQUFRRCxTQUNyRWlDLEtBQUssc1JBS0Z5RCxzREFNTCxTQUFTQyw0Q0FBNEMxRixPQUFRRCxRQUFTRixxQkFHcEVtQyxLQUFLLGt4QkFLRjJELHNEQU1MLFNBQVNDLDJDQUEyQzVGLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssMDFDQUtGNkQsdURBTUwsU0FBU0MsNENBQTRDOUYsT0FBUUQsUUFBU0YscUJBQ3BFbUMsS0FBSywrV0FLRitELDZEQU1MLFNBQVNDLGtEQUFrRGhHLE9BQVFELFFBQVNGLHFCQUMxRW1DLEtBQUssNGdCQUtGaUUsa0RBTUwsU0FBU0MseUNBQXlDbEcsT0FBUUQsUUFBU0YscUJBQ2pFbUMsS0FBSywyY0FLRm1FLG1EQU1MLFNBQVNDLHlDQUF5Q3BHLE9BQVFELFNBQ3hEaUMsS0FBSyx5V0FLRnFFLDhEQU1MLFNBQVNDLG1EQUFtRHRHLE9BQVFELFFBQVNGLHFCQUMzRW1DLEtBQUssNmpCQUtGdUUsd0RBTUwsU0FBU0MsNkNBQTZDeEcsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyxzUkFLRnlFLHdEQU1MLFNBQVNDLDZDQUE2QzFHLE9BQVFELFFBQVNGLHFCQUNyRW1DLEtBQUssbWxDQUtGMkUsb0RBTUwsU0FBU0MseUNBQXlDNUcsT0FBUUQsU0FDeERpQyxLQUFLLGdSQUtGNkUsNkNBTUwsU0FBU0Msb0NBQW9DOUcsT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2d0dBS0YrRSw0Q0FNTCxTQUFTQyxtQ0FBbUNoSCxPQUFRRCxTQUNsRGlDLEtBQUssK0xBS0ZpRiwrQ0FNTCxTQUFTQyxzQ0FBc0NsSCxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLG9aQUtGbUYsNERBTUwsU0FBU0MsaURBQWlEcEgsT0FBUUQsUUFBU0YscUJBQ3pFbUMsS0FBSyw2d0JBS0ZxRiwyREFNTCxTQUFTQyxnREFBZ0R0SCxPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLG1mQUtGdUYsb0RBTUwsU0FBU0MsMENBQTBDeEgsT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyxxWEFLRnlGLG9EQU1MLFNBQVNDLDBDQUEwQzFILE9BQVFELFFBQVNGLHFCQUNsRW1DLEtBQUssMjdCQUtGMkYsZ0VBTUwsU0FBU0Msb0RBQW9ENUgsT0FBUUQsUUFBU0YscUJBQzVFbUMsS0FBSyxvaUJBS0Y2Riw0REFNTCxTQUFTQyxpREFBaUQ5SCxPQUFRRCxRQUFTRixxQkFDekVtQyxLQUFLLDhsQkFLRitGLG1EQU1MLFNBQVNDLHdDQUF3Q2hJLE9BQVFELFFBQVNGLHFCQUNoRW1DLEtBQUssb2tCQUtGaUcsMERBTUwsU0FBU0MsK0NBQStDbEksT0FBUUQsUUFBU0YscUJBQ3ZFbUMsS0FBSyxnN0JBS0ZtRyxtREFNTCxTQUFTQyx5Q0FBeUNwSSxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLG9oQ0FLRnFHLGlEQU1MLFNBQVNDLHVDQUF1Q3RJLE9BQVFELFFBQVNGLHFCQUMvRG1DLEtBQUssd2lCQUtGdUcsNkNBTUwsU0FBU0Msb0NBQW9DeEksT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2MkJBS0Z5Ryx1REFNTCxTQUFTQyw0Q0FBNEMxSSxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLG9wQkFLRjJHLGtEQU1MLFNBQVNDLHdDQUF3QzVJLE9BQVFELFNBQ3ZEaUMsS0FBSyx3R0FLRjZHLDJDQU1MLFNBQVNDLGtDQUFrQzlJLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssd1FBS0YrRyxxREFNTCxTQUFTQywwQ0FBMENoSixPQUFRRCxRQUFTRixxQkFDbEVtQyxLQUFLLGl3QkFLRmlILHFEQU1MLFNBQVNDLDJDQUEyQ2xKLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssdzVCQUtGbUgsMERBTUwsU0FBU0MsK0NBQStDcEosT0FBUUQsUUFBU0YscUJBQ3ZFbUMsS0FBSyxnaUNBS0ZxSCxxREFNTCxTQUFTQywyQ0FBMkN0SixPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLHl3QkFLRnVILHdEQU1MLFNBQVNDLDhDQUE4Q3hKLE9BQVFELFFBQVNGLHFCQUN0RW1DLEtBQUssMHVIQUtGeUgscURBTUwsU0FBU0MsMkNBQTJDMUosT0FBUUQsUUFBU0YscUJBQ25FbUMsS0FBSyx3dUZBS0YySCwrREFNTCxTQUFTQyxtREFBbUQ1SixPQUFRRCxRQUFTRixxQkFDM0VtQyxLQUFLLDhsQkFLRjZILCtDQU1MLFNBQVNDLHFDQUFxQzlKLE9BQVFELFFBQVNGLHFCQUM3RG1DLEtBQUsseWJBS0YrSCxrREFNTCxTQUFTQyx3Q0FBd0NoSyxPQUFRRCxRQUFTRixxQkFDaEVtQyxLQUFLLDBoQkFLRmlJLHFEQU1MLFNBQVNDLDJDQUEyQ2xLLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssc3pFQUtGbUksZ0RBTUwsU0FBU0Msc0NBQXNDcEssT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSyxzMUJBS0ZxSSwyREFNTCxTQUFTQywrQ0FBK0N0SyxPQUFRRCxTQUM5RGlDLEtBQUssaVRBS0Z1SSxnREFNTCxTQUFTQyxzQ0FBc0N4SyxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLGdtQkFLRnlJLDhDQU1MLFNBQVNDLG9DQUFvQzFLLE9BQVFELFNBQ25EaUMsS0FBSyx1R0FLRjJJLGdEQU1MLFNBQVNDLHNDQUFzQzVLLE9BQVFELFFBQVNGLHFCQUM5RG1DLEtBQUssNDJCQUtGNkksOENBTUwsU0FBU0MscUNBQXFDOUssT0FBUUQsUUFBU0YscUJBQzdEbUMsS0FBSyxpMkdBS0YrSSxxREFNTCxTQUFTQywyQ0FBMkNoTCxPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLDY3QkFLRmlKLGtFQU1MLFNBQVNDLHVEQUF1RGxMLE9BQVFELFFBQVNGLHFCQUcvRW1DLEtBQUsseXRDQUtGbUosc0RBTUwsU0FBU0MsNENBQTRDcEwsT0FBUUQsUUFBU0YscUJBR3BFbUMsS0FBSyxna0xBS0ZxSixxREFNTCxTQUFTQywyQ0FBMkN0TCxPQUFRRCxRQUFTRixxQkFHbkVtQyxLQUFLLHk2RUFLRnVKLGdEQU1MLFNBQVNDLHVDQUF1Q3hMLE9BQVFELFNBQ3REaUMsS0FBSyxzR0FLRnlKLDJEQU1MLFNBQVNDLCtDQUErQzFMLE9BQVFELFFBQVNGLHFCQUN2RW1DLEtBQUssc1hBS0YySixvREFNTCxTQUFTQyx5Q0FBeUM1TCxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLCs3RkFLRjZKLGlEQU1MLFNBQVNDLHVDQUF1QzlMLE9BQVFELFNBQ3REaUMsS0FBSyx5V0FLRitKLG9EQU1MLFNBQVNDLDBDQUEwQ2hNLE9BQVFELFFBQVNGLHFCQUdsRW1DLEtBQUssMGtHQUtGaUssb0RBTUwsU0FBU0MsMENBQTBDbE0sT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyw0cEhBS0ZtSywrREFNTCxTQUFTQyxvREFBb0RwTSxPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLCs2Q0FLRnFLLDZEQU1MLFNBQVNDLGtEQUFrRHRNLE9BQVFELFFBQVNGLHFCQUMxRW1DLEtBQUssdTBFQUtGdUsseUVBTUwsU0FBU0MsNERBQTREeE0sT0FBUUQsUUFBU0YscUJBQ3BGbUMsS0FBSyxnekRBS0Z5Syw2RUFNTCxTQUFTQywrREFBK0QxTSxPQUFRRCxRQUFTRixxQkFDdkZtQyxLQUFLLDJ3Q0FLRjJLLG9FQU1MLFNBQVNDLHVEQUF1RDVNLE9BQVFELFFBQVNGLHFCQUMvRW1DLEtBQUssb3VCQUtGNkssc0VBTUwsU0FBU0MseURBQXlEOU0sT0FBUUQsU0FDeEVpQyxLQUFLLHlOQUtGK0ssOERBTUwsU0FBU0Msa0RBQWtEaE4sT0FBUUQsUUFBU0YscUJBQzFFbUMsS0FBSyw2MkNBS0ZpTCwyREFNTCxTQUFTQyxnREFBZ0RsTixPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLHVvQ0FLRm1MLDZEQU1MLFNBQVNDLGlEQUFpRHBOLE9BQVFELFFBQVNGLHFCQUN6RW1DLEtBQUssK1JBS0ZxTCwyREFNTCxTQUFTQyxnREFBZ0R0TixPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLDJwQ0FLRnVMLGtEQU1MLFNBQVNDLHdDQUF3Q3hOLE9BQVFELFFBQVNGLHFCQUNoRW1DLEtBQUssMGtCQUtGeUwsb0VBTUwsU0FBU0Msd0RBQXdEMU4sT0FBUUQsUUFBU0YscUJBR2hGbUMsS0FBSyx1dUJBS0YyTCw4REFNTCxTQUFTQyxrREFBa0Q1TixPQUFRRCxRQUFTRixxQkFDMUVtQyxLQUFLLHM0Q0FLRjZMLHVEQU1MLFNBQVNDLDRDQUE0QzlOLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssc2xCQUtGK0wsNERBTUwsU0FBU0MsaURBQWlEaE8sT0FBUUQsUUFBU0YscUJBQ3pFbUMsS0FBSywwL0JBS0ZpTSwrQ0FNTCxTQUFTQyxxQ0FBcUNsTyxPQUFRRCxRQUFTRixxQkFDN0RtQyxLQUFLLCtxQ0FLRm1NLDJDQU1MLFNBQVNDLGtDQUFrQ3BPLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssbU5BS0ZxTSwrREFNTCxTQUFTQyxvREFBb0R0TyxPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLDhmQUtGdU0sa0RBTUwsU0FBU0Msd0NBQXdDeE8sT0FBUUQsUUFBU0YscUJBR2hFbUMsS0FBSyxzL0JBS0Z5TSx3REFNTCxTQUFTQyw0Q0FBNEMxTyxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLHd5QkFLRjJNLGlEQU1MLFNBQVNDLHVDQUF1QzVPLE9BQVFELFFBQVNGLHFCQUMvRG1DLEtBQUssd1pBS0Y2TSxtREFNTCxTQUFTQyx5Q0FBeUM5TyxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLDZkQUtGK00sNkNBTUwsU0FBU0Msb0NBQW9DaFAsT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2ckJBS0ZpTix1REFNTCxTQUFTQyw2Q0FBNkNsUCxPQUFRRCxRQUFTRixxQkFDckVtQyxLQUFLLHd5REFLRm1OLG1FQU1MLFNBQVNDLHdEQUF3RHBQLE9BQVFELFFBQVNGLHFCQUNoRm1DLEtBQUssMjdCQUtGcU4sd0RBTUwsU0FBU0MsNkNBQTZDdFAsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyx5b0JBS0Z1Tix3REFNTCxTQUFTQyw2Q0FBNkN4UCxPQUFRRCxRQUFTRixxQkFDckVtQyxLQUFLLGtoQkFLRnlOLDZEQU1MLFNBQVNDLGlEQUFpRDFQLE9BQVFELFFBQVNGLHFCQUN6RW1DLEtBQUssd2ZBS0YyTixnREFNTCxTQUFTQyxzQ0FBc0M1UCxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLGdmQUtGNk4sZ0RBTUwsU0FBU0Msc0NBQXNDOVAsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSyx3YkFLRitOLG1EQU1MLFNBQVNDLHlDQUF5Q2hRLE9BQVFELFFBQVNGLHFCQUNqRW1DLEtBQUssMi9DQUtGaU8sc0RBTUwsU0FBU0MsMkNBQTJDbFEsT0FBUUQsUUFBU0YscUJBQ25FbUMsS0FBSyx1aUJBS0ZtTyw0REFNTCxTQUFTQyxnREFBZ0RwUSxPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLGlZQUtGcU8sZ0RBTUwsU0FBU0Msc0NBQXNDdFEsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSywwWUFLRnVPLG9EQU1MLFNBQVNDLHlDQUF5Q3hRLE9BQVFELFNBQ3hEaUMsS0FBSyxpUEFLRnlPLDBDQU1MLFNBQVNDLGlDQUFpQzFRLE9BQVFELFFBQVNGLHFCQUN6RG1DLEtBQUssd2JBS0YyTyx3REFNTCxTQUFTQyw0Q0FBNEM1USxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLG1aQUtGNk8sOERBTUwsU0FBU0Msa0RBQWtEOVEsT0FBUUQsUUFBU0YscUJBQzFFbUMsS0FBSyx3cUJBS0YrTywrREFNTCxTQUFTQyxtREFBbURoUixPQUFRRCxRQUFTRixxQkFDM0VtQyxLQUFLLHNiQUtGaVAsd0RBTUwsU0FBU0MsNkNBQTZDbFIsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyxna0RBS0ZtUCxrREFNTCxTQUFTQyx1Q0FBdUNwUixPQUFRRCxRQUFTRixxQkFDL0RtQyxLQUFLLGd6QkFLRnFQLHNEQU1MLFNBQVNDLDJDQUEyQ3RSLE9BQVFELFFBQVNGLHFCQUduRW1DLEtBQUssdzFHQUtGdVAsdURBTUwsU0FBU0MsNENBQTRDeFIsT0FBUUQsUUFBU0YscUJBR3BFbUMsS0FBSyw4akJBS0Z5UCwyQ0FNTCxTQUFTQyxpQ0FBaUMxUixPQUFRRCxRQUFTRixxQkFDekRtQyxLQUFLLGlSQUtGMlAscURBTUwsU0FBU0MsMENBQTBDNVIsT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyx1akJBS0Y2UCx3REFNTCxTQUFTQyw0Q0FBNEM5UixPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLDRzQkFLRitQLHVEQU1MLFNBQVNDLDRDQUE0Q2hTLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssOGpCQUtGaVEsMkNBTUwsU0FBU0MsaUNBQWlDbFMsT0FBUUQsUUFBU0YscUJBQ3pEbUMsS0FBSyxpUkFLRm1RLHVEQU1MLFNBQVNDLDRDQUE0Q3BTLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssb25EQUtGcVEsNERBTUwsU0FBU0MsZ0RBQWdEdFMsT0FBUUQsUUFBU0YscUJBR3hFbUMsS0FBSyx5ckhBS0Z1USxnREFNTCxTQUFTQyxxQ0FBcUN4UyxPQUFRRCxRQUFTRixxQkFDN0RtQyxLQUFLLGdTQUtGeVEsdUNBTUwsU0FBU0MsK0JBQStCMVMsT0FBUUQsU0FDOUNpQyxLQUFLLHUvS0FLRjJRLDBDQU1MLFNBQVNDLGtDQUFrQzVTLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssNHFXQUtGNlEsd0RBTUwsU0FBU0MsK0NBQStDOVMsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssd3dCQUtGZ1IseURBTUwsU0FBU0MsZ0RBQWdEalQsT0FBUStTLG9CQUFxQmxULHFCQUdwRm1DLEtBQUssMDVDQUtGa1Isc0RBTUwsU0FBU0MsNkNBQTZDblQsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssMG1DQUtGb1Isc0RBTUwsU0FBU0MsNkNBQTZDclQsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssc3pDQUtGc1Isa0RBTUwsU0FBU0MseUNBQXlDdlQsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssMGtFQUtGd1IscURBTUwsU0FBU0MsNENBQTRDelQsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssODdHQUtGMFIsa0RBTUwsU0FBU0MseUNBQXlDM1QsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssNHlLQUtGNFIsbURBTUwsU0FBU0MsMENBQTBDN1QsT0FBUStTLG9CQUFxQmxULHFCQUc5RW1DLEtBQUssMGdDQUtGOFIsbURBTUwsU0FBU0MsMENBQTBDL1QsT0FBUStTLG9CQUFxQmxULHFCQUc5RW1DLEtBQUssbytIQUtGZ1Msa0RBTUwsU0FBU0MseUNBQXlDalUsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssK2tFQUtGa1Msa0RBTUwsU0FBU0MseUNBQXlDblUsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssaXpEQUtGb1MsdURBTUwsU0FBU0MsNkNBQTZDclUsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssb3lDQUtGc1Msb0RBTUwsU0FBU0MsMkNBQTJDdlUsT0FBUStTLG9CQUFxQmxULHFCQUcvRW1DLEtBQUssc25DQUtGd1MseURBTUwsU0FBU0MsK0NBQStDelUsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssbXZCQUtGMFMscURBTUwsU0FBU0MsNENBQTRDM1UsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssa21DQUtGNFMsMkNBTUwsU0FBU0MsbUNBQW1DN1UsT0FBUStTLG9CQUFxQmxULHFCQUd2RW1DLEtBQUssbzBLQUtGOFMsNkNBTUwsU0FBU0MscUNBQXFDL1UsT0FBUStTLG9CQUFxQmxULHFCQUd6RW1DLEtBQUssdTZHQUtGZ1QsNENBTUwsU0FBU0Msb0NBQW9DalYsT0FBUStTLG9CQUFxQmxULHFCQUd4RW1DLEtBQUssbXNGQUtGa1QsK0NBTUwsU0FBU0MsdUNBQXVDblYsT0FBUStTLG9CQUFxQmxULHFCQUczRW1DLEtBQUssbTBEQUtGb1QsK0NBTUwsU0FBU0MsdUNBQXVDclYsT0FBUStTLG9CQUFxQmxULHFCQUczRW1DLEtBQUssOC9lQUtGc1QscURBTUwsU0FBU0MsNENBQTRDdlYsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssb3NDQUtGd1QsZ0VBTUwsU0FBU0MscURBQXFEelYsT0FBUStTLG9CQUFxQmxULHFCQUd6Rm1DLEtBQUssdW5EQUtGMFQseURBTUwsU0FBU0MsK0NBQStDM1YsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssd2lFQUtGNFQsNERBTUwsU0FBU0Msa0RBQWtEN1YsT0FBUStTLG9CQUFxQmxULHFCQUd0Rm1DLEtBQUssOGdFQUtGOFQsMkNBTUwsU0FBU0MsbUNBQW1DL1YsT0FBUStTLG9CQUFxQmxULHFCQUd2RW1DLEtBQUssdTBFQUtGZ1UscURBTUwsU0FBU0MsNENBQTRDalcsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssNmNBS0ZrVSxpREFNTCxTQUFTQyx3Q0FBd0NuVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyxxL0VBS0ZvVSxpREFNTCxTQUFTQyx3Q0FBd0NyVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyxrMEZBS0ZzVSxpREFNTCxTQUFTQyx3Q0FBd0N2VyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyw4dUVBS0Z3VSxxREFNTCxTQUFTQywyQ0FBMkN6VyxPQUFRK1Msb0JBQXFCbFQscUJBRy9FbUMsS0FBSywraUVBS0YwVSw0REFNTCxTQUFTQyxpREFBaUQzVyxPQUFRK1Msb0JBQXFCbFQscUJBR3JGbUMsS0FBSyxtaUJBS0Y0VSx3REFNTCxTQUFTQyw4Q0FBOEM3VyxPQUFRK1Msb0JBQXFCbFQscUJBR2xGbUMsS0FBSyx3dEJBS0Y4VSxpREFNTCxTQUFTQyx3Q0FBd0MvVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyx3L0VBS0ZnVixxREFNTCxTQUFTQywwQ0FBMENqWCxPQUFRK1Msb0JBQXFCbFQscUJBRzlFbUMsS0FBSyxrY0FLRmtWLHFEQU1MLFNBQVNDLDJDQUEyQ25YLE9BQVErUyxvQkFBcUJsVCxxQkFHL0VtQyxLQUFLLDJwQ0FLRm9WLHdEQU1MLFNBQVNDLDhDQUE4Q3JYLE9BQVErUyxvQkFBcUJsVCxxQkFHbEZtQyxLQUFLLDgwS0FLRnNWLG9DQU1MLFNBQVNDLDRCQUE0QnZYLE9BQVErUyxvQkFBcUJsVCxxQkFHaEVtQyxLQUFLLDZ6YUFLRndWLDJDQU1MLFNBQVNDLG1DQUFtQ3pYLE9BQVFELFNBQ2xEaUMsS0FBSyxnakJBS0YwViwyQkFNTCxTQUFTQyxvQkFBb0IzWCxPQUFRK1Msb0JBQXFCbFQscUJBR3hEbUMsS0FBSyxvZ09BS0Y0ViwyQkFNTCxTQUFTQyxvQkFBb0I3WCxPQUFRK1Msb0JBQXFCbFQscUJBR3hEbUMsS0FBSyIsImZpbGUiOiJjb250YWN0LnNjcmlwdHMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbi8qKioqKiovKGZ1bmN0aW9uIChtb2R1bGVzKSB7XG4gIC8vIHdlYnBhY2tCb290c3RyYXBcbiAgLyoqKioqKi8gLy8gVGhlIG1vZHVsZSBjYWNoZVxuICAvKioqKioqL1xuICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAvKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAvKioqKioqL1xuICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiAgICAvKioqKioqL2lmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuICAgICAgLyoqKioqKi9yZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gICAgLyoqKioqKi9cbiAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAvKioqKioqL2k6IG1vZHVsZUlkLFxuICAgICAgLyoqKioqKi9sOiBmYWxzZSxcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gICAgLyoqKioqKi9cbiAgICBtb2R1bGUubCA9IHRydWU7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH1cbiAgLyoqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uIChleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAvKioqKioqL2lmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gICAgICAvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAvKioqKioqL2lmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICB2YWx1ZTogJ01vZHVsZSdcbiAgICAgIH0pO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuICAvKioqKioqLyAvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiAgLyoqKioqKi8gLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gIC8qKioqKiovIC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuICAvKioqKioqLyAvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgIC8qKioqKiovaWYgKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuICAgIC8qKioqKiovXG4gICAgaWYgKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gICAgLyoqKioqKi9cbiAgICBpZiAobW9kZSAmIDQgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAvKioqKioqL1xuICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqKioqKi9cbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuICAgIC8qKioqKiovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICAvKioqKioqL1xuICAgIGlmIChtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICB9LmJpbmQobnVsbCwga2V5KSk7XG4gICAgfVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG5zO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKioqKioqL3ZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyAvKioqKioqL2Z1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107XG4gICAgfSA6IC8qKioqKiovZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiAgICAvKioqKioqL1xuICAgIHJldHVybiBnZXR0ZXI7XG4gICAgLyoqKioqKi9cbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gIC8qKioqKiovXG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvc2NyaXB0cy9jb250YWN0LmpzXCIpO1xuICAvKioqKioqL1xufVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovKSh7XG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNFc0FycmF5RnJvbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvZXMuYXJyYXkuZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcXFwiKTtcXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2ludGVybmFscy9wYXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLkFycmF5LmZyb207XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL21hcC9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0VzTWFwSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcXFwiKTtcXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2ludGVybmFscy9wYXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk1hcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNPYmplY3RBc3NpZ25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmFzc2lnbjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvc2V0L2luZGV4LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3NldC9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNTZXRJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5zZXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguU2V0O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3NldC9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3dlYWstbWFwL2luZGV4LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvd2Vhay1tYXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNXZWFrTWFwSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvZXMud2Vhay1tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguV2Vha01hcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy93ZWFrLW1hcC9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQUNhbGxhYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciB0cnlUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90cnktdG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQVBvc3NpYmxlUHJvdG90eXBlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcblxcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKFxcXCJDYW4ndCBzZXQgXFxcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FkZFRvVW5zY29wYWJsZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpLmY7XFxuXFxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXFxuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcXG4gIGRlZmluZVByb3BlcnR5KEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xcbiAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcXG4gIH0pO1xcbn1cXG5cXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQW5JbnN0YW5jZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xcbiAgaWYgKGlzUHJvdG90eXBlT2YoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcXG4gIHRocm93ICRUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQW5PYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyICRTdHJpbmcgPSBTdHJpbmc7XFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKCRTdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCIvLyBGRjI2LSBidWc6IEFycmF5QnVmZmVycyBhcmUgbm9uLWV4dGVuc2libGUsIGJ1dCBPYmplY3QuaXNFeHRlbnNpYmxlIGRvZXMgbm90IHJlcG9ydCBpdFxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoYnVmZmVyKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1ZmZlciwgJ2EnLCB7IHZhbHVlOiA4IH0pO1xcbiAgfVxcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5RnJvbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzXFxcIik7XFxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qc1xcXCIpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG52YXIgaXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGdldEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzXFxcIik7XFxudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG5cXG52YXIgJEFycmF5ID0gQXJyYXk7XFxuXFxuLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xcbiAgdmFyIElTX0NPTlNUUlVDVE9SID0gaXNDb25zdHJ1Y3Rvcih0aGlzKTtcXG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcXG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcXG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XFxuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PT0gJEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XFxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcXG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XFxuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XFxuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcXG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkobGVuZ3RoKTtcXG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XFxuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUluY2x1ZGVzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXFxcIik7XFxudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XFxuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xcbiAgICB2YXIgdmFsdWU7XFxuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXFxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJdGVyYXRpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanNcXFwiKTtcXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcXFwiKTtcXG5cXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcXG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XFxuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XFxuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XFxuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcXG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XFxuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShzZWxmKTtcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcXG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcXG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XFxuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XFxuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xcbiAgICAgIGlmIChUWVBFKSB7XFxuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XFxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXFxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcXG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcXG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcXG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QoNylcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlTbGljZVNpbXBsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1xcXCIpO1xcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcXFwiKTtcXG5cXG52YXIgJEFycmF5ID0gQXJyYXk7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcXG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcXG4gIHZhciByZXN1bHQgPSAkQXJyYXkobWF4KGZpbiAtIGssIDApKTtcXG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcXG4gIHJlc3VsdC5sZW5ndGggPSBuO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U3BlY2llc0NvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1xcXCIpO1xcbnZhciBpc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcXG52YXIgJEFycmF5ID0gQXJyYXk7XFxuXFxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xcbiAgdmFyIEM7XFxuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcXG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcXG4gICAgaWYgKGlzQ29uc3RydWN0b3IoQykgJiYgKEMgPT09ICRBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XFxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XFxuICAgICAgQyA9IENbU1BFQ0lFU107XFxuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U3BlY2llc0NyZWF0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcblxcbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XFxuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qc1xcXCIpO1xcblxcbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XFxuXFxudHJ5IHtcXG4gIHZhciBjYWxsZWQgPSAwO1xcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcXG4gICAgfSxcXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xcbiAgICB9XFxuICB9O1xcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcXG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcXG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xcbiAgdHJ5IHtcXG4gICAgdmFyIG9iamVjdCA9IHt9O1xcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH07XFxuICAgIGV4ZWMob2JqZWN0KTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mUmF3SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpc1JhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzXFxcIik7XFxuXFxudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXNSYXcoe30udG9TdHJpbmcpO1xcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzUmF3KCcnLnNsaWNlKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcXFwiKTtcXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xcblxcbi8vIEVTMyB3cm9uZyBoZXJlXFxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBpdFtrZXldO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbn07XFxuXFxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXFxuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXFxuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25TdHJvbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpLmY7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcXFwiKTtcXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1xcXCIpO1xcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzXFxcIik7XFxudmFyIGRlZmluZUl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWRlZmluZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzXFxcIik7XFxudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qc1xcXCIpO1xcbnZhciBzZXRTcGVjaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZmFzdEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanNcXFwiKS5mYXN0S2V5O1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpO1xcblxcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcXG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcXG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcXG4gICAgICAgIHNpemU6IDBcXG4gICAgICB9KTtcXG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaXRlcmFibGUpKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgeyB0aGF0OiB0aGF0LCBBU19FTlRSSUVTOiBJU19NQVAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xcblxcbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XFxuXFxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XFxuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcXG4gICAgICB2YXIgcHJldmlvdXMsIGluZGV4O1xcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxcbiAgICAgIGlmIChlbnRyeSkge1xcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcXG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcXG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxcbiAgICAgICAgICBrZXk6IGtleSxcXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXFxuICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcXG4gICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XFxuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xcbiAgICAgICAgLy8gYWRkIHRvIGluZGV4XFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XFxuICAgICAgfSByZXR1cm4gdGhhdDtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XFxuICAgICAgLy8gZmFzdCBjYXNlXFxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xcbiAgICAgIHZhciBlbnRyeTtcXG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcXG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcXG4gICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcXG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIHtcXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmNsZWFyXFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcXG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XFxuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcXG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcXG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcXG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtcXG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kZWxldGVcXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcXG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XFxuICAgICAgICBpZiAoZW50cnkpIHtcXG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXZpb3VzO1xcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcXG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubmV4dCA9IG5leHQ7XFxuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcXG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XFxuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcXG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XFxuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XFxuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xcbiAgICAgIH0sXFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKWAgbWV0aG9kc1xcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG4gICAgICAgIHZhciBlbnRyeTtcXG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XFxuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XFxuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IE1hcCwgU2V0fS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmhhc1xcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIElTX01BUCA/IHtcXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcXG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcXG4gICAgICB9LFxcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSA6IHtcXG4gICAgICAvLyBgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkoUHJvdG90eXBlLCAnc2l6ZScsIHtcXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbiAgfSxcXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcXG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XFxuICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XFxuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKElURVJBVE9SX05BTUUpO1xcbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmVudHJpZXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUtQEBpdGVyYXRvclxcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUudmFsdWVzXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXFxuICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcXG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXFxuICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcXG4gICAgICAgIGtpbmQ6IGtpbmQsXFxuICAgICAgICBsYXN0OiB1bmRlZmluZWRcXG4gICAgICB9KTtcXG4gICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcXG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XFxuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcXG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcXG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcXG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxcbiAgICAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XFxuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxcbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcXG4gICAgICB9XFxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZW50cnkua2V5LCBmYWxzZSk7XFxuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LnZhbHVlLCBmYWxzZSk7XFxuICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBmYWxzZSk7XFxuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcXG5cXG4gICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGVbQEBzcGVjaWVzXWAgYWNjZXNzb3JzXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LW1hcC1AQHNwZWNpZXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xcbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25XZWFrSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcXFwiKTtcXG52YXIgZ2V0V2Vha0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIikuZ2V0V2Vha0RhdGE7XFxudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUuanNcXFwiKTtcXG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcXFwiKTtcXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG5cXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XFxudmFyIGZpbmQgPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kO1xcbnZhciBmaW5kSW5kZXggPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kSW5kZXg7XFxudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzKFtdLnNwbGljZSk7XFxudmFyIGlkID0gMDtcXG5cXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSkge1xcbiAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XFxufTtcXG5cXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZW50cmllcyA9IFtdO1xcbn07XFxuXFxudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XFxuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XFxuICB9KTtcXG59O1xcblxcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcXG4gIH0sXFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcXG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xcbiAgICBlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XFxuICB9LFxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XFxuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XFxuICAgIH0pO1xcbiAgICBpZiAofmluZGV4KSBzcGxpY2UodGhpcy5lbnRyaWVzLCBpbmRleCwgMSk7XFxuICAgIHJldHVybiAhIX5pbmRleDtcXG4gIH1cXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XFxuICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XFxuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBQcm90b3R5cGUpO1xcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcXG4gICAgICAgIGlkOiBpZCsrLFxcbiAgICAgICAgZnJvemVuOiB1bmRlZmluZWRcXG4gICAgICB9KTtcXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG5cXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xcblxcbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xcbiAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XFxuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtcXG4gICAgICBlbHNlIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XFxuICAgICAgcmV0dXJuIHRoYXQ7XFxuICAgIH07XFxuXFxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwge1xcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmRlbGV0ZVxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuZGVsZXRlXFxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XFxuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcXG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcXG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSlbJ2RlbGV0ZSddKGtleSk7XFxuICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXNPd24oZGF0YSwgc3RhdGUuaWQpICYmIGRlbGV0ZSBkYXRhW3N0YXRlLmlkXTtcXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmhhc1xcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuaGFzXFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XFxuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XFxuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIElTX01BUCA/IHtcXG4gICAgICAvLyBgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZ2V0XFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcXG4gICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpO1xcbiAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5zZXRcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSA6IHtcXG4gICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5hZGRcXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29sbGVjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIik7XFxudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qc1xcXCIpO1xcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1xcXCIpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiKTtcXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xcbiAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XFxuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIHZhciBDb25zdHJ1Y3RvciA9IE5hdGl2ZUNvbnN0cnVjdG9yO1xcbiAgdmFyIGV4cG9ydGVkID0ge307XFxuXFxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMoTmF0aXZlUHJvdG90eXBlW0tFWV0pO1xcbiAgICBkZWZpbmVCdWlsdEluKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxcbiAgICAgIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xcbiAgICAgICAgdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XFxuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcXG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcXG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICAgIHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuICAgICk7XFxuICB9O1xcblxcbiAgdmFyIFJFUExBQ0UgPSBpc0ZvcmNlZChcXG4gICAgQ09OU1RSVUNUT1JfTkFNRSxcXG4gICAgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XFxuICAgIH0pKVxcbiAgKTtcXG5cXG4gIGlmIChSRVBMQUNFKSB7XFxuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXFxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcXG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xcbiAgICAvLyBWOCB+IENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XFxuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XFxuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XFxuICAgICAgdmFyIGluZGV4ID0gNTtcXG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XFxuICAgIH0pO1xcblxcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcXG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgTmF0aXZlUHJvdG90eXBlKTtcXG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XFxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoYXQ7XFxuICAgICAgfSk7XFxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gTmF0aXZlUHJvdG90eXBlO1xcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xcbiAgICB9XFxuXFxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XFxuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcXG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xcbiAgICB9XFxuXFxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xcblxcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XFxuICB9XFxuXFxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xcbiAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogQ29uc3RydWN0b3IgIT0gTmF0aXZlQ29uc3RydWN0b3IgfSwgZXhwb3J0ZWQpO1xcblxcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xcblxcbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xcblxcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29weUNvbnN0cnVjdG9yUHJvcGVydGllc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vd24ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XFxuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGtleSA9IGtleXNbaV07XFxuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XFxuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvcnJlY3RQcm90b3R5cGVHZXR0ZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cXG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZUl0ZXJSZXN1bHRPYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwiLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaXRlcnJlc3VsdG9iamVjdFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBkb25lKSB7XFxuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XFxufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XFxuICByZXR1cm4gb2JqZWN0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZVByb3BlcnR5RGVzY3JpcHRvckpzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XFxuICByZXR1cm4ge1xcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxcbiAgICB2YWx1ZTogdmFsdWVcXG4gIH07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ3JlYXRlUHJvcGVydHlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcXG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XFxuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRGVmaW5lQnVpbHRJbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBtYWtlQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XFxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcXG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XFxuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XFxuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcXG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XFxuICB9IGVsc2Uge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XFxuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XFxuICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxcbiAgICB9KTtcXG4gIH0gcmV0dXJuIE87XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVCdWlsdEluc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XFxuICByZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0RlZmluZUdsb2JhbFByb3BlcnR5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgdHJ5IHtcXG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcXG4gIH0gcmV0dXJuIHZhbHVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZXNjcmlwdG9yc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxuXFxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEb2N1bWVudEFsbEpzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJ2YXIgZG9jdW1lbnRBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xcblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3RcXG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkO1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgYWxsOiBkb2N1bWVudEFsbCxcXG4gIElTX0hUTUxEREE6IElTX0hUTUxEREFcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEb2N1bWVudENyZWF0ZUVsZW1lbnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcXG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVVzZXJBZ2VudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVY4VmVyc2lvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanNcXFwiKTtcXG5cXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XFxudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xcbnZhciBtYXRjaCwgdmVyc2lvbjtcXG5cXG5pZiAodjgpIHtcXG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcXG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXFxuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xcbn1cXG5cXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XFxuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcXFwvKFxcXFxkKykvKTtcXG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcXG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcXFwvKFxcXFxkKykvKTtcXG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbnVtQnVnS2V5c0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcXG5tb2R1bGUuZXhwb3J0cyA9IFtcXG4gICdjb25zdHJ1Y3RvcicsXFxuICAnaGFzT3duUHJvcGVydHknLFxcbiAgJ2lzUHJvdG90eXBlT2YnLFxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcXG4gICd0b0xvY2FsZVN0cmluZycsXFxuICAndG9TdHJpbmcnLFxcbiAgJ3ZhbHVlT2YnXFxuXTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFeHBvcnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCIpLmY7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qc1xcXCIpO1xcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1xcXCIpO1xcblxcbi8qXFxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcXG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXFxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcXG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXFxuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcXG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XFxuKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcXG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcXG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcXG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XFxuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xcbiAgaWYgKEdMT0JBTCkge1xcbiAgICB0YXJnZXQgPSBnbG9iYWw7XFxuICB9IGVsc2UgaWYgKFNUQVRJQykge1xcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcXG4gIH0gZWxzZSB7XFxuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xcbiAgfVxcbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XFxuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XFxuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XFxuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XFxuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XFxuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xcbiAgICB9XFxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XFxuICAgIH1cXG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZhaWxzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAhIWV4ZWMoKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRnJlZXppbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmRDb250ZXh0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanNcXFwiKTtcXG5cXG52YXIgYmluZCA9IHVuY3VycnlUaGlzKHVuY3VycnlUaGlzLmJpbmQpO1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XFxuICBhQ2FsbGFibGUoZm4pO1xcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xcbiAgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmROYXRpdmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXFxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkNhbGxKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qc1xcXCIpO1xcblxcbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRnVuY3Rpb25OYW1lSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG5cXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG5cXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIEVYSVNUUzogRVhJU1RTLFxcbiAgUFJPUEVSOiBQUk9QRVIsXFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLXJhdy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNSYXdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qc1xcXCIpO1xcblxcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcXG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XFxudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCAmJiBGdW5jdGlvblByb3RvdHlwZS5iaW5kLmJpbmQoY2FsbCwgY2FsbCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xcbiAgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxudmFyIHVuY3VycnlUaGlzUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1yYXcuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xcbiAgLy8gTmFzaG9ybiBidWc6XFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTI4XFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpc1Jhdyhmbik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dldEJ1aWx0SW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcblxcbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2V0SXRlcmF0b3JNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1xcXCIpO1xcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaXQpKSByZXR1cm4gZ2V0TWV0aG9kKGl0LCBJVEVSQVRPUilcXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXFxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRJdGVyYXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanNcXFwiKTtcXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xcXCIpO1xcblxcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XFxuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XFxuICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGNhbGwoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XFxuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1xcXCIpO1xcblxcbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xcbiAgdmFyIGZ1bmMgPSBWW1BdO1xcbiAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2xvYmFsSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XFxufTtcXG5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxcbm1vZHVsZS5leHBvcnRzID1cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIikpKVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hhc093blByb3BlcnR5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcXG5cXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XFxuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIaWRkZW5LZXlzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIdG1sSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0llOERvbURlZmluZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1xcXCIpO1xcblxcbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XFxuICB9KS5hICE9IDc7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5kZXhlZE9iamVjdEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xcblxcbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXFxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcXG4gIHJldHVybiAhJE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xcbn0pID8gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XFxufSA6ICRPYmplY3Q7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbmhlcml0SWZSZXF1aXJlZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxuXFxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xcbiAgaWYgKFxcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xcbiAgICBpc0NhbGxhYmxlKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcXG4gIHJldHVybiAkdGhpcztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5zcGVjdFNvdXJjZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG5cXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcXG5cXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXFxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XFxuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcXG4gIH07XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbE1ldGFkYXRhSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKS5mO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzXFxcIik7XFxudmFyIGlzRXh0ZW5zaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxudmFyIEZSRUVaSU5HID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZyZWV6aW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qc1xcXCIpO1xcblxcbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xcbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xcbnZhciBpZCA9IDA7XFxuXFxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XFxuICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHtcXG4gICAgb2JqZWN0SUQ6ICdPJyArIGlkKyssIC8vIG9iamVjdCBJRFxcbiAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcXG4gIH0gfSk7XFxufTtcXG5cXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XFxuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XFxuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXFxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxcbiAgICBzZXRNZXRhZGF0YShpdCk7XFxuICAvLyByZXR1cm4gb2JqZWN0IElEXFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XFxufTtcXG5cXG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxcbiAgICBzZXRNZXRhZGF0YShpdCk7XFxuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XFxufTtcXG5cXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXNPd24oaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxudmFyIGVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcbiAgUkVRVUlSRUQgPSB0cnVlO1xcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7XFxuICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMoW10uc3BsaWNlKTtcXG4gIHZhciB0ZXN0ID0ge307XFxuICB0ZXN0W01FVEFEQVRBXSA9IDE7XFxuXFxuICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxcbiAgaWYgKGdldE93blByb3BlcnR5TmFtZXModGVzdCkubGVuZ3RoKSB7XFxuICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAocmVzdWx0W2ldID09PSBNRVRBREFUQSkge1xcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcXG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUuZlxcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XFxuICBlbmFibGU6IGVuYWJsZSxcXG4gIGZhc3RLZXk6IGZhc3RLZXksXFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXFxuICBvbkZyZWV6ZTogb25GcmVlemVcXG59O1xcblxcbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbFN0YXRlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24uanNcXFwiKTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcXFwiKTtcXG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcXFwiKTtcXG5cXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XFxudmFyIHNldCwgZ2V0LCBoYXM7XFxuXFxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xcbn07XFxuXFxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHZhciBzdGF0ZTtcXG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcXG4gICAgfSByZXR1cm4gc3RhdGU7XFxuICB9O1xcbn07XFxuXFxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcXG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXFxuICBzdG9yZS5nZXQgPSBzdG9yZS5nZXQ7XFxuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XFxuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcXG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XFxuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xcbiAgICBzdG9yZS5zZXQoaXQsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XFxuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XFxuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XFxuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcXG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XFxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBzZXQ6IHNldCxcXG4gIGdldDogZ2V0LFxcbiAgaGFzOiBoYXMsXFxuICBlbmZvcmNlOiBlbmZvcmNlLFxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3JcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0FycmF5SXRlcmF0b3JNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXFxcIik7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQXJyYXlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxuXFxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xcbiAgcmV0dXJuIGNsYXNzb2YoYXJndW1lbnQpID09ICdBcnJheSc7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0NhbGxhYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkZG9jdW1lbnRBbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanNcXFwiKTtcXG5cXG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xcblxcbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcXG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQgPT09IGRvY3VtZW50QWxsO1xcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQ29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiKTtcXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qc1xcXCIpO1xcblxcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcbnZhciBlbXB0eSA9IFtdO1xcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxcXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxcXGIvO1xcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XFxudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcXG5cXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcXG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcXG4gIHRyeSB7XFxuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59O1xcblxcbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcXG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXFxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxufTtcXG5cXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xcblxcbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcXG5tb2R1bGUuZXhwb3J0cyA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgdmFyIGNhbGxlZDtcXG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXFxuICAgIHx8IGNhbGxlZDtcXG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0ZvcmNlZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxuXFxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFxcXC5wcm90b3R5cGVcXFxcLi87XFxuXFxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXFxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxcbiAgICA6ICEhZGV0ZWN0aW9uO1xcbn07XFxuXFxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcXG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcXG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzTnVsbE9yVW5kZWZpbmVkSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2VcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90LWFlY1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc09iamVjdEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgJGRvY3VtZW50QWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzXFxcIik7XFxuXFxudmFyIGRvY3VtZW50QWxsID0gJGRvY3VtZW50QWxsLmFsbDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KSB8fCBpdCA9PT0gZG9jdW1lbnRBbGw7XFxufSA6IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1B1cmVKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1N5bWJvbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcXG59IDogZnVuY3Rpb24gKGl0KSB7XFxuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qc1xcXCIpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qc1xcXCIpO1xcbnZhciBnZXRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXFxcIik7XFxudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcXG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XFxuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcXG59O1xcblxcbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcXG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XFxuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcXG4gIHZhciBJU19SRUNPUkQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfUkVDT1JEKTtcXG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XFxuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xcbiAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcXG5cXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xcbiAgfTtcXG5cXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcXG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XFxuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XFxuICAgIH0gcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xcbiAgfTtcXG5cXG4gIGlmIChJU19SRUNPUkQpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZS5pdGVyYXRvcjtcXG4gIH0gZWxzZSBpZiAoSVNfSVRFUkFUT1IpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcXG4gIH0gZWxzZSB7XFxuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcXG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcXG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XFxuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcXG4gICAgfVxcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xcbiAgfVxcblxcbiAgbmV4dCA9IElTX1JFQ09SRCA/IGl0ZXJhYmxlLm5leHQgOiBpdGVyYXRvci5uZXh0O1xcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xcbiAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XFxuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDbG9zZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtbWV0aG9kLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XFxuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XFxuICBhbk9iamVjdChpdGVyYXRvcik7XFxuICB0cnkge1xcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XFxuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcbiAgICBpbm5lclJlc3VsdCA9IGNhbGwoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xcbiAgfVxcbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xcbiAgcmV0dXJuIHZhbHVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdG9yQ3JlYXRlQ29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzXFxcIikuSXRlcmF0b3JQcm90b3R5cGU7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcXG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcXG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XFxuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3RvcjtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JEZWZpbmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXFxcIik7XFxudmFyIEZ1bmN0aW9uTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1uYW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3IuanNcXFwiKTtcXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1xcXCIpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiKTtcXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcXFwiKTtcXG5cXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxudmFyIEtFWVMgPSAna2V5cyc7XFxudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcXG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XFxuXFxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcXG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xcbiAgICBzd2l0Y2ggKEtJTkQpIHtcXG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcXG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xcbiAgfTtcXG5cXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXFxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcXG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XFxuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XFxuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XFxuXFxuICAvLyBmaXggbmF0aXZlXFxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcXG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XFxuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XFxuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XFxuICAgICAgICAgIGRlZmluZUJ1aWx0SW4oQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXFxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XFxuICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XFxuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbChuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcXG4gIGlmIChERUZBVUxUKSB7XFxuICAgIG1ldGhvZHMgPSB7XFxuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXFxuICAgIH07XFxuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcXG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XFxuICAgICAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XFxuICB9XFxuXFxuICAvLyBkZWZpbmUgaXRlcmF0b3JcXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xcbiAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XFxuICB9XFxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XFxuXFxuICByZXR1cm4gbWV0aG9kcztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJdGVyYXRvcnNDb3JlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1xcXCIpO1xcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xcblxcbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XFxuXFxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xcbmlmIChbXS5rZXlzKSB7XFxuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xcbiAgZWxzZSB7XFxuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcXG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxufVxcblxcbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gIWlzT2JqZWN0KEl0ZXJhdG9yUHJvdG90eXBlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICB2YXIgdGVzdCA9IHt9O1xcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXFxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwodGVzdCkgIT09IHRlc3Q7XFxufSk7XFxuXFxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XFxuZWxzZSBpZiAoSVNfUFVSRSkgSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xcblxcbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXFxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcXG4gIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdG9yc0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNMZW5ndGhPZkFycmF5TGlrZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcXFwiKTtcXG5cXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzTWFrZUJ1aWx0SW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qc1xcXCIpLkNPTkZJR1VSQUJMRTtcXG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG5cXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuXFxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xcbn0pO1xcblxcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcXG5cXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XFxuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcXFwoKFteKV0qKVxcXFwpLywgJyQxJykgKyAnXSc7XFxuICB9XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XFxuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcXG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XFxuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XFxuICB9XFxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcXG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XFxuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcXG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcXG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XFxuICB9IHJldHVybiB2YWx1ZTtcXG59O1xcblxcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xcbn0sICd0b1N0cmluZycpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNNYXRoVHJ1bmNKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxcbm1vZHVsZS5leHBvcnRzID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XFxuICB2YXIgbiA9ICt4O1xcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0QXNzaWduSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXFxcIik7XFxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcXG5cXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXFxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxcbiAgaWYgKERFU0NSSVBUT1JTICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcXG4gICAgICAgIHZhbHVlOiAzLFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XFxuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcXG4gIHZhciBBID0ge307XFxuICB2YXIgQiA9IHt9O1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN5bWJvbCAtLSBzYWZlXFxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XFxuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xcbiAgQVtzeW1ib2xdID0gNztcXG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcXG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XFxufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XFxuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBpbmRleCA9IDE7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XFxuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XFxuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcXG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xcbiAgICB2YXIgaiA9IDA7XFxuICAgIHZhciBrZXk7XFxuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XFxuICAgICAga2V5ID0ga2V5c1tqKytdO1xcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xcbiAgICB9XFxuICB9IHJldHVybiBUO1xcbn0gOiAkYXNzaWduO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RDcmVhdGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaHRtbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qc1xcXCIpO1xcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxuXFxudmFyIEdUID0gJz4nO1xcbnZhciBMVCA9ICc8JztcXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG5cXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcXG5cXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XFxufTtcXG5cXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XFxuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcXG4gIHJldHVybiB0ZW1wO1xcbn07XFxuXFxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XFxuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XFxuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XFxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcXG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XFxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XFxufTtcXG5cXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XFxuLy8gYXZvaWQgSUUgR0MgYnVnXFxudmFyIGFjdGl2ZVhEb2N1bWVudDtcXG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgdHJ5IHtcXG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxcbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXFxuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcXG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xcbn07XFxuXFxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xcblxcbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKE8gIT09IG51bGwpIHtcXG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XFxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XFxuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XFxuICAgIC8vIGFkZCBcXFwiX19wcm90b19fXFxcIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0RGVmaW5lUHJvcGVydGllc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcXFwiKTtcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcXG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIga2V5O1xcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xcbiAgcmV0dXJuIE87XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3REZWZpbmVQcm9wZXJ0eUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1xcXCIpO1xcblxcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcXG52YXIgQ09ORklHVVJBQkxFID0gJ2NvbmZpZ3VyYWJsZSc7XFxudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XFxuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XFxuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcXG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gICAgICBBdHRyaWJ1dGVzID0ge1xcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XFxuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XFxuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XFxuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XFxuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XFxuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCIvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXFxcIikuZjtcXG52YXIgYXJyYXlTbGljZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qc1xcXCIpO1xcblxcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXFxuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcXG5cXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XFxuICB9IGNhdGNoIChlcnJvcikge1xcbiAgICByZXR1cm4gYXJyYXlTbGljZSh3aW5kb3dOYW1lcyk7XFxuICB9XFxufTtcXG5cXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XFxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcXG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mKGl0KSA9PSAnV2luZG93J1xcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxcbiAgICA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcXG5cXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0UHJvdG90eXBlT2ZKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1xcXCIpO1xcblxcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG52YXIgJE9iamVjdCA9IE9iamVjdDtcXG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xcbiAgaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XFxuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XFxuICBpZiAoaXNDYWxsYWJsZShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0SXNFeHRlbnNpYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiKTtcXG52YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlLmpzXFxcIik7XFxuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUgLS0gc2FmZVxcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGlzRXh0ZW5zaWJsZSgxKTsgfSk7XFxuXFxuLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxcbm1vZHVsZS5leHBvcnRzID0gKEZBSUxTX09OX1BSSU1JVElWRVMgfHwgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFKSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcXG4gIGlmIChBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgJiYgY2xhc3NvZihpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWU7XFxufSA6ICRpc0V4dGVuc2libGU7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc1Byb3RvdHlwZU9mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RLZXlzSW50ZXJuYWxKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcXFwiKS5pbmRleE9mO1xcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1xcXCIpO1xcblxcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcXG4gIHZhciBpID0gMDtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIHZhciBrZXk7XFxuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XFxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXFxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093bihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0S2V5c0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gTmFzaG9ybiB+IEpESzggYnVnXFxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XFxuXFxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XFxuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcXG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFNldFByb3RvdHlwZU9mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXFxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XFxuICB2YXIgdGVzdCA9IHt9O1xcbiAgdmFyIHNldHRlcjtcXG4gIHRyeSB7XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcXG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcXG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcXG4gICAgYW5PYmplY3QoTyk7XFxuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XFxuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcXG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xcbiAgICByZXR1cm4gTztcXG4gIH07XFxufSgpIDogdW5kZWZpbmVkKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFRvU3RyaW5nSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1xcXCIpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiKTtcXG5cXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3JkaW5hcnlUb1ByaW1pdGl2ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XFxuICB2YXIgZm4sIHZhbDtcXG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcXG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgdGhyb3cgJFR5cGVFcnJvcihcXFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXFxcIik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3duS2V5c0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1xcXCIpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xcblxcbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcXG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XFxuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzUGF0aEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzUmVxdWlyZU9iamVjdENvZXJjaWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyAkVHlwZUVycm9yKFxcXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcXFwiICsgaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NldFNwZWNpZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxuXFxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XFxuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcXG5cXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcXG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2V0VG9TdHJpbmdUYWdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKS5mO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcXG4gIH1cXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkS2V5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxuXFxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZFN0b3JlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qc1xcXCIpO1xcblxcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcXG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXB1cmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcXFwiKTtcXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG5cXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XFxufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xcbiAgdmVyc2lvbjogJzMuMjYuMCcsXFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjYuMC9MSUNFTlNFJyxcXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N0cmluZ011bHRpYnl0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzXFxcIik7XFxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXFxcIik7XFxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcXFwiKTtcXG5cXG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcXG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcXG5cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcXG4gICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XFxuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcXG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcXG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XFxuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XFxuICAgIGZpcnN0ID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbik7XFxuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcXG4gICAgICAgICAgPyBjaGFyQXQoUywgcG9zaXRpb24pXFxuICAgICAgICAgIDogZmlyc3RcXG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcXG4gICAgICAgICAgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XFxuICB9O1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcXG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcXG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcXG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXFxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXFxuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXFxuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvQWJzb2x1dGVJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzXFxcIik7XFxuXFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcXG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXFxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XFxuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0luZGV4ZWRPYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvSW50ZWdlck9ySW5maW5pdHlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRydW5jID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL21hdGgtdHJ1bmMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanNcXFwiKTtcXG5cXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9MZW5ndGhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qc1xcXCIpO1xcblxcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvT2JqZWN0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxuXFxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiAkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9QcmltaXRpdmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qc1xcXCIpO1xcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xcblxcbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XFxuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcXG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcXG4gICAgdGhyb3cgJFR5cGVFcnJvcihcXFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXFxcIik7XFxuICB9XFxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XFxuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvUHJvcGVydHlLZXlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXFxcIik7XFxuXFxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcXG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvU3RyaW5nVGFnU3VwcG9ydEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbnZhciB0ZXN0ID0ge307XFxuXFxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9TdHJpbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1xcXCIpO1xcblxcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XFxuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUcnlUb1N0cmluZ0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJ2YXIgJFN0cmluZyA9IFN0cmluZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuICdPYmplY3QnO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVWlkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcblxcbnZhciBpZCA9IDA7XFxudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVXNlU3ltYm9sQXNVaWRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxcbiAgJiYgIVN5bWJvbC5zaGFtXFxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1Y4UHJvdG90eXBlRGVmaW5lQnVnSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxuXFxuLy8gVjggfiBDaHJvbWUgMzYtXFxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XFxuICAgIHZhbHVlOiA0MixcXG4gICAgd3JpdGFibGU6IGZhbHNlXFxuICB9KS5wcm90b3R5cGUgIT0gNDI7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlYWtNYXBCYXNpY0RldGVjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxuXFxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlbGxLbm93blN5bWJvbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcXFwiKTtcXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzXFxcIik7XFxudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1xcXCIpO1xcblxcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wgJiYgU3ltYm9sWydmb3InXTtcXG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XFxuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XFxuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpKSB7XFxuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcXG4gICAgfVxcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzQXJyYXlGcm9tSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGZyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qc1xcXCIpO1xcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanNcXFwiKTtcXG5cXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XFxufSk7XFxuXFxuLy8gYEFycmF5LmZyb21gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XFxuICBmcm9tOiBmcm9tXFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc0FycmF5SXRlcmF0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIikuZjtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanNcXFwiKTtcXG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG5cXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXFxuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXFxuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3JcXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXFxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XFxuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcXG4gIH0pO1xcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxcbn0sIGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XFxuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcXG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcXG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xcbiAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xcbiAgfVxcbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChpbmRleCwgZmFsc2UpO1xcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHRhcmdldFtpbmRleF0sIGZhbHNlKTtcXG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGZhbHNlKTtcXG59LCAndmFsdWVzJyk7XFxuXFxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XFxuXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XFxuXFxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xcbmlmICghSVNfUFVSRSAmJiBERVNDUklQVE9SUyAmJiB2YWx1ZXMubmFtZSAhPT0gJ3ZhbHVlcycpIHRyeSB7XFxuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XFxufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc01hcENvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGNvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qc1xcXCIpO1xcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qc1xcXCIpO1xcblxcbi8vIGBNYXBgIGNvbnN0cnVjdG9yXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xcbmNvbGxlY3Rpb24oJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcXG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzTWFwSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc09iamVjdEFzc2lnbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1xcXCIpO1xcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xcbiAgYXNzaWduOiBhc3NpZ25cXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNPYmplY3RUb1N0cmluZ0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanNcXFwiKTtcXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xcbiAgZGVmaW5lQnVpbHRJbihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmNvbnN0cnVjdG9yLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzU2V0Q29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgY29sbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb2xsZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzXFxcIik7XFxudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nLmpzXFxcIik7XFxuXFxuLy8gYFNldGAgY29uc3RydWN0b3JcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXFxuY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcXG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmNvbnN0cnVjdG9yLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTZXRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLy8gVE9ETzogUmVtb3ZlIHRoaXMgbW9kdWxlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyByZXBsYWNlZCB0byBtb2R1bGUgYmVsb3dcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTdHJpbmdJdGVyYXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciBjaGFyQXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xcXCIpLmNoYXJBdDtcXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanNcXFwiKTtcXG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xcblxcbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcXG4gICAgc3RyaW5nOiB0b1N0cmluZyhpdGVyYXRlZCksXFxuICAgIGluZGV4OiAwXFxuICB9KTtcXG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XFxuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcXG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xcbiAgdmFyIHBvaW50O1xcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XFxuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcXG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcXG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHBvaW50LCBmYWxzZSk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzV2Vha01hcENvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdElucyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzXFxcIik7XFxudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIik7XFxudmFyIGNvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qc1xcXCIpO1xcbnZhciBjb2xsZWN0aW9uV2VhayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpc0V4dGVuc2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzXFxcIik7XFxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpLmVuZm9yY2U7XFxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qc1xcXCIpO1xcblxcbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XFxudmFyIEludGVybmFsV2Vha01hcDtcXG5cXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChpbml0KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcXG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XFxuICB9O1xcbn07XFxuXFxuLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXFxudmFyICRXZWFrTWFwID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrKTtcXG5cXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XFxuLy8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxcbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xcbiAgSW50ZXJuYWxXZWFrTWFwID0gY29sbGVjdGlvbldlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgJ1dlYWtNYXAnLCB0cnVlKTtcXG4gIEludGVybmFsTWV0YWRhdGFNb2R1bGUuZW5hYmxlKCk7XFxuICB2YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcXG4gIHZhciBuYXRpdmVEZWxldGUgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXSk7XFxuICB2YXIgbmF0aXZlSGFzID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5oYXMpO1xcbiAgdmFyIG5hdGl2ZUdldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcXG4gIHZhciBuYXRpdmVTZXQgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLnNldCk7XFxuICBkZWZpbmVCdWlsdElucyhXZWFrTWFwUHJvdG90eXBlLCB7XFxuICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcXG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XFxuICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpO1xcbiAgICB9LFxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcXG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcXG4gICAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XFxuICAgICAgfSByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSk7XFxuICAgIH0sXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XFxuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlR2V0KHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XFxuICAgICAgfSByZXR1cm4gbmF0aXZlR2V0KHRoaXMsIGtleSk7XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcXG4gICAgICAgIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcXG4gICAgICB9IGVsc2UgbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNXZWFrTWFwSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9lcy53ZWFrLW1hcC5jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNMb2Rhc2hDbGFtcEluZGV4SnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXFxudmFyIE5BTiA9IDAgLyAwO1xcblxcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XFxuXFxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cXG52YXIgcmVUcmltID0gL15cXFxccyt8XFxcXHMrJC9nO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XFxuXFxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XFxuXFxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLyoqXFxuICogVXNlZCB0byByZXNvbHZlIHRoZVxcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxcbiAqIG9mIHZhbHVlcy5cXG4gKi9cXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXFxuICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXFxuICovXFxuZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XFxuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcXG4gICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcXG4gICAgfVxcbiAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbnVtYmVyO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXFxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdExpa2Uoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UobnVsbCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XFxufVxcblxcbi8qKlxcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLnRvTnVtYmVyKDMuMik7XFxuICogLy8gPT4gMy4yXFxuICpcXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xcbiAqIC8vID0+IDVlLTMyNFxcbiAqXFxuICogXy50b051bWJlcihJbmZpbml0eSk7XFxuICogLy8gPT4gSW5maW5pdHlcXG4gKlxcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xcbiAqIC8vID0+IDMuMlxcbiAqL1xcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcXG4gIH1cXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XFxuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXFxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xcbn1cXG5cXG4vKipcXG4gKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xcbiAqIC8vID0+IC01XFxuICpcXG4gKiBfLmNsYW1wKDEwLCAtNSwgNSk7XFxuICogLy8gPT4gNVxcbiAqL1xcbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XFxuICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xcbiAgICB1cHBlciA9IGxvd2VyO1xcbiAgICBsb3dlciA9IHVuZGVmaW5lZDtcXG4gIH1cXG4gIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xcbiAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcXG4gIH1cXG4gIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xcbiAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcXG4gIH1cXG4gIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsYW1wL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0xvZGFzaERlYm91bmNlSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFxcXCJGdW5jdGlvbnNcXFwiIG1ldGhvZHMuICovXFxudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcXG5cXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cXG52YXIgTkFOID0gMCAvIDA7XFxuXFxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcXG5cXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xcbnZhciByZVRyaW0gPSAvXlxcXFxzK3xcXFxccyskL2c7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcXG5cXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcXG5cXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xcbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcXG5cXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcXG5cXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xcblxcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xcbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xcblxcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcXG4gKiBvZiB2YWx1ZXMuXFxuICovXFxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XFxuXFxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xcbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXFxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgMi40LjBcXG4gKiBAY2F0ZWdvcnkgRGF0ZVxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcXG4gKiB9LCBfLm5vdygpKTtcXG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxcbiAqL1xcbnZhciBub3cgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiByb290LkRhdGUubm93KCk7XFxufTtcXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXFxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXFxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcXG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxcbiAqIGludm9jYXRpb24uXFxuICpcXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXFxuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXFxuICpcXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXFxuICpcXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXFxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxcbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXFxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XFxuICpcXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XFxuICogICAnbGVhZGluZyc6IHRydWUsXFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxcbiAqIH0pKTtcXG4gKlxcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXFxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XFxuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcXG4gKlxcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXFxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XFxuICovXFxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xcbiAgdmFyIGxhc3RBcmdzLFxcbiAgICAgIGxhc3RUaGlzLFxcbiAgICAgIG1heFdhaXQsXFxuICAgICAgcmVzdWx0LFxcbiAgICAgIHRpbWVySWQsXFxuICAgICAgbGFzdENhbGxUaW1lLFxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXFxuICAgICAgbWF4aW5nID0gZmFsc2UsXFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xcblxcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xcbiAgfVxcbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XFxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcXG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcXG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcXG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xcblxcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XFxuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XFxuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXFxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcXG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcXG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXFxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcXG5cXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XFxuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xcblxcbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXFxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcXG4gICAgdmFyIHRpbWUgPSBub3coKTtcXG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XFxuICAgIH1cXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXFxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xcblxcbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXFxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxcbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcXG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcXG4gICAgfVxcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xcbiAgICB9XFxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcXG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBmbHVzaCgpIHtcXG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XFxuICAgIHZhciB0aW1lID0gbm93KCksXFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xcblxcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcXG4gICAgbGFzdFRoaXMgPSB0aGlzO1xcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xcblxcbiAgICBpZiAoaXNJbnZva2luZykge1xcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xcbiAgICAgIH1cXG4gICAgICBpZiAobWF4aW5nKSB7XFxuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcXG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XFxuICByZXR1cm4gZGVib3VuY2VkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXFxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdExpa2Uoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UobnVsbCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XFxufVxcblxcbi8qKlxcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLnRvTnVtYmVyKDMuMik7XFxuICogLy8gPT4gMy4yXFxuICpcXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xcbiAqIC8vID0+IDVlLTMyNFxcbiAqXFxuICogXy50b051bWJlcihJbmZpbml0eSk7XFxuICogLy8gPT4gSW5maW5pdHlcXG4gKlxcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xcbiAqIC8vID0+IDMuMlxcbiAqL1xcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcXG4gIH1cXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XFxuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXFxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcXFwiKSkpXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvYm9vbGVhbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGJvb2xlYW4gKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0Jvb2xlYW5Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYm9vbGVhblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYm9vbGVhbjsgfSk7XFxuZnVuY3Rpb24gYm9vbGVhbihwcm90bywga2V5KSB7XFxuICAgIHZhciBhbGlhcyA9IFxcXCJfXFxcIiArIGtleTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2FsaWFzXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgYWxpYXMsIHtcXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEhdmFsLFxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVib3VuY2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0RlYm91bmNlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlYm91bmNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWJvdW5jZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmRlYm91bmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcblxcblxcbmZ1bmN0aW9uIGRlYm91bmNlKCkge1xcbiAgICB2YXIgb3B0aW9ucyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgb3B0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAoX3Byb3RvLCBrZXksIGRlc2NyaXB0b3IpIHtcXG4gICAgICAgIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb2Rhc2hfZGVib3VuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0LmEuYXBwbHkodm9pZCAwLCBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19zcHJlYWRBcnJheXNcXFwiXSkoW2ZuXSwgb3B0aW9ucykpLFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfTtcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9kZWJvdW5jZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiByYW5nZSwgYm9vbGVhbiwgZGVib3VuY2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmFuZ2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9yYW5nZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmFuZ2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyYW5nZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jvb2xlYW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYm9vbGVhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJvb2xlYW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ib29sZWFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImJvb2xlYW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWJvdW5jZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWJvdW5jZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlYm91bmNlXFxcIl07IH0pO1xcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogcmFuZ2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc1JhbmdlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJhbmdlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByYW5nZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcbmZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4KSB7XFxuICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAtSW5maW5pdHk7IH1cXG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG8sIGtleSkge1xcbiAgICAgICAgdmFyIGFsaWFzID0gXFxcIl9cXFwiICsga2V5O1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIHtcXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbYWxpYXNdO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBhbGlhcywge1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh2YWwsIG1pbiwgbWF4KSxcXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB9KTtcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9yYW5nZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGtleWJvYXJkSGFuZGxlciwgbW91c2VIYW5kbGVyLCByZXNpemVIYW5kbGVyLCBzZWxlY3RIYW5kbGVyLCB0b3VjaEhhbmRsZXIsIHdoZWVsSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNJbmRleEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleWJvYXJkICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9rZXlib2FyZC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW91c2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW91c2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL21vdXNlLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb3VzZUhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb3VzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJtb3VzZUhhbmRsZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVzaXplICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9yZXNpemUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlc2l6ZUhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwicmVzaXplSGFuZGxlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZWxlY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2VsZWN0SGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZWxlY3RIYW5kbGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG91Y2ggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3RvdWNoLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0b3VjaEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJ0b3VjaEhhbmRsZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93aGVlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93aGVlbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIndoZWVsSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3doZWVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIndoZWVsSGFuZGxlclxcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMva2V5Ym9hcmQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL2tleWJvYXJkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBrZXlib2FyZEhhbmRsZXIgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRXZlbnRzS2V5Ym9hcmRKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBrZXlib2FyZEhhbmRsZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgS0VZX0NPREU7XFxuKGZ1bmN0aW9uIChLRVlfQ09ERSkge1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiVEFCXFxcIl0gPSA5XSA9IFxcXCJUQUJcXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiU1BBQ0VcXFwiXSA9IDMyXSA9IFxcXCJTUEFDRVxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJQQUdFX1VQXFxcIl0gPSAzM10gPSBcXFwiUEFHRV9VUFxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJQQUdFX0RPV05cXFwiXSA9IDM0XSA9IFxcXCJQQUdFX0RPV05cXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiRU5EXFxcIl0gPSAzNV0gPSBcXFwiRU5EXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIkhPTUVcXFwiXSA9IDM2XSA9IFxcXCJIT01FXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIkxFRlRcXFwiXSA9IDM3XSA9IFxcXCJMRUZUXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIlVQXFxcIl0gPSAzOF0gPSBcXFwiVVBcXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiUklHSFRcXFwiXSA9IDM5XSA9IFxcXCJSSUdIVFxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJET1dOXFxcIl0gPSA0MF0gPSBcXFwiRE9XTlxcXCI7XFxufSkoS0VZX0NPREUgfHwgKEtFWV9DT0RFID0ge30pKTtcXG5mdW5jdGlvbiBrZXlib2FyZEhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBhZGRFdmVudCA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImV2ZW50U2NvcGVcXFwiXSkoc2Nyb2xsYmFyKTtcXG4gICAgdmFyIGNvbnRhaW5lciA9IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG4gICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICE9PSBjb250YWluZXIgJiYgIWNvbnRhaW5lci5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0VkaXRhYmxlKGFjdGl2ZUVsZW1lbnQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbHRhID0gZ2V0S2V5RGVsdGEoc2Nyb2xsYmFyLCBldnQua2V5Q29kZSB8fCBldnQud2hpY2gpO1xcbiAgICAgICAgaWYgKCFkZWx0YSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB4ID0gZGVsdGFbMF0sIHkgPSBkZWx0YVsxXTtcXG4gICAgICAgIHNjcm9sbGJhci5hZGRUcmFuc2Zvcm1hYmxlTW9tZW50dW0oeCwgeSwgZXZ0LCBmdW5jdGlvbiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIGlmICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyLmNvbnRhaW5lckVsLmJsdXIoKTtcXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhci5wYXJlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhci5wYXJlbnQuY29udGFpbmVyRWwuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gZ2V0S2V5RGVsdGEoc2Nyb2xsYmFyLCBrZXlDb2RlKSB7XFxuICAgIHZhciBzaXplID0gc2Nyb2xsYmFyLnNpemUsIGxpbWl0ID0gc2Nyb2xsYmFyLmxpbWl0LCBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0O1xcbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuVEFCOlxcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVUYWJLZXkoc2Nyb2xsYmFyKTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuU1BBQ0U6XFxuICAgICAgICAgICAgcmV0dXJuIFswLCAyMDBdO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5QQUdFX1VQOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLXNpemUuY29udGFpbmVyLmhlaWdodCArIDQwXTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuUEFHRV9ET1dOOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgc2l6ZS5jb250YWluZXIuaGVpZ2h0IC0gNDBdO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5FTkQ6XFxuICAgICAgICAgICAgcmV0dXJuIFswLCBsaW1pdC55IC0gb2Zmc2V0LnldO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5IT01FOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLW9mZnNldC55XTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuTEVGVDpcXG4gICAgICAgICAgICByZXR1cm4gWy00MCwgMF07XFxuICAgICAgICBjYXNlIEtFWV9DT0RFLlVQOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLTQwXTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuUklHSFQ6XFxuICAgICAgICAgICAgcmV0dXJuIFs0MCwgMF07XFxuICAgICAgICBjYXNlIEtFWV9DT0RFLkRPV046XFxuICAgICAgICAgICAgcmV0dXJuIFswLCA0MF07XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxufVxcbmZ1bmN0aW9uIGhhbmRsZVRhYktleShzY3JvbGxiYXIpIHtcXG4gICAgLy8gaGFuZGxlIGluIG5leHQgZnJhbWVcXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNjcm9sbGJhci5zY3JvbGxJbnRvVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50LCB7XFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiBzY3JvbGxiYXIuc2l6ZS5jb250YWluZXIuaGVpZ2h0IC8gMixcXG4gICAgICAgICAgICBvZmZzZXRMZWZ0OiBzY3JvbGxiYXIuc2l6ZS5jb250YWluZXIud2lkdGggLyAyLFxcbiAgICAgICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZSxcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gaXNFZGl0YWJsZShlbGVtKSB7XFxuICAgIGlmIChlbGVtLnRhZ05hbWUgPT09ICdJTlBVVCcgfHxcXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHxcXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fFxcbiAgICAgICAgZWxlbS5pc0NvbnRlbnRFZGl0YWJsZSkge1xcbiAgICAgICAgcmV0dXJuICFlbGVtLmRpc2FibGVkO1xcbiAgICB9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Ym9hcmQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL2tleWJvYXJkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL21vdXNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9tb3VzZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogbW91c2VIYW5kbGVyICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c01vdXNlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1vdXNlSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2VIYW5kbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcblxcblxcbnZhciBEaXJlY3Rpb247XFxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcXFwiWFxcXCJdID0gMF0gPSBcXFwiWFxcXCI7XFxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXFxcIllcXFwiXSA9IDFdID0gXFxcIllcXFwiO1xcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcXG5mdW5jdGlvbiBtb3VzZUhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBhZGRFdmVudCA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImV2ZW50U2NvcGVcXFwiXSkoc2Nyb2xsYmFyKTtcXG4gICAgdmFyIGNvbnRhaW5lciA9IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgdmFyIF9hID0gc2Nyb2xsYmFyLnRyYWNrLCB4QXhpcyA9IF9hLnhBeGlzLCB5QXhpcyA9IF9hLnlBeGlzO1xcbiAgICBmdW5jdGlvbiBjYWxjTW9tZW50dW0oZGlyZWN0aW9uLCBjbGlja1Bvc2l0aW9uKSB7XFxuICAgICAgICB2YXIgc2l6ZSA9IHNjcm9sbGJhci5zaXplLCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdCwgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldDtcXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5YKSB7XFxuICAgICAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBzaXplLmNvbnRhaW5lci53aWR0aCArICh4QXhpcy50aHVtYi5yZWFsU2l6ZSAtIHhBeGlzLnRodW1iLmRpc3BsYXlTaXplKTtcXG4gICAgICAgICAgICByZXR1cm4gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGNsaWNrUG9zaXRpb24gLyB0b3RhbFdpZHRoICogc2l6ZS5jb250ZW50LndpZHRoLCAwLCBsaW1pdC54KSAtIG9mZnNldC54O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlkpIHtcXG4gICAgICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSBzaXplLmNvbnRhaW5lci5oZWlnaHQgKyAoeUF4aXMudGh1bWIucmVhbFNpemUgLSB5QXhpcy50aHVtYi5kaXNwbGF5U2l6ZSk7XFxuICAgICAgICAgICAgcmV0dXJuIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShjbGlja1Bvc2l0aW9uIC8gdG90YWxIZWlnaHQgKiBzaXplLmNvbnRlbnQuaGVpZ2h0LCAwLCBsaW1pdC55KSAtIG9mZnNldC55O1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gZ2V0VHJhY2tEaXJlY3Rpb24oZWxlbSkge1xcbiAgICAgICAgaWYgKE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzT25lT2ZcXFwiXSkoZWxlbSwgW3hBeGlzLmVsZW1lbnQsIHhBeGlzLnRodW1iLmVsZW1lbnRdKSkge1xcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb24uWDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc09uZU9mXFxcIl0pKGVsZW0sIFt5QXhpcy5lbGVtZW50LCB5QXhpcy50aHVtYi5lbGVtZW50XSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9uLlk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICB9XFxuICAgIHZhciBpc01vdXNlRG93bjtcXG4gICAgdmFyIGlzTW91c2VNb3Zpbmc7XFxuICAgIHZhciBzdGFydE9mZnNldFRvVGh1bWI7XFxuICAgIHZhciB0cmFja0RpcmVjdGlvbjtcXG4gICAgdmFyIGNvbnRhaW5lclJlY3Q7XFxuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKGlzTW91c2VNb3ZpbmcgfHwgIU9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzT25lT2ZcXFwiXSkoZXZ0LnRhcmdldCwgW3hBeGlzLmVsZW1lbnQsIHlBeGlzLmVsZW1lbnRdKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0cmFjayA9IGV2dC50YXJnZXQ7XFxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ2V0VHJhY2tEaXJlY3Rpb24odHJhY2spO1xcbiAgICAgICAgdmFyIHJlY3QgPSB0cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIHZhciBjbGlja1BvcyA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCk7XFxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWCkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXRPblRyYWNrID0gY2xpY2tQb3MueCAtIHJlY3QubGVmdCAtIHhBeGlzLnRodW1iLmRpc3BsYXlTaXplIC8gMjtcXG4gICAgICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0oY2FsY01vbWVudHVtKGRpcmVjdGlvbiwgb2Zmc2V0T25UcmFjayksIDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlkpIHtcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0T25UcmFjayA9IGNsaWNrUG9zLnkgLSByZWN0LnRvcCAtIHlBeGlzLnRodW1iLmRpc3BsYXlTaXplIC8gMjtcXG4gICAgICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0oMCwgY2FsY01vbWVudHVtKGRpcmVjdGlvbiwgb2Zmc2V0T25UcmFjaykpO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKCFPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc09uZU9mXFxcIl0pKGV2dC50YXJnZXQsIFt4QXhpcy50aHVtYi5lbGVtZW50LCB5QXhpcy50aHVtYi5lbGVtZW50XSkpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpc01vdXNlRG93biA9IHRydWU7XFxuICAgICAgICB2YXIgdGh1bWIgPSBldnQudGFyZ2V0O1xcbiAgICAgICAgdmFyIGN1cnNvclBvcyA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCk7XFxuICAgICAgICB2YXIgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgICB0cmFja0RpcmVjdGlvbiA9IGdldFRyYWNrRGlyZWN0aW9uKHRodW1iKTtcXG4gICAgICAgIC8vIHBvaW50ZXIgb2Zmc2V0IHRvIHRodW1iXFxuICAgICAgICBzdGFydE9mZnNldFRvVGh1bWIgPSB7XFxuICAgICAgICAgICAgeDogY3Vyc29yUG9zLnggLSB0aHVtYlJlY3QubGVmdCxcXG4gICAgICAgICAgICB5OiBjdXJzb3JQb3MueSAtIHRodW1iUmVjdC50b3AsXFxuICAgICAgICB9O1xcbiAgICAgICAgLy8gY29udGFpbmVyIGJvdW5kaW5nIHJlY3RhbmdsZVxcbiAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIC8vIHByZXZlbnQgc2VsZWN0aW9uLCBzZWU6XFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWRpb3RXdS9zbW9vdGgtc2Nyb2xsYmFyL2lzc3Vlcy80OFxcbiAgICAgICAgT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2V0U3R5bGVcXFwiXSkoc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCB7XFxuICAgICAgICAgICAgJy11c2VyLXNlbGVjdCc6ICdub25lJyxcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG4gICAgYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKCFpc01vdXNlRG93bilcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICBpc01vdXNlTW92aW5nID0gdHJ1ZTtcXG4gICAgICAgIHZhciBjdXJzb3JQb3MgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJnZXRQb3NpdGlvblxcXCJdKShldnQpO1xcbiAgICAgICAgaWYgKHRyYWNrRGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWCkge1xcbiAgICAgICAgICAgIC8vIGdldCBwZXJjZW50YWdlIG9mIHBvaW50ZXIgcG9zaXRpb24gaW4gdHJhY2tcXG4gICAgICAgICAgICAvLyB0aGVuIHRyYW5mb3JtIHRvIHB4XFxuICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCBlYXNpbmdcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0T25UcmFjayA9IGN1cnNvclBvcy54IC0gc3RhcnRPZmZzZXRUb1RodW1iLnggLSBjb250YWluZXJSZWN0LmxlZnQ7XFxuICAgICAgICAgICAgc2Nyb2xsYmFyLnNldE1vbWVudHVtKGNhbGNNb21lbnR1bSh0cmFja0RpcmVjdGlvbiwgb2Zmc2V0T25UcmFjayksIDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRyYWNrRGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWSkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXRPblRyYWNrID0gY3Vyc29yUG9zLnkgLSBzdGFydE9mZnNldFRvVGh1bWIueSAtIGNvbnRhaW5lclJlY3QudG9wO1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5zZXRNb21lbnR1bSgwLCBjYWxjTW9tZW50dW0odHJhY2tEaXJlY3Rpb24sIG9mZnNldE9uVHJhY2spKTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ21vdXNldXAgYmx1cicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlzTW91c2VEb3duID0gaXNNb3VzZU1vdmluZyA9IGZhbHNlO1xcbiAgICAgICAgT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2V0U3R5bGVcXFwiXSkoc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCB7XFxuICAgICAgICAgICAgJy11c2VyLXNlbGVjdCc6ICcnLFxcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3VzZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvbW91c2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogcmVzaXplSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNSZXNpemVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVzaXplSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzaXplSGFuZGxlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmRlYm91bmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiByZXNpemVIYW5kbGVyKHNjcm9sbGJhcikge1xcbiAgICB2YXIgYWRkRXZlbnQgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJldmVudFNjb3BlXFxcIl0pKHNjcm9sbGJhcik7XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShzY3JvbGxiYXIudXBkYXRlLmJpbmQoc2Nyb2xsYmFyKSwgMzAwKSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNlbGVjdEhhbmRsZXIgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRXZlbnRzU2VsZWN0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNlbGVjdEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGVjdEhhbmRsZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC5jbGFtcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsYW1wL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gc2VsZWN0SGFuZGxlcihzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGFkZEV2ZW50ID0gT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZXZlbnRTY29wZVxcXCJdKShzY3JvbGxiYXIpO1xcbiAgICB2YXIgY29udGFpbmVyRWwgPSBzY3JvbGxiYXIuY29udGFpbmVyRWwsIGNvbnRlbnRFbCA9IHNjcm9sbGJhci5jb250ZW50RWw7XFxuICAgIHZhciBpc1NlbGVjdGVkID0gZmFsc2U7XFxuICAgIHZhciBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7IC8vIGZsYWcgdG8gcHJldmVudCBzZWxlY3Rpb24gd2hlbiBjb250ZXh0IG1lbnUgaXMgb3BlbmVkXFxuICAgIHZhciBhbmltYXRpb25JRDtcXG4gICAgZnVuY3Rpb24gc2Nyb2xsKF9hKSB7XFxuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xcbiAgICAgICAgaWYgKCF4ICYmICF5KVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIHZhciBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0LCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdDtcXG4gICAgICAgIC8vIERJU0FMTE9XIGRlbHRhIHRyYW5zZm9ybWF0aW9uXFxuICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG9mZnNldC54ICsgeCwgMCwgbGltaXQueCkgLSBvZmZzZXQueCwgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG9mZnNldC55ICsgeSwgMCwgbGltaXQueSkgLSBvZmZzZXQueSk7XFxuICAgICAgICBhbmltYXRpb25JRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc2Nyb2xsKHsgeDogeCwgeTogeSB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIGlmICghaXNTZWxlY3RlZClcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRCk7XFxuICAgICAgICB2YXIgZGlyID0gY2FsY01vbWVudHVtKHNjcm9sbGJhciwgZXZ0KTtcXG4gICAgICAgIHNjcm9sbChkaXIpO1xcbiAgICB9KTtcXG4gICAgLy8gcHJldmVudCBzY3JvbGxpbmcgd2hlbiBjb250ZXh0IG1lbnUgaXMgb3BlbmVkXFxuICAgIC8vIE5PVEU6IGBjb250ZXh0bWVudWAgZXZlbnQgbWF5IGJlIGZpcmVkXFxuICAgIC8vICAgICAgICAgIDEuIEJFRk9SRSBgc2VsZWN0c3RhcnRgOiB3aGVuIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSB0ZXh0IGNvbnRlbnQgLT4gcHJldmVudCBmdXR1cmUgc2Nyb2xsaW5nLFxcbiAgICAvLyAgICAgICAgICAyLiBBRlRFUiBgc2VsZWN0c3RhcnRgOiB3aGVuIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBibGFuayBhcmVhIC0+IGNhbmNlbCBjdXJyZW50IHNjcm9sbGluZyxcXG4gICAgLy8gICAgICAgIHNvIHdlIG5lZWQgdG8gYm90aCBzZXQgdGhlIGZsYWcgYW5kIGNhbmNlbCBjdXJyZW50IHNjcm9sbGluZ1xcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIHNldCB0aGUgZmxhZyB0byBwcmV2ZW50IGZ1dHVyZSBzY3JvbGxpbmdcXG4gICAgICAgIGlzQ29udGV4dE1lbnVPcGVuZWQgPSB0cnVlO1xcbiAgICAgICAgLy8gc3RvcCBjdXJyZW50IHNjcm9sbGluZ1xcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSUQpO1xcbiAgICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xcbiAgICB9KTtcXG4gICAgLy8gcmVzZXQgY29udGV4dCBtZW51IGZsYWcgb24gbW91c2UgZG93blxcbiAgICAvLyB0byBlbnN1cmUgdGhlIHNjcm9sbGluZyBpcyBhbGxvd2VkIGluIHRoZSBuZXh0IHNlbGVjdGlvblxcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChpc0NvbnRleHRNZW51T3BlbmVkKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSUQpO1xcbiAgICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudCh3aW5kb3csICdtb3VzZXVwIGJsdXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRCk7XFxuICAgICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XFxuICAgICAgICBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7XFxuICAgIH0pO1xcbiAgICAvLyBwYXRjaCBmb3IgdG91Y2ggZGV2aWNlc1xcbiAgICBhZGRFdmVudChjb250YWluZXJFbCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsVG9wID0gY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IDA7XFxuICAgIH0pO1xcbn1cXG5mdW5jdGlvbiBjYWxjTW9tZW50dW0oc2Nyb2xsYmFyLCBldnQpIHtcXG4gICAgdmFyIF9hID0gc2Nyb2xsYmFyLmJvdW5kaW5nLCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbSwgbGVmdCA9IF9hLmxlZnQ7XFxuICAgIHZhciBfYiA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCksIHggPSBfYi54LCB5ID0gX2IueTtcXG4gICAgdmFyIHJlcyA9IHtcXG4gICAgICAgIHg6IDAsXFxuICAgICAgICB5OiAwLFxcbiAgICB9O1xcbiAgICB2YXIgcGFkZGluZyA9IDIwO1xcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKVxcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgaWYgKHggPiByaWdodCAtIHBhZGRpbmcpIHtcXG4gICAgICAgIHJlcy54ID0gKHggLSByaWdodCArIHBhZGRpbmcpO1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKHggPCBsZWZ0ICsgcGFkZGluZykge1xcbiAgICAgICAgcmVzLnggPSAoeCAtIGxlZnQgLSBwYWRkaW5nKTtcXG4gICAgfVxcbiAgICBpZiAoeSA+IGJvdHRvbSAtIHBhZGRpbmcpIHtcXG4gICAgICAgIHJlcy55ID0gKHkgLSBib3R0b20gKyBwYWRkaW5nKTtcXG4gICAgfVxcbiAgICBlbHNlIGlmICh5IDwgdG9wICsgcGFkZGluZykge1xcbiAgICAgICAgcmVzLnkgPSAoeSAtIHRvcCAtIHBhZGRpbmcpO1xcbiAgICB9XFxuICAgIHJlcy54ICo9IDI7XFxuICAgIHJlcy55ICo9IDI7XFxuICAgIHJldHVybiByZXM7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvc2VsZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3RvdWNoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy90b3VjaC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogdG91Y2hIYW5kbGVyICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c1RvdWNoSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInRvdWNoSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG91Y2hIYW5kbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIGFjdGl2ZVNjcm9sbGJhcjtcXG5mdW5jdGlvbiB0b3VjaEhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciB0YXJnZXQgPSBzY3JvbGxiYXIub3B0aW9ucy5kZWxlZ2F0ZVRvIHx8IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgdmFyIHRvdWNoUmVjb3JkID0gbmV3IF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiVG91Y2hSZWNvcmRcXFwiXSgpO1xcbiAgICB2YXIgYWRkRXZlbnQgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJldmVudFNjb3BlXFxcIl0pKHNjcm9sbGJhcik7XFxuICAgIHZhciBkYW1waW5nO1xcbiAgICB2YXIgcG9pbnRlckNvdW50ID0gMDtcXG4gICAgYWRkRXZlbnQodGFyZ2V0LCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIC8vIHN0YXJ0IHJlY29yZHNcXG4gICAgICAgIHRvdWNoUmVjb3JkLnRyYWNrKGV2dCk7XFxuICAgICAgICAvLyBzdG9wIHNjcm9sbGluZ1xcbiAgICAgICAgc2Nyb2xsYmFyLnNldE1vbWVudHVtKDAsIDApO1xcbiAgICAgICAgLy8gc2F2ZSBkYW1waW5nXFxuICAgICAgICBpZiAocG9pbnRlckNvdW50ID09PSAwKSB7XFxuICAgICAgICAgICAgZGFtcGluZyA9IHNjcm9sbGJhci5vcHRpb25zLmRhbXBpbmc7XFxuICAgICAgICAgICAgc2Nyb2xsYmFyLm9wdGlvbnMuZGFtcGluZyA9IE1hdGgubWF4KGRhbXBpbmcsIDAuNSk7IC8vIGxlc3MgZnJhbWVzIG9uIHRvdWNobW92ZVxcbiAgICAgICAgfVxcbiAgICAgICAgcG9pbnRlckNvdW50Kys7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudCh0YXJnZXQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICBpZiAoYWN0aXZlU2Nyb2xsYmFyICYmIGFjdGl2ZVNjcm9sbGJhciAhPT0gc2Nyb2xsYmFyKVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIHRvdWNoUmVjb3JkLnVwZGF0ZShldnQpO1xcbiAgICAgICAgdmFyIF9hID0gdG91Y2hSZWNvcmQuZ2V0RGVsdGEoKSwgeCA9IF9hLngsIHkgPSBfYS55O1xcbiAgICAgICAgc2Nyb2xsYmFyLmFkZFRyYW5zZm9ybWFibGVNb21lbnR1bSh4LCB5LCBldnQsIGZ1bmN0aW9uICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgaWYgKHdpbGxTY3JvbGwgJiYgZXZ0LmNhbmNlbGFibGUpIHtcXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICAgIGFjdGl2ZVNjcm9sbGJhciA9IHNjcm9sbGJhcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxuICAgIGFkZEV2ZW50KHRhcmdldCwgJ3RvdWNoY2FuY2VsIHRvdWNoZW5kJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgdmFyIGRlbHRhID0gdG91Y2hSZWNvcmQuZ2V0RWFzaW5nRGlzdGFuY2UoZGFtcGluZyk7XFxuICAgICAgICBzY3JvbGxiYXIuYWRkVHJhbnNmb3JtYWJsZU1vbWVudHVtKGRlbHRhLngsIGRlbHRhLnksIGV2dCk7XFxuICAgICAgICBwb2ludGVyQ291bnQtLTtcXG4gICAgICAgIC8vIHJlc3RvcmUgZGFtcGluZ1xcbiAgICAgICAgaWYgKHBvaW50ZXJDb3VudCA9PT0gMCkge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5vcHRpb25zLmRhbXBpbmcgPSBkYW1waW5nO1xcbiAgICAgICAgfVxcbiAgICAgICAgdG91Y2hSZWNvcmQucmVsZWFzZShldnQpO1xcbiAgICAgICAgYWN0aXZlU2Nyb2xsYmFyID0gbnVsbDtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvdWNoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy90b3VjaC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy93aGVlbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHdoZWVsSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNXaGVlbEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ3aGVlbEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdoZWVsSGFuZGxlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHdoZWVsSGFuZGxlcihzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGFkZEV2ZW50ID0gT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZXZlbnRTY29wZVxcXCJdKShzY3JvbGxiYXIpO1xcbiAgICB2YXIgdGFyZ2V0ID0gc2Nyb2xsYmFyLm9wdGlvbnMuZGVsZWdhdGVUbyB8fCBzY3JvbGxiYXIuY29udGFpbmVyRWw7XFxuICAgIHZhciBldmVudE5hbWUgPSAoJ29ud2hlZWwnIGluIHdpbmRvdyB8fCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJykpID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJztcXG4gICAgYWRkRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZURlbHRhKGV2dCksIHggPSBfYS54LCB5ID0gX2EueTtcXG4gICAgICAgIHNjcm9sbGJhci5hZGRUcmFuc2Zvcm1hYmxlTW9tZW50dW0oeCwgeSwgZXZ0LCBmdW5jdGlvbiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIGlmICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuLy8gTm9ybWFsaXppbmcgd2hlZWwgZGVsdGFcXG52YXIgREVMVEFfU0NBTEUgPSB7XFxuICAgIFNUQU5EQVJEOiAxLFxcbiAgICBPVEhFUlM6IC0zLFxcbn07XFxudmFyIERFTFRBX01PREUgPSBbMS4wLCAyOC4wLCA1MDAuMF07XFxudmFyIGdldERlbHRhTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7IHJldHVybiBERUxUQV9NT0RFW21vZGVdIHx8IERFTFRBX01PREVbMF07IH07XFxuZnVuY3Rpb24gbm9ybWFsaXplRGVsdGEoZXZ0KSB7XFxuICAgIGlmICgnZGVsdGFYJyBpbiBldnQpIHtcXG4gICAgICAgIHZhciBtb2RlID0gZ2V0RGVsdGFNb2RlKGV2dC5kZWx0YU1vZGUpO1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB4OiBldnQuZGVsdGFYIC8gREVMVEFfU0NBTEUuU1RBTkRBUkQgKiBtb2RlLFxcbiAgICAgICAgICAgIHk6IGV2dC5kZWx0YVkgLyBERUxUQV9TQ0FMRS5TVEFOREFSRCAqIG1vZGUsXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGV2dCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB4OiBldnQud2hlZWxEZWx0YVggLyBERUxUQV9TQ0FMRS5PVEhFUlMsXFxuICAgICAgICAgICAgeTogZXZ0LndoZWVsRGVsdGFZIC8gREVMVEFfU0NBTEUuT1RIRVJTLFxcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICAvLyBpZSB3aXRoIHRvdWNocGFkXFxuICAgIHJldHVybiB7XFxuICAgICAgICB4OiAwLFxcbiAgICAgICAgeTogZXZ0LndoZWVsRGVsdGEgLyBERUxUQV9TQ0FMRS5PVEhFUlMsXFxuICAgIH07XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdoZWVsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy93aGVlbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2dldC1zaXplLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvZ2V0LXNpemUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0U2l6ZSAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJHZW9tZXRyeUdldFNpemVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0U2l6ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U2l6ZTsgfSk7XFxuZnVuY3Rpb24gZ2V0U2l6ZShzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGNvbnRhaW5lckVsID0gc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCBjb250ZW50RWwgPSBzY3JvbGxiYXIuY29udGVudEVsO1xcbiAgICB2YXIgY29udGFpbmVyU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXJFbCk7XFxuICAgIHZhciBwYWRkaW5ncyA9IFtcXG4gICAgICAgICdwYWRkaW5nVG9wJyxcXG4gICAgICAgICdwYWRkaW5nQm90dG9tJyxcXG4gICAgICAgICdwYWRkaW5nTGVmdCcsXFxuICAgICAgICAncGFkZGluZ1JpZ2h0JyxcXG4gICAgXS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgIHJldHVybiBjb250YWluZXJTdHlsZXNbcHJvcF0gPyBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlc1twcm9wXSkgOiAwO1xcbiAgICB9KTtcXG4gICAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IHBhZGRpbmdzWzBdICsgcGFkZGluZ3NbMV07XFxuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdzWzJdICsgcGFkZGluZ3NbM107XFxuICAgIHJldHVybiB7XFxuICAgICAgICBjb250YWluZXI6IHtcXG4gICAgICAgICAgICAvLyByZXF1aXJlcyBgb3ZlcmZsb3c6IGhpZGRlbmBcXG4gICAgICAgICAgICB3aWR0aDogY29udGFpbmVyRWwuY2xpZW50V2lkdGgsXFxuICAgICAgICAgICAgaGVpZ2h0OiBjb250YWluZXJFbC5jbGllbnRIZWlnaHQsXFxuICAgICAgICB9LFxcbiAgICAgICAgY29udGVudDoge1xcbiAgICAgICAgICAgIC8vIGJvcmRlciB3aWR0aCBhbmQgcGFkZGluZ3Mgc2hvdWxkIGJlIGluY2x1ZGVkXFxuICAgICAgICAgICAgd2lkdGg6IGNvbnRlbnRFbC5vZmZzZXRXaWR0aCAtIGNvbnRlbnRFbC5jbGllbnRXaWR0aCArIGNvbnRlbnRFbC5zY3JvbGxXaWR0aCArIGhvcml6b250YWxQYWRkaW5nLFxcbiAgICAgICAgICAgIGhlaWdodDogY29udGVudEVsLm9mZnNldEhlaWdodCAtIGNvbnRlbnRFbC5jbGllbnRIZWlnaHQgKyBjb250ZW50RWwuc2Nyb2xsSGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nLFxcbiAgICAgICAgfSxcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNpemUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvZ2V0LXNpemUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdldFNpemUsIGlzVmlzaWJsZSwgdXBkYXRlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SW5kZXhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtc2l6ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9nZXQtc2l6ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0U2l6ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2dldF9zaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImdldFNpemVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc192aXNpYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXZpc2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvaXMtdmlzaWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNWaXNpYmxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfaXNfdmlzaWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc1Zpc2libGVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91cGRhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidXBkYXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXBkYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInVwZGF0ZVxcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2lzLXZpc2libGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2lzLXZpc2libGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBpc1Zpc2libGUgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyR2VvbWV0cnlJc1Zpc2libGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNWaXNpYmxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1Zpc2libGU7IH0pO1xcbmZ1bmN0aW9uIGlzVmlzaWJsZShzY3JvbGxiYXIsIGVsZW0pIHtcXG4gICAgdmFyIGJvdW5kaW5nID0gc2Nyb2xsYmFyLmJvdW5kaW5nO1xcbiAgICB2YXIgdGFyZ2V0Qm91bmRpbmcgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAvLyBjaGVjayBvdmVybGFwcGluZ1xcbiAgICB2YXIgdG9wID0gTWF0aC5tYXgoYm91bmRpbmcudG9wLCB0YXJnZXRCb3VuZGluZy50b3ApO1xcbiAgICB2YXIgbGVmdCA9IE1hdGgubWF4KGJvdW5kaW5nLmxlZnQsIHRhcmdldEJvdW5kaW5nLmxlZnQpO1xcbiAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbihib3VuZGluZy5yaWdodCwgdGFyZ2V0Qm91bmRpbmcucmlnaHQpO1xcbiAgICB2YXIgYm90dG9tID0gTWF0aC5taW4oYm91bmRpbmcuYm90dG9tLCB0YXJnZXRCb3VuZGluZy5ib3R0b20pO1xcbiAgICByZXR1cm4gdG9wIDwgYm90dG9tICYmIGxlZnQgPCByaWdodDtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdmlzaWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pcy12aXNpYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvdXBkYXRlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogdXBkYXRlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5VXBkYXRlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInVwZGF0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlOyB9KTtcXG5mdW5jdGlvbiB1cGRhdGUoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBuZXdTaXplID0gc2Nyb2xsYmFyLmdldFNpemUoKTtcXG4gICAgdmFyIGxpbWl0ID0ge1xcbiAgICAgICAgeDogTWF0aC5tYXgobmV3U2l6ZS5jb250ZW50LndpZHRoIC0gbmV3U2l6ZS5jb250YWluZXIud2lkdGgsIDApLFxcbiAgICAgICAgeTogTWF0aC5tYXgobmV3U2l6ZS5jb250ZW50LmhlaWdodCAtIG5ld1NpemUuY29udGFpbmVyLmhlaWdodCwgMCksXFxuICAgIH07XFxuICAgIC8vIG1ldHJpY3NcXG4gICAgdmFyIGNvbnRhaW5lckJvdW5kaW5nID0gc2Nyb2xsYmFyLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICB2YXIgYm91bmRpbmcgPSB7XFxuICAgICAgICB0b3A6IE1hdGgubWF4KGNvbnRhaW5lckJvdW5kaW5nLnRvcCwgMCksXFxuICAgICAgICByaWdodDogTWF0aC5taW4oY29udGFpbmVyQm91bmRpbmcucmlnaHQsIHdpbmRvdy5pbm5lcldpZHRoKSxcXG4gICAgICAgIGJvdHRvbTogTWF0aC5taW4oY29udGFpbmVyQm91bmRpbmcuYm90dG9tLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxcbiAgICAgICAgbGVmdDogTWF0aC5tYXgoY29udGFpbmVyQm91bmRpbmcubGVmdCwgMCksXFxuICAgIH07XFxuICAgIC8vIGFzc2lnbiBwcm9wc1xcbiAgICBzY3JvbGxiYXIuc2l6ZSA9IG5ld1NpemU7XFxuICAgIHNjcm9sbGJhci5saW1pdCA9IGxpbWl0O1xcbiAgICBzY3JvbGxiYXIuYm91bmRpbmcgPSBib3VuZGluZztcXG4gICAgLy8gdXBkYXRlIHRyYWNrc1xcbiAgICBzY3JvbGxiYXIudHJhY2sudXBkYXRlKCk7XFxuICAgIC8vIHJlLXBvc2l0aW9uaW5nXFxuICAgIHNjcm9sbGJhci5zZXRQb3NpdGlvbigpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvdXBkYXRlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBTY3JvbGxiYXJQbHVnaW4sIGRlZmF1bHQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFySW5kZXhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb2x5ZmlsbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9seWZpbGxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Njcm9sbGJhciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvcGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxiYXJQbHVnaW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiU2Nyb2xsYmFyUGx1Z2luXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3R5bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc3R5bGUuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBjYXN0IGBJLlNjcm9sbGJhcmAgdG8gYFNjcm9sbGJhcmAgdG8gYXZvaWQgZXJyb3JcXG4gKlxcbiAqIGBJLlNjcm9sbGJhcmAgaXMgbm90IGFzc2lnbmFibGUgdG8gYFNjcm9sbGJhcmA6XFxuICogICAgIFxcXCJwcml2YXRlUHJvcFxcXCIgaXMgbWlzc2luZyBpbiBgSS5TY3JvbGxiYXJgXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjY3MlxcbiAqL1xcbnZhciBTbW9vdGhTY3JvbGxiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2V4dGVuZHNcXFwiXSkoU21vb3RoU2Nyb2xsYmFyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBTbW9vdGhTY3JvbGxiYXIoKSB7XFxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGEgc2Nyb2xsYmFyIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBpbml0aWFsaXplIHNjcm9sbGJhciB0b1xcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIEluaXRpYWwgb3B0aW9uc1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJleHBlY3QgZWxlbWVudCB0byBiZSBET00gRWxlbWVudCwgYnV0IGdvdCBcXFwiICsgZWxlbSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBhdHRhY2ggc3R5bGVzaGVldFxcbiAgICAgICAgT2JqZWN0KF9zdHlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJhdHRhY2hTdHlsZVxcXCJdKSgpO1xcbiAgICAgICAgaWYgKF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uaGFzKGVsZW0pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5ldyBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlNjcm9sbGJhclxcXCJdKGVsZW0sIG9wdGlvbnMpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQXV0b21hdGljYWxseSBpbml0IHNjcm9sbGJhciBvbiBhbGwgZWxlbWVudHMgYmFzZSBvbiB0aGUgc2VsZWN0b3IgYFtkYXRhLXNjcm9sbGJhcl1gXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBvcHRpb25zIEluaXRpYWwgb3B0aW9uc1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmluaXRBbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsYmFyXScpLCBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHJldHVybiBTbW9vdGhTY3JvbGxiYXIuaW5pdChlbGVtLCBvcHRpb25zKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYSBzY3JvbGxiYXIgb24gZ2l2ZW4gZWxlbWVudFxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBjaGVja1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmhhcyA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxiYXJNYXBcXFwiXS5oYXMoZWxlbSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHNjcm9sbGJhciBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAgICogSWYgbm8gc2Nyb2xsYmFyIGluc3RhbmNlIGV4c2l0cywgcmV0dXJucyBgdW5kZWZpbmVkYFxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBjaGVjay5cXG4gICAgICovXFxuICAgIFNtb290aFNjcm9sbGJhci5nZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBzY3JvbGxiYXIgaW5zdGFuY2VzXFxuICAgICAqL1xcbiAgICBTbW9vdGhTY3JvbGxiYXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxiYXJNYXBcXFwiXS52YWx1ZXMoKSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIHNjcm9sbGJhciBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgdmFyIHNjcm9sbGJhciA9IF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICAgICAgaWYgKHNjcm9sbGJhcikge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5kZXN0cm95KCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBzY3JvbGxiYXIgaW5zdGFuY2VzIGZyb20gY3VycmVudCBkb2N1bWVudFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRlc3Ryb3lBbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInNjcm9sbGJhck1hcFxcXCJdLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbGJhcikge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5kZXN0cm95KCk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaGVzIHBsdWdpbnMgdG8gc2Nyb2xsYmFyc1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gLi4uUGx1Z2lucyBTY3JvbGxiYXIgcGx1Z2luIGNsYXNzZXNcXG4gICAgICovXFxuICAgIFNtb290aFNjcm9sbGJhci51c2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgUGx1Z2lucyA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICBQbHVnaW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJhZGRQbHVnaW5zXFxcIl0uYXBwbHkodm9pZCAwLCBQbHVnaW5zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaGVzIGRlZmF1bHQgc3R5bGUgc2hlZXRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXFxuICAgICAqIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgbWFudWFsbHkgdW5sZXNzXFxuICAgICAqIHlvdSByZW1vdmVkIHRoZSBkZWZhdWx0IHN0eWxlcyB2aWEgYFNjcm9sbGJhci5kZXRhY2hTdHlsZSgpYFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmF0dGFjaFN0eWxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiYXR0YWNoU3R5bGVcXFwiXSkoKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgZGVmYXVsdCBzdHlsZXMgZnJvbSBjdXJyZW50IGRvY3VtZW50LlxcbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gY3NzIGZvciBzY3JvbGxiYXJzLlxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRldGFjaFN0eWxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGV0YWNoU3R5bGVcXFwiXSkoKTtcXG4gICAgfTtcXG4gICAgU21vb3RoU2Nyb2xsYmFyLnZlcnNpb24gPSBcXFwiOC44LjFcXFwiO1xcbiAgICBTbW9vdGhTY3JvbGxiYXIuU2Nyb2xsYmFyUGx1Z2luID0gX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJTY3JvbGxiYXJQbHVnaW5cXFwiXTtcXG4gICAgcmV0dXJuIFNtb290aFNjcm9sbGJhcjtcXG59KF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiU2Nyb2xsYmFyXFxcIl0pKTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChTbW9vdGhTY3JvbGxiYXIpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IE9wdGlvbnMgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyT3B0aW9uc0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJPcHRpb25zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPcHRpb25zOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlY29yYXRvcnMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG52YXIgT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gT3B0aW9ucyhjb25maWcpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTW9tZW50dW0gcmVkdWN0aW9uIGRhbXBpbmcgZmFjdG9yLCBhIGZsb2F0IHZhbHVlIGJldHdlZW4gYCgwLCAxKWAuXFxuICAgICAgICAgKiBUaGUgbG93ZXIgdGhlIHZhbHVlIGlzLCB0aGUgbW9yZSBzbW9vdGggdGhlIHNjcm9sbGluZyB3aWxsIGJlXFxuICAgICAgICAgKiAoYWxzbyB0aGUgbW9yZSBwYWludCBmcmFtZXMpLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmRhbXBpbmcgPSAwLjE7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1pbmltYWwgc2l6ZSBmb3Igc2Nyb2xsYmFyIHRodW1icy5cXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy50aHVtYk1pblNpemUgPSAyMDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogUmVuZGVyIGV2ZXJ5IGZyYW1lIGluIGludGVnZXIgcGl4ZWwgdmFsdWVzXFxuICAgICAgICAgKiBzZXQgdG8gYHRydWVgIHRvIGltcHJvdmUgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnJlbmRlckJ5UGl4ZWxzID0gdHJ1ZTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogS2VlcCBzY3JvbGxiYXIgdHJhY2tzIHZpc2libGVcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5hbHdheXNTaG93VHJhY2tzID0gZmFsc2U7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgb3V0ZXIgc2Nyb2xsYmFycyBjb250aW51ZSBzY3JvbGxpbmdcXG4gICAgICAgICAqIHdoZW4gY3VycmVudCBzY3JvbGxiYXIgcmVhY2hlcyBlZGdlLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNTY3JvbGxpbmcgPSB0cnVlO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBEZWxlZ2F0ZSB3aGVlbCBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBjb250YWluZXIgZWxlbWVudCBpcyB1c2VkLlxcbiAgICAgICAgICogVGhpcyBvcHRpb24gd2lsbCBiZSB1c2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBmaXhlZCBlbGVtZW50cy5cXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZVRvID0gbnVsbDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogT3B0aW9ucyBmb3IgcGx1Z2lucy4gU3ludGF4OlxcbiAgICAgICAgICogICBwbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luT3B0aW9uczogYW55XFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XFxuICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBjb25maWdbcHJvcF07XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJ3aGVlbEV2ZW50VGFyZ2V0XFxcIiwge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVUbztcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3Ntb290aC1zY3JvbGxiYXJdOiBgb3B0aW9ucy53aGVlbEV2ZW50VGFyZ2V0YCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgdXNlIGBvcHRpb25zLmRlbGVnYXRlVG9gIGluc3RlYWQuJyk7XFxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZVRvID0gZWw7XFxuICAgICAgICB9LFxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fZGVjb3JhdGVcXFwiXSkoW1xcbiAgICAgICAgT2JqZWN0KF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJyYW5nZVxcXCJdKSgwLCAxKVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcImRhbXBpbmdcXFwiLCB2b2lkIDApO1xcbiAgICBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19kZWNvcmF0ZVxcXCJdKShbXFxuICAgICAgICBPYmplY3QoX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJhbmdlXFxcIl0pKDAsIEluZmluaXR5KVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcInRodW1iTWluU2l6ZVxcXCIsIHZvaWQgMCk7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJib29sZWFuXFxcIl1cXG4gICAgXSwgT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJyZW5kZXJCeVBpeGVsc1xcXCIsIHZvaWQgMCk7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJib29sZWFuXFxcIl1cXG4gICAgXSwgT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJhbHdheXNTaG93VHJhY2tzXFxcIiwgdm9pZCAwKTtcXG4gICAgT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fZGVjb3JhdGVcXFwiXSkoW1xcbiAgICAgICAgX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImJvb2xlYW5cXFwiXVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcImNvbnRpbnVvdXNTY3JvbGxpbmdcXFwiLCB2b2lkIDApO1xcbiAgICByZXR1cm4gT3B0aW9ucztcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbnMuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BsdWdpbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wbHVnaW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFNjcm9sbGJhclBsdWdpbiwgZ2xvYmFsUGx1Z2lucywgYWRkUGx1Z2lucywgaW5pdFBsdWdpbnMgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUGx1Z2luSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclBsdWdpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyUGx1Z2luOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnbG9iYWxQbHVnaW5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnbG9iYWxQbHVnaW5zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZGRQbHVnaW5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRQbHVnaW5zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpbml0UGx1Z2luc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5pdFBsdWdpbnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xcXCIpO1xcblxcbnZhciBTY3JvbGxiYXJQbHVnaW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFNjcm9sbGJhclBsdWdpbihzY3JvbGxiYXIsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcXG4gICAgICAgIHRoaXMuc2Nyb2xsYmFyID0gc2Nyb2xsYmFyO1xcbiAgICAgICAgdGhpcy5uYW1lID0gX25ld1RhcmdldC5wbHVnaW5OYW1lO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fYXNzaWduXFxcIl0pKE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgX25ld1RhcmdldC5kZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIFNjcm9sbGJhclBsdWdpbi5wcm90b3R5cGUub25Jbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xcbiAgICBTY3JvbGxiYXJQbHVnaW4ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS5vblJlbmRlciA9IGZ1bmN0aW9uIChfcmVtYWluTW9tZW50dW0pIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS50cmFuc2Zvcm1EZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgX2V2dCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgZGVsdGEpO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXJQbHVnaW4ucGx1Z2luTmFtZSA9ICcnO1xcbiAgICBTY3JvbGxiYXJQbHVnaW4uZGVmYXVsdE9wdGlvbnMgPSB7fTtcXG4gICAgcmV0dXJuIFNjcm9sbGJhclBsdWdpbjtcXG59KCkpO1xcblxcbnZhciBnbG9iYWxQbHVnaW5zID0ge1xcbiAgICBvcmRlcjogbmV3IFNldCgpLFxcbiAgICBjb25zdHJ1Y3RvcnM6IHt9LFxcbn07XFxuZnVuY3Rpb24gYWRkUGx1Z2lucygpIHtcXG4gICAgdmFyIFBsdWdpbnMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIFBsdWdpbnNbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICBQbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKFApIHtcXG4gICAgICAgIHZhciBwbHVnaW5OYW1lID0gUC5wbHVnaW5OYW1lO1xcbiAgICAgICAgaWYgKCFwbHVnaW5OYW1lKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicGx1Z2luIG5hbWUgaXMgcmVxdWlyZWRcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsb2JhbFBsdWdpbnMub3JkZXIuYWRkKHBsdWdpbk5hbWUpO1xcbiAgICAgICAgZ2xvYmFsUGx1Z2lucy5jb25zdHJ1Y3RvcnNbcGx1Z2luTmFtZV0gPSBQO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gaW5pdFBsdWdpbnMoc2Nyb2xsYmFyLCBvcHRpb25zKSB7XFxuICAgIHJldHVybiBBcnJheS5mcm9tKGdsb2JhbFBsdWdpbnMub3JkZXIpXFxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XFxuICAgICAgICByZXR1cm4gb3B0aW9uc1twbHVnaW5OYW1lXSAhPT0gZmFsc2U7XFxuICAgIH0pXFxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XFxuICAgICAgICB2YXIgUGx1Z2luID0gZ2xvYmFsUGx1Z2lucy5jb25zdHJ1Y3RvcnNbcGx1Z2luTmFtZV07XFxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgUGx1Z2luKHNjcm9sbGJhciwgb3B0aW9uc1twbHVnaW5OYW1lXSk7XFxuICAgICAgICAvLyBiaW5kIHBsdWdpbiBvcHRpb25zIHRvIGBzY3JvbGxiYXIub3B0aW9uc2BcXG4gICAgICAgIG9wdGlvbnNbcGx1Z2luTmFtZV0gPSBpbnN0YW5jZS5vcHRpb25zO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BsdWdpbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wb2x5ZmlsbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUG9seWZpbGxzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvbWFwL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfbWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc19tYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfc2V0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL2VzL3NldCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9zZXQvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19zZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX2VzX3NldF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc193ZWFrX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy93ZWFrLW1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy93ZWFrLW1hcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX3dlYWtfbWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc193ZWFrX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19hcnJheV9mcm9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL2VzL2FycmF5L2Zyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX2VzX2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfb2JqZWN0X2Fzc2lnbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy9vYmplY3QvYXNzaWduICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9hc3NpZ24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19vYmplY3RfYXNzaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc19vYmplY3RfYXNzaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wb2x5ZmlsbHMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsYmFyLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBzY3JvbGxiYXJNYXAsIFNjcm9sbGJhciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxiYXJKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsYmFyTWFwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxiYXJNYXA7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcHRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29wdGlvbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVjb3JhdG9ycy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhY2tfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYWNrLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dlb21ldHJ5LyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Nyb2xsaW5nX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3JvbGxpbmcvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3Njcm9sbGluZy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BsdWdpbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZlbnRzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyBETyBOT1QgdXNlIFdlYWtNYXAgaGVyZVxcbi8vIC5nZXRBbGwoKSBtZXRob2RzIHJlcXVpcmVzIGBzY3JvbGxiYXJNYXAudmFsdWVzKClgXFxudmFyIHNjcm9sbGJhck1hcCA9IG5ldyBNYXAoKTtcXG52YXIgU2Nyb2xsYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIoY29udGFpbmVyRWwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEN1cnJlbnQgc2Nyb2xsaW5nIG9mZnNldHNcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB7XFxuICAgICAgICAgICAgeDogMCxcXG4gICAgICAgICAgICB5OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTWF4LWFsbG93ZWQgc2Nyb2xsaW5nIG9mZnNldHNcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5saW1pdCA9IHtcXG4gICAgICAgICAgICB4OiBJbmZpbml0eSxcXG4gICAgICAgICAgICB5OiBJbmZpbml0eSxcXG4gICAgICAgIH07XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIENvbnRhaW5lciBib3VuZGluZyByZWN0XFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuYm91bmRpbmcgPSB7XFxuICAgICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcXG4gICAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIC8vIHByaXZhdGUgX29ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbXTtcXG4gICAgICAgIHRoaXMuX21vbWVudHVtID0geyB4OiAwLCB5OiAwIH07XFxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XFxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XFxuICAgICAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBfb3B0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJPcHRpb25zXFxcIl0ob3B0aW9ucyk7XFxuICAgICAgICAvLyBtYXJrIGFzIGEgc2Nyb2xsIGVsZW1lbnRcXG4gICAgICAgIGNvbnRhaW5lckVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGxiYXInLCAndHJ1ZScpO1xcbiAgICAgICAgLy8gbWFrZSBjb250YWluZXIgZm9jdXNhYmxlXFxuICAgICAgICBjb250YWluZXJFbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250YWluZXJFbCwge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vIGVuYWJsZSB0b3VjaCBldmVudCBjYXB0dXJpbmcgaW4gSUUsIHNlZTpcXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pZGlvdFd1L3Ntb290aC1zY3JvbGxiYXIvaXNzdWVzLzM5XFxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XFxuICAgICAgICAgICAgY29udGFpbmVyRWwuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIG1vdW50IGNvbnRlbnRcXG4gICAgICAgIGNvbnRlbnRFbC5jbGFzc05hbWUgPSAnc2Nyb2xsLWNvbnRlbnQnO1xcbiAgICAgICAgQXJyYXkuZnJvbShjb250YWluZXJFbC5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgICAgICAgY29udGVudEVsLmFwcGVuZENoaWxkKG5vZGUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xcbiAgICAgICAgLy8gYXR0YWNoIHRyYWNrXFxuICAgICAgICB0aGlzLnRyYWNrID0gbmV3IF90cmFja19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVHJhY2tDb250cm9sbGVyXFxcIl0odGhpcyk7XFxuICAgICAgICAvLyBpbml0aWFsIG1lYXN1cmluZ1xcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5nZXRTaXplKCk7XFxuICAgICAgICAvLyBpbml0IHBsdWdpbnNcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBPYmplY3QoX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJpbml0UGx1Z2luc1xcXCJdKSh0aGlzLCB0aGlzLm9wdGlvbnMucGx1Z2lucyk7XFxuICAgICAgICAvLyBwcmVzZXJ2ZSBzY3JvbGwgb2Zmc2V0XFxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGNvbnRhaW5lckVsLnNjcm9sbExlZnQsIHNjcm9sbFRvcCA9IGNvbnRhaW5lckVsLnNjcm9sbFRvcDtcXG4gICAgICAgIGNvbnRhaW5lckVsLnNjcm9sbExlZnQgPSBjb250YWluZXJFbC5zY3JvbGxUb3AgPSAwO1xcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHtcXG4gICAgICAgICAgICB3aXRob3V0Q2FsbGJhY2tzOiB0cnVlLFxcbiAgICAgICAgfSk7XFxuICAgICAgICAvLyBGSVhNRTogdXBkYXRlIHR5cGVzY3JpcHRcXG4gICAgICAgIHZhciBSZXNpemVPYnNlcnZlciA9IHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcXG4gICAgICAgIC8vIG9ic2VydmVcXG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoY29udGVudEVsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNjcm9sbGJhck1hcC5zZXQoY29udGFpbmVyRWwsIHRoaXMpO1xcbiAgICAgICAgLy8gd2FpdCBmb3IgRE9NIHJlYWR5XFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9pbml0KCk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcInBhcmVudFxcXCIsIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogUGFyZW50IHNjcm9sbGJhclxcbiAgICAgICAgICovXFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuY29udGFpbmVyRWwucGFyZW50RWxlbWVudDtcXG4gICAgICAgICAgICB3aGlsZSAoZWxlbSkge1xcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50U2Nyb2xsYmFyID0gc2Nyb2xsYmFyTWFwLmdldChlbGVtKTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNjcm9sbGJhcikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFNjcm9sbGJhcjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnRFbGVtZW50O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcInNjcm9sbFRvcFxcXCIsIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogR2V0cyBvciBzZXRzIGBzY3JvbGxiYXIub2Zmc2V0LnlgXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldC55O1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHkpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuc2Nyb2xsTGVmdCwgeSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbGJhci5wcm90b3R5cGUsIFxcXCJzY3JvbGxMZWZ0XFxcIiwge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYHNjcm9sbGJhci5vZmZzZXQueGBcXG4gICAgICAgICAqL1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoeCkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgdGhpcy5zY3JvbGxUb3ApO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSk7XFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBzY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICogYW5kIHRoZSBjb250ZW50IHdyYXBwZXIgZWxlbWVudFxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImdldFNpemVcXFwiXSkodGhpcyk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBGb3JjZXMgc2Nyb2xsYmFyIHRvIHVwZGF0ZSBnZW9tZXRyeSBpbmZvbWF0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBCeSBkZWZhdWx0LCBzY3JvbGxiYXJzIGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2l0aCBgMTAwbXNgIGRlYm91bmNlIChvciBgTXV0YXRpb25PYnNlcnZlcmAgZmlyZXMpLlxcbiAgICAgKiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgdG8gZm9yY2UgYW4gdXBkYXRlIHdoZW4geW91IG1vZGlmaWVkIGNvbnRlbnRzXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE9iamVjdChfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInVwZGF0ZVxcXCJdKSh0aGlzKTtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uVXBkYXRlKCk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlldyBhcmVhXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0KF9nZW9tZXRyeV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiaXNWaXNpYmxlXFxcIl0pKHRoaXMsIGVsZW0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgc2Nyb2xsYmFyIHRvIHRoZSBnaXZlbiBvZmZzZXQgd2l0aG91dCBlYXNpbmdcXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IHRoaXMub2Zmc2V0Lng7IH1cXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHsgeSA9IHRoaXMub2Zmc2V0Lnk7IH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XFxuICAgICAgICB2YXIgc3RhdHVzID0gT2JqZWN0KF9zY3JvbGxpbmdfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcInNldFBvc2l0aW9uXFxcIl0pKHRoaXMsIHgsIHkpO1xcbiAgICAgICAgaWYgKCFzdGF0dXMgfHwgb3B0aW9ucy53aXRob3V0Q2FsbGJhY2tzKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICAgICAgZm4uY2FsbChfdGhpcywgc3RhdHVzKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2Nyb2xscyB0byBnaXZlbiBwb3NpdGlvbiB3aXRoIGVhc2luZyBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbiwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkgeyB4ID0gdGhpcy5vZmZzZXQueDsgfVxcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gdGhpcy5vZmZzZXQueTsgfVxcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAwOyB9XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxcbiAgICAgICAgT2JqZWN0KF9zY3JvbGxpbmdfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcInNjcm9sbFRvXFxcIl0pKHRoaXMsIHgsIHksIGR1cmF0aW9uLCBvcHRpb25zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFNjcm9sbHMgdGhlIHRhcmdldCBlbGVtZW50IGludG8gdmlzaWJsZSBhcmVhIG9mIHNjcm9sbGJhcixcXG4gICAgICogbGlrZXMgdGhlIERPTSBtZXRob2QgYGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKS5cXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cXG4gICAgICAgIE9iamVjdChfc2Nyb2xsaW5nX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJzY3JvbGxJbnRvVmlld1xcXCJdKSh0aGlzLCBlbGVtLCBvcHRpb25zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEFkZHMgc2Nyb2xsaW5nIGxpc3RlbmVyXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignW3Ntb290aC1zY3JvbGxiYXJdIHNjcm9sbGluZyBsaXN0ZW5lciBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmFkZChmbik7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGBzY3JvbGxiYXIuYWRkTGlzdGVuZXIoKWBcXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZm4pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQWRkcyBtb21lbnR1bSBhbmQgYXBwbHlzIGRlbHRhIHRyYW5zZm9ybWVycy5cXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuYWRkVHJhbnNmb3JtYWJsZU1vbWVudHVtID0gZnVuY3Rpb24gKHgsIHksIGZyb21FdmVudCwgY2FsbGJhY2spIHtcXG4gICAgICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCgpO1xcbiAgICAgICAgdmFyIGZpbmFsRGVsdGEgPSB0aGlzLl9wbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIHBsdWdpbikge1xcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW4udHJhbnNmb3JtRGVsdGEoZGVsdGEsIGZyb21FdmVudCkgfHwgZGVsdGE7XFxuICAgICAgICB9LCB7IHg6IHgsIHk6IHkgfSk7XFxuICAgICAgICB2YXIgd2lsbFNjcm9sbCA9ICF0aGlzLl9zaG91bGRQcm9wYWdhdGVNb21lbnR1bShmaW5hbERlbHRhLngsIGZpbmFsRGVsdGEueSk7XFxuICAgICAgICBpZiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIHRoaXMuYWRkTW9tZW50dW0oZmluYWxEZWx0YS54LCBmaW5hbERlbHRhLnkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB3aWxsU2Nyb2xsKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEluY3JlYXNlcyBzY3JvbGxiYXIncyBtb21lbnR1bVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5hZGRNb21lbnR1bSA9IGZ1bmN0aW9uICh4LCB5KSB7XFxuICAgICAgICB0aGlzLnNldE1vbWVudHVtKHRoaXMuX21vbWVudHVtLnggKyB4LCB0aGlzLl9tb21lbnR1bS55ICsgeSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHNjcm9sbGJhcidzIG1vbWVudHVtIHRvIGdpdmVuIHZhbHVlXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKHgsIHkpIHtcXG4gICAgICAgIGlmICh0aGlzLmxpbWl0LnggPT09IDApIHtcXG4gICAgICAgICAgICB4ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLmxpbWl0LnkgPT09IDApIHtcXG4gICAgICAgICAgICB5ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVuZGVyQnlQaXhlbHMpIHtcXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuX21vbWVudHVtLnggPSB4O1xcbiAgICAgICAgdGhpcy5fbW9tZW50dW0ueSA9IHk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgb3B0aW9ucyBmb3Igc3BlY2lmaWMgcGx1Z2luXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBwbHVnaW5OYW1lIE5hbWUgb2YgdGhlIHBsdWdpblxcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIEFuIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydGllcyB0aGF0IHlvdSB3YW50IHRvIHVwZGF0ZVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS51cGRhdGVQbHVnaW5PcHRpb25zID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUsIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgaWYgKHBsdWdpbi5uYW1lID09PSBwbHVnaW5OYW1lKSB7XFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGx1Z2luLm9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250YWluZXJFbCA9IF9hLmNvbnRhaW5lckVsLCBjb250ZW50RWwgPSBfYS5jb250ZW50RWw7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJjbGVhckV2ZW50c09uXFxcIl0pKHRoaXMpO1xcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmNsZWFyKCk7XFxuICAgICAgICB0aGlzLnNldE1vbWVudHVtKDAsIDApO1xcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVySUQpO1xcbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XFxuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2Nyb2xsYmFyTWFwLmRlbGV0ZSh0aGlzLmNvbnRhaW5lckVsKTtcXG4gICAgICAgIC8vIHJlc3RvcmUgY29udGVudHNcXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShjb250ZW50RWwuY2hpbGROb2Rlcyk7XFxuICAgICAgICB3aGlsZSAoY29udGFpbmVyRWwuZmlyc3RDaGlsZCkge1xcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmZpcnN0Q2hpbGQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgLy8gcmVzZXQgc2Nyb2xsIHBvc2l0aW9uXFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250YWluZXJFbCwge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XFxuICAgICAgICBjb250YWluZXJFbC5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xcbiAgICAgICAgLy8gaW52b2tlIHBsdWdpbi5vbkRlc3Ryb3lcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uRGVzdHJveSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLl9wbHVnaW5zLmxlbmd0aCA9IDA7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcXG4gICAgICAgIC8vIGluaXQgZXZldCBoYW5kbGVyc1xcbiAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50c19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xcbiAgICAgICAgICAgIF9ldmVudHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bcHJvcF0oX3RoaXMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvLyBpbnZva2UgYHBsdWdpbi5vbkluaXRgXFxuICAgICAgICB0aGlzLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xcbiAgICAgICAgICAgIHBsdWdpbi5vbkluaXQoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX3VwZGF0ZURlYm91bmNlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XFxuICAgIH07XFxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdG8gcHJvcGFnYXRlIG1vbm1lbnR1bSB0byBwYXJlbnQgc2Nyb2xsYmFyXFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgc2l0dWF0aW9ucyBhcmUgY29uc2lkZXJlZCBhcyBgdHJ1ZWA6XFxuICAgIC8vICAgICAgICAgMS4gY29udGludW91cyBzY3JvbGxpbmcgaXMgZW5hYmxlZCAoYXV0b21hdGljYWxseSBkaXNhYmxlZCB3aGVuIG92ZXJzY3JvbGwgaXMgZW5hYmxlZClcXG4gICAgLy8gICAgICAgICAyLiBzY3JvbGxiYXIgcmVhY2hlcyBvbmUgc2lkZSBhbmQgaXMgbm90IGFib3V0IHRvIHNjcm9sbCBvbiB0aGUgb3RoZXIgZGlyZWN0aW9uXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX3Nob3VsZFByb3BhZ2F0ZU1vbWVudHVtID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XFxuICAgICAgICBpZiAoZGVsdGFYID09PSB2b2lkIDApIHsgZGVsdGFYID0gMDsgfVxcbiAgICAgICAgaWYgKGRlbHRhWSA9PT0gdm9pZCAwKSB7IGRlbHRhWSA9IDA7IH1cXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBvZmZzZXQgPSBfYS5vZmZzZXQsIGxpbWl0ID0gX2EubGltaXQ7XFxuICAgICAgICBpZiAoIW9wdGlvbnMuY29udGludW91c1Njcm9sbGluZylcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUgd2hlbiBzY3JvbGxiYXIgaXMgXFxcInVuc2Nyb2xsYWJsZVxcXCIsIHNlZSAjMTA2XFxuICAgICAgICBpZiAobGltaXQueCA9PT0gMCAmJiBsaW1pdC55ID09PSAwKSB7XFxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVib3VuY2VkKCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGVzdFggPSBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkoZGVsdGFYICsgb2Zmc2V0LngsIDAsIGxpbWl0LngpO1xcbiAgICAgICAgdmFyIGRlc3RZID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKGRlbHRhWSArIG9mZnNldC55LCAwLCBsaW1pdC55KTtcXG4gICAgICAgIHZhciByZXMgPSB0cnVlO1xcbiAgICAgICAgLy8gb2Zmc2V0cyBhcmUgbm90IGFib3V0IHRvIGNoYW5nZVxcbiAgICAgICAgLy8gYCY9YCBvcGVyYXRvciBpcyBub3QgYWxsb3dlZCBmb3IgYm9vbGVhbiB0eXBlc1xcbiAgICAgICAgcmVzID0gcmVzICYmIChkZXN0WCA9PT0gb2Zmc2V0LngpO1xcbiAgICAgICAgcmVzID0gcmVzICYmIChkZXN0WSA9PT0gb2Zmc2V0LnkpO1xcbiAgICAgICAgLy8gY3VycmVudCBvZmZzZXRzIGFyZSBvbiB0aGUgZWRnZVxcbiAgICAgICAgcmVzID0gcmVzICYmIChvZmZzZXQueCA9PT0gbGltaXQueCB8fCBvZmZzZXQueCA9PT0gMCB8fCBvZmZzZXQueSA9PT0gbGltaXQueSB8fCBvZmZzZXQueSA9PT0gMCk7XFxuICAgICAgICByZXR1cm4gcmVzO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX21vbWVudHVtID0gdGhpcy5fbW9tZW50dW07XFxuICAgICAgICBpZiAoX21vbWVudHVtLnggfHwgX21vbWVudHVtLnkpIHtcXG4gICAgICAgICAgICB2YXIgbmV4dFggPSB0aGlzLl9uZXh0VGljaygneCcpO1xcbiAgICAgICAgICAgIHZhciBuZXh0WSA9IHRoaXMuX25leHRUaWNrKCd5Jyk7XFxuICAgICAgICAgICAgX21vbWVudHVtLnggPSBuZXh0WC5tb21lbnR1bTtcXG4gICAgICAgICAgICBfbW9tZW50dW0ueSA9IG5leHRZLm1vbWVudHVtO1xcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24obmV4dFgucG9zaXRpb24sIG5leHRZLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciByZW1haW4gPSBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRoaXMuX21vbWVudHVtKTtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uUmVuZGVyKHJlbWFpbik7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuX3JlbmRlcklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpKTtcXG4gICAgfTtcXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5fbmV4dFRpY2sgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBfbW9tZW50dW0gPSBfYS5fbW9tZW50dW07XFxuICAgICAgICB2YXIgY3VycmVudCA9IG9mZnNldFtkaXJlY3Rpb25dO1xcbiAgICAgICAgdmFyIHJlbWFpbiA9IF9tb21lbnR1bVtkaXJlY3Rpb25dO1xcbiAgICAgICAgaWYgKE1hdGguYWJzKHJlbWFpbikgPD0gMC4xKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgbW9tZW50dW06IDAsXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50ICsgcmVtYWluLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbmV4dE1vbWVudHVtID0gcmVtYWluICogKDEgLSBvcHRpb25zLmRhbXBpbmcpO1xcbiAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyQnlQaXhlbHMpIHtcXG4gICAgICAgICAgICBuZXh0TW9tZW50dW0gfD0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbW9tZW50dW06IG5leHRNb21lbnR1bSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogY3VycmVudCArIHJlbWFpbiAtIG5leHRNb21lbnR1bSxcXG4gICAgICAgIH07XFxuICAgIH07XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIE9iamVjdChfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVib3VuY2VcXFwiXSkoMTAwLCB7IGxlYWRpbmc6IHRydWUgfSlcXG4gICAgXSwgU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcIl91cGRhdGVEZWJvdW5jZWRcXFwiLCBudWxsKTtcXG4gICAgcmV0dXJuIFNjcm9sbGJhcjtcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbGJhci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBzZXRQb3NpdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEludG9WaWV3ICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldC1wb3NpdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2V0LXBvc2l0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzZXRQb3NpdGlvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldF9wb3NpdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzZXRQb3NpdGlvblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Njcm9sbF90b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3JvbGwtdG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC10by5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9zY3JvbGxfdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2Nyb2xsVG9cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JvbGxfaW50b192aWV3X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Njcm9sbC1pbnRvLXZpZXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbEludG9WaWV3XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2Nyb2xsX2ludG9fdmlld19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxJbnRvVmlld1xcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLWludG8tdmlldy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3Njcm9sbGluZy9zY3JvbGwtaW50by12aWV3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNjcm9sbEludG9WaWV3ICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1Njcm9sbEludG9WaWV3SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbEludG9WaWV3XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxJbnRvVmlldzsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHNjcm9sbGJhciwgZWxlbSwgX2EpIHtcXG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuYWxpZ25Ub1RvcCwgYWxpZ25Ub1RvcCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2Iub25seVNjcm9sbElmTmVlZGVkLCBvbmx5U2Nyb2xsSWZOZWVkZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5vZmZzZXRUb3AsIG9mZnNldFRvcCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gX2Iub2Zmc2V0TGVmdCwgb2Zmc2V0TGVmdCA9IF9mID09PSB2b2lkIDAgPyAwIDogX2YsIF9nID0gX2Iub2Zmc2V0Qm90dG9tLCBvZmZzZXRCb3R0b20gPSBfZyA9PT0gdm9pZCAwID8gMCA6IF9nO1xcbiAgICB2YXIgY29udGFpbmVyRWwgPSBzY3JvbGxiYXIuY29udGFpbmVyRWwsIGJvdW5kaW5nID0gc2Nyb2xsYmFyLmJvdW5kaW5nLCBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0LCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdDtcXG4gICAgaWYgKCFlbGVtIHx8ICFjb250YWluZXJFbC5jb250YWlucyhlbGVtKSlcXG4gICAgICAgIHJldHVybjtcXG4gICAgdmFyIHRhcmdldEJvdW5kaW5nID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgaWYgKG9ubHlTY3JvbGxJZk5lZWRlZCAmJiBzY3JvbGxiYXIuaXNWaXNpYmxlKGVsZW0pKVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICB2YXIgZGVsdGEgPSBhbGlnblRvVG9wID8gdGFyZ2V0Qm91bmRpbmcudG9wIC0gYm91bmRpbmcudG9wIC0gb2Zmc2V0VG9wIDogdGFyZ2V0Qm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgb2Zmc2V0Qm90dG9tO1xcbiAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0odGFyZ2V0Qm91bmRpbmcubGVmdCAtIGJvdW5kaW5nLmxlZnQgLSBvZmZzZXRMZWZ0LCBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZGVsdGEsIC1vZmZzZXQueSwgbGltaXQueSAtIG9mZnNldC55KSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC1pbnRvLXZpZXcuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogc2Nyb2xsVG8gKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nU2Nyb2xsVG9Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbFRvOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuXFxudmFyIGFuaW1hdGlvbklEU3RvcmFnZSA9IG5ldyBXZWFrTWFwKCk7XFxuZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsYmFyLCB4LCB5LCBkdXJhdGlvbiwgX2EpIHtcXG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAwOyB9XFxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmVhc2luZywgZWFzaW5nID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFYXNpbmcgOiBfYywgY2FsbGJhY2sgPSBfYi5jYWxsYmFjaztcXG4gICAgdmFyIG9wdGlvbnMgPSBzY3JvbGxiYXIub3B0aW9ucywgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldCwgbGltaXQgPSBzY3JvbGxiYXIubGltaXQ7XFxuICAgIGlmIChvcHRpb25zLnJlbmRlckJ5UGl4ZWxzKSB7XFxuICAgICAgICAvLyBlbnN1cmUgcmVzb2x2ZWQgd2l0aCBpbnRlZ2VyXFxuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xcbiAgICB9XFxuICAgIHZhciBzdGFydFggPSBvZmZzZXQueDtcXG4gICAgdmFyIHN0YXJ0WSA9IG9mZnNldC55O1xcbiAgICB2YXIgZGlzWCA9IGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh4LCAwLCBsaW1pdC54KSAtIHN0YXJ0WDtcXG4gICAgdmFyIGRpc1kgPSBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoeSwgMCwgbGltaXQueSkgLSBzdGFydFk7XFxuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XFxuICAgIGZ1bmN0aW9uIHNjcm9sbCgpIHtcXG4gICAgICAgIHZhciBlbGFwc2UgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBkdXJhdGlvbiA/IGVhc2luZyhNYXRoLm1pbihlbGFwc2UgLyBkdXJhdGlvbiwgMSkpIDogMTtcXG4gICAgICAgIHNjcm9sbGJhci5zZXRQb3NpdGlvbihzdGFydFggKyBkaXNYICogcHJvZ3Jlc3MsIHN0YXJ0WSArIGRpc1kgKiBwcm9ncmVzcyk7XFxuICAgICAgICBpZiAoZWxhcHNlID49IGR1cmF0aW9uKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjcm9sbGJhcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbCk7XFxuICAgICAgICAgICAgYW5pbWF0aW9uSURTdG9yYWdlLnNldChzY3JvbGxiYXIsIGFuaW1hdGlvbklEKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRFN0b3JhZ2UuZ2V0KHNjcm9sbGJhcikpO1xcbiAgICBzY3JvbGwoKTtcXG59XFxuLyoqXFxuICogZWFzZU91dEN1YmljXFxuICovXFxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh0KSB7XFxuICAgIHJldHVybiBNYXRoLnBvdygodCAtIDEpLCAzKSArIDE7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC10by5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldFBvc2l0aW9uICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1NldFBvc2l0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNldFBvc2l0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRQb3NpdGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBzZXRQb3NpdGlvbihzY3JvbGxiYXIsIHgsIHkpIHtcXG4gICAgdmFyIG9wdGlvbnMgPSBzY3JvbGxiYXIub3B0aW9ucywgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldCwgbGltaXQgPSBzY3JvbGxiYXIubGltaXQsIHRyYWNrID0gc2Nyb2xsYmFyLnRyYWNrLCBjb250ZW50RWwgPSBzY3JvbGxiYXIuY29udGVudEVsO1xcbiAgICBpZiAob3B0aW9ucy5yZW5kZXJCeVBpeGVscykge1xcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XFxuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcXG4gICAgfVxcbiAgICB4ID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKHgsIDAsIGxpbWl0LngpO1xcbiAgICB5ID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKHksIDAsIGxpbWl0LnkpO1xcbiAgICAvLyBwb3NpdGlvbiBjaGFuZ2VkIC0+IHNob3cgdHJhY2sgZm9yIDMwMG1zXFxuICAgIGlmICh4ICE9PSBvZmZzZXQueClcXG4gICAgICAgIHRyYWNrLnhBeGlzLnNob3coKTtcXG4gICAgaWYgKHkgIT09IG9mZnNldC55KVxcbiAgICAgICAgdHJhY2sueUF4aXMuc2hvdygpO1xcbiAgICBpZiAoIW9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgdHJhY2suYXV0b0hpZGVPbklkbGUoKTtcXG4gICAgfVxcbiAgICBpZiAoeCA9PT0gb2Zmc2V0LnggJiYgeSA9PT0gb2Zmc2V0LnkpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIG9mZnNldC54ID0geDtcXG4gICAgb2Zmc2V0LnkgPSB5O1xcbiAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250ZW50RWwsIHtcXG4gICAgICAgICctdHJhbnNmb3JtJzogXFxcInRyYW5zbGF0ZTNkKFxcXCIgKyAteCArIFxcXCJweCwgXFxcIiArIC15ICsgXFxcInB4LCAwKVxcXCIsXFxuICAgIH0pO1xcbiAgICB0cmFjay51cGRhdGUoKTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIG9mZnNldDogT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fYXNzaWduXFxcIl0pKHt9LCBvZmZzZXQpLFxcbiAgICAgICAgbGltaXQ6IE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgbGltaXQpLFxcbiAgICB9O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtcG9zaXRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3N0eWxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc3R5bGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogYXR0YWNoU3R5bGUsIGRldGFjaFN0eWxlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclN0eWxlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImF0dGFjaFN0eWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdHRhY2hTdHlsZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGV0YWNoU3R5bGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRldGFjaFN0eWxlOyB9KTtcXG52YXIgVFJBQ0tfQkcgPSAncmdiYSgyMjIsIDIyMiwgMjIyLCAuNzUpJztcXG52YXIgVEhVTUJfQkcgPSAncmdiYSgwLCAwLCAwLCAuNSknO1xcbi8vIHNldHMgY29udGVudCdzIGRpc3BsYXkgdHlwZSB0byBgZmxvdy1yb290YCB0byBzdXBwcmVzcyBtYXJnaW4gY29sbGFwc2luZ1xcbnZhciBTQ1JPTExCQVJfU1RZTEUgPSBcXFwiXFxcXG5bZGF0YS1zY3JvbGxiYXJdIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbn1cXFxcblxcXFxuLnNjcm9sbC1jb250ZW50IHtcXFxcbiAgZGlzcGxheTogZmxvdy1yb290O1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXFxcbn1cXFxcblxcXFxuLnNjcm9sbGJhci10cmFjayB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgb3BhY2l0eTogMDtcXFxcbiAgei1pbmRleDogMTtcXFxcbiAgYmFja2dyb3VuZDogXFxcIiArIFRSQUNLX0JHICsgXFxcIjtcXFxcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgMC41cyBlYXNlLW91dDtcXFxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgMC41cyBlYXNlLW91dDtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdHJhY2suc2hvdyxcXFxcbi5zY3JvbGxiYXItdHJhY2s6aG92ZXIge1xcXFxuICBvcGFjaXR5OiAxO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb24tZGVsYXk6IDBzO1xcXFxuICAgICAgICAgIHRyYW5zaXRpb24tZGVsYXk6IDBzO1xcXFxufVxcXFxuXFxcXG4uc2Nyb2xsYmFyLXRyYWNrLXgge1xcXFxuICBib3R0b206IDA7XFxcXG4gIGxlZnQ6IDA7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICBoZWlnaHQ6IDhweDtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdHJhY2steSB7XFxcXG4gIHRvcDogMDtcXFxcbiAgcmlnaHQ6IDA7XFxcXG4gIHdpZHRoOiA4cHg7XFxcXG4gIGhlaWdodDogMTAwJTtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdGh1bWIge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHRvcDogMDtcXFxcbiAgbGVmdDogMDtcXFxcbiAgd2lkdGg6IDhweDtcXFxcbiAgaGVpZ2h0OiA4cHg7XFxcXG4gIGJhY2tncm91bmQ6IFxcXCIgKyBUSFVNQl9CRyArIFxcXCI7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXFxcbn1cXFxcblxcXCI7XFxudmFyIFNUWUxFX0lEID0gJ3Ntb290aC1zY3JvbGxiYXItc3R5bGUnO1xcbnZhciBpc1N0eWxlQXR0YWNoZWQgPSBmYWxzZTtcXG5mdW5jdGlvbiBhdHRhY2hTdHlsZSgpIHtcXG4gICAgaWYgKGlzU3R5bGVBdHRhY2hlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgc3R5bGVFbC5pZCA9IFNUWUxFX0lEO1xcbiAgICBzdHlsZUVsLnRleHRDb250ZW50ID0gU0NST0xMQkFSX1NUWUxFO1xcbiAgICBpZiAoZG9jdW1lbnQuaGVhZCkge1xcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcXG4gICAgfVxcbiAgICBpc1N0eWxlQXR0YWNoZWQgPSB0cnVlO1xcbn1cXG5mdW5jdGlvbiBkZXRhY2hTdHlsZSgpIHtcXG4gICAgaWYgKCFpc1N0eWxlQXR0YWNoZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNUWUxFX0lEKTtcXG4gICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLnBhcmVudE5vZGUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdHlsZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbCk7XFxuICAgIGlzU3R5bGVBdHRhY2hlZCA9IGZhbHNlO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zdHlsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9kaXJlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRyYWNrRGlyZWN0aW9uICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclRyYWNrRGlyZWN0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrRGlyZWN0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFja0RpcmVjdGlvbjsgfSk7XFxudmFyIFRyYWNrRGlyZWN0aW9uO1xcbihmdW5jdGlvbiAoVHJhY2tEaXJlY3Rpb24pIHtcXG4gICAgVHJhY2tEaXJlY3Rpb25bXFxcIlhcXFwiXSA9IFxcXCJ4XFxcIjtcXG4gICAgVHJhY2tEaXJlY3Rpb25bXFxcIllcXFwiXSA9IFxcXCJ5XFxcIjtcXG59KShUcmFja0RpcmVjdGlvbiB8fCAoVHJhY2tEaXJlY3Rpb24gPSB7fSkpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9kaXJlY3Rpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRyYWNrQ29udHJvbGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrQ29udHJvbGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhY2tDb250cm9sbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlyZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlY29yYXRvcnMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG52YXIgVHJhY2tDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBUcmFja0NvbnRyb2xsZXIoX3Njcm9sbGJhcikge1xcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyID0gX3Njcm9sbGJhcjtcXG4gICAgICAgIHZhciB0aHVtYk1pblNpemUgPSBfc2Nyb2xsYmFyLm9wdGlvbnMudGh1bWJNaW5TaXplO1xcbiAgICAgICAgdGhpcy54QXhpcyA9IG5ldyBfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiU2Nyb2xsYmFyVHJhY2tcXFwiXShfZGlyZWN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlRyYWNrRGlyZWN0aW9uXFxcIl0uWCwgdGh1bWJNaW5TaXplKTtcXG4gICAgICAgIHRoaXMueUF4aXMgPSBuZXcgX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlNjcm9sbGJhclRyYWNrXFxcIl0oX2RpcmVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJUcmFja0RpcmVjdGlvblxcXCJdLlksIHRodW1iTWluU2l6ZSk7XFxuICAgICAgICB0aGlzLnhBeGlzLmF0dGFjaFRvKF9zY3JvbGxiYXIuY29udGFpbmVyRWwpO1xcbiAgICAgICAgdGhpcy55QXhpcy5hdHRhY2hUbyhfc2Nyb2xsYmFyLmNvbnRhaW5lckVsKTtcXG4gICAgICAgIGlmIChfc2Nyb2xsYmFyLm9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgICAgIHRoaXMueEF4aXMuc2hvdygpO1xcbiAgICAgICAgICAgIHRoaXMueUF4aXMuc2hvdygpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGVzIHRyYWNrIGFwcGVhcmFuY2VcXG4gICAgICovXFxuICAgIFRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fc2Nyb2xsYmFyLCBzaXplID0gX2Euc2l6ZSwgb2Zmc2V0ID0gX2Eub2Zmc2V0O1xcbiAgICAgICAgdGhpcy54QXhpcy51cGRhdGUob2Zmc2V0LngsIHNpemUuY29udGFpbmVyLndpZHRoLCBzaXplLmNvbnRlbnQud2lkdGgpO1xcbiAgICAgICAgdGhpcy55QXhpcy51cGRhdGUob2Zmc2V0LnksIHNpemUuY29udGFpbmVyLmhlaWdodCwgc2l6ZS5jb250ZW50LmhlaWdodCk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGhpZGUgdHJhY2tzIHdoZW4gc2Nyb2xsYmFyIGlzIGluIGlkbGUgc3RhdGVcXG4gICAgICovXFxuICAgIFRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuYXV0b0hpZGVPbklkbGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsYmFyLm9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMueEF4aXMuaGlkZSgpO1xcbiAgICAgICAgdGhpcy55QXhpcy5oaWRlKCk7XFxuICAgIH07XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIE9iamVjdChfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVib3VuY2VcXFwiXSkoMzAwKVxcbiAgICBdLCBUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcXFwiYXV0b0hpZGVPbklkbGVcXFwiLCBudWxsKTtcXG4gICAgcmV0dXJuIFRyYWNrQ29udHJvbGxlcjtcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdGh1bWIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90aHVtYi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBTY3JvbGxiYXJUaHVtYiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja1RodW1iSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclRodW1iXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTY3JvbGxiYXJUaHVtYjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlyZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG52YXIgU2Nyb2xsYmFyVGh1bWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFNjcm9sbGJhclRodW1iKF9kaXJlY3Rpb24sIF9taW5TaXplKSB7XFxuICAgICAgICBpZiAoX21pblNpemUgPT09IHZvaWQgMCkgeyBfbWluU2l6ZSA9IDA7IH1cXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XFxuICAgICAgICB0aGlzLl9taW5TaXplID0gX21pblNpemU7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFRodW1iIGVsZW1lbnRcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIERpc3BsYXkgc2l6ZSBvZiB0aGUgdGh1bWJcXG4gICAgICAgICAqIHdpbGwgYWx3YXlzIGJlIGdyZWF0ZXIgdGhhbiBgc2Nyb2xsYmFyLm9wdGlvbnMudGh1bWJNaW5TaXplYFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gMDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogQWN0dWFsIHNpemUgb2YgdGhlIHRodW1iXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMucmVhbFNpemUgPSAwO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBUaHVtYiBvZmZzZXQgdG8gdGhlIHRvcFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXFxcInNjcm9sbGJhci10aHVtYiBzY3JvbGxiYXItdGh1bWItXFxcIiArIF9kaXJlY3Rpb247XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaCB0byB0cmFjayBlbGVtZW50XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB0cmFja0VsIFRyYWNrIGVsZW1lbnRcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uICh0cmFja0VsKSB7XFxuICAgICAgICB0cmFja0VsLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsT2Zmc2V0LCBjb250YWluZXJTaXplLCBwYWdlU2l6ZSkge1xcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRodW1iIHNpemVcXG4gICAgICAgIC8vIHBhZ2VTaXplID4gY29udGFpbmVyU2l6ZSAtPiBzY3JvbGxhYmxlXFxuICAgICAgICB0aGlzLnJlYWxTaXplID0gTWF0aC5taW4oY29udGFpbmVyU2l6ZSAvIHBhZ2VTaXplLCAxKSAqIGNvbnRhaW5lclNpemU7XFxuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gTWF0aC5tYXgodGhpcy5yZWFsU2l6ZSwgdGhpcy5fbWluU2l6ZSk7XFxuICAgICAgICAvLyBjYWxjdWxhdGUgdGh1bWIgb2Zmc2V0XFxuICAgICAgICB0aGlzLm9mZnNldCA9IHNjcm9sbE9mZnNldCAvIHBhZ2VTaXplICogKGNvbnRhaW5lclNpemUgKyAodGhpcy5yZWFsU2l6ZSAtIHRoaXMuZGlzcGxheVNpemUpKTtcXG4gICAgICAgIE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInNldFN0eWxlXFxcIl0pKHRoaXMuZWxlbWVudCwgdGhpcy5fZ2V0U3R5bGUoKSk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS5fZ2V0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2RpcmVjdGlvbikge1xcbiAgICAgICAgICAgIGNhc2UgX2RpcmVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJUcmFja0RpcmVjdGlvblxcXCJdLlg6XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5kaXNwbGF5U2l6ZSArIFxcXCJweFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAnLXRyYW5zZm9ybSc6IFxcXCJ0cmFuc2xhdGUzZChcXFwiICsgdGhpcy5vZmZzZXQgKyBcXFwicHgsIDAsIDApXFxcIixcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBjYXNlIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiVHJhY2tEaXJlY3Rpb25cXFwiXS5ZOlxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmRpc3BsYXlTaXplICsgXFxcInB4XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICctdHJhbnNmb3JtJzogXFxcInRyYW5zbGF0ZTNkKDAsIFxcXCIgKyB0aGlzLm9mZnNldCArIFxcXCJweCwgMClcXFwiLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICByZXR1cm4gU2Nyb2xsYmFyVGh1bWI7XFxufSgpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHVtYi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90aHVtYi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdHJhY2suanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogU2Nyb2xsYmFyVHJhY2sgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tUcmFja0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxiYXJUcmFja1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyVHJhY2s7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGh1bWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGh1bWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdGh1bWIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxuXFxudmFyIFNjcm9sbGJhclRyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXJUcmFjayhkaXJlY3Rpb24sIHRodW1iTWluU2l6ZSkge1xcbiAgICAgICAgaWYgKHRodW1iTWluU2l6ZSA9PT0gdm9pZCAwKSB7IHRodW1iTWluU2l6ZSA9IDA7IH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVHJhY2sgZWxlbWVudFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcXFwic2Nyb2xsYmFyLXRyYWNrIHNjcm9sbGJhci10cmFjay1cXFwiICsgZGlyZWN0aW9uO1xcbiAgICAgICAgdGhpcy50aHVtYiA9IG5ldyBfdGh1bWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiU2Nyb2xsYmFyVGh1bWJcXFwiXShkaXJlY3Rpb24sIHRodW1iTWluU2l6ZSk7XFxuICAgICAgICB0aGlzLnRodW1iLmF0dGFjaFRvKHRoaXMuZWxlbWVudCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaCB0byBzY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHNjcm9sbGJhckNvbnRhaW5lciBTY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRyYWNrLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJDb250YWluZXIpIHtcXG4gICAgICAgIHNjcm9sbGJhckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2hvdyB0cmFjayBpbW1lZGlhdGVseVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyVHJhY2sucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEhpZGUgdHJhY2sgaW1tZWRpYXRlbHlcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRyYWNrLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcXG4gICAgfTtcXG4gICAgU2Nyb2xsYmFyVHJhY2sucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzY3JvbGxPZmZzZXQsIGNvbnRhaW5lclNpemUsIHBhZ2VTaXplKSB7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJzZXRTdHlsZVxcXCJdKSh0aGlzLmVsZW1lbnQsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBwYWdlU2l6ZSA8PSBjb250YWluZXJTaXplID8gJ25vbmUnIDogJ2Jsb2NrJyxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy50aHVtYi51cGRhdGUoc2Nyb2xsT2Zmc2V0LCBjb250YWluZXJTaXplLCBwYWdlU2l6ZSk7XFxuICAgIH07XFxuICAgIHJldHVybiBTY3JvbGxiYXJUcmFjaztcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZXZlbnQtaHViLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2V2ZW50LWh1Yi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZXZlbnRTY29wZSwgY2xlYXJFdmVudHNPbiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0V2ZW50SHViSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50U2NvcGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV2ZW50U2NvcGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsZWFyRXZlbnRzT25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsZWFyRXZlbnRzT247IH0pO1xcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucztcXG52YXIgZXZlbnRNYXAgPSBuZXcgV2Vha01hcCgpO1xcbmZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XFxuICAgIGlmIChldmVudExpc3RlbmVyT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lck9wdGlvbnM7XFxuICAgIH1cXG4gICAgdmFyIHN1cHBvcnRQYXNzaXZlRXZlbnQgPSBmYWxzZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBzdXBwb3J0UGFzc2l2ZUV2ZW50ID0gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBub29wLCBvcHRpb25zKTtcXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG5vb3AsIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlKSB7IH1cXG4gICAgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0UGFzc2l2ZUV2ZW50ID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIHJldHVybiBldmVudExpc3RlbmVyT3B0aW9ucztcXG59XFxuZnVuY3Rpb24gZXZlbnRTY29wZShzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGNvbmZpZ3MgPSBldmVudE1hcC5nZXQoc2Nyb2xsYmFyKSB8fCBbXTtcXG4gICAgZXZlbnRNYXAuc2V0KHNjcm9sbGJhciwgY29uZmlncyk7XFxuICAgIHJldHVybiBmdW5jdGlvbiBhZGRFdmVudChlbGVtLCBldmVudHMsIGZuKSB7XFxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuICAgICAgICAgICAgLy8gaWdub3JlIGRlZmF1bHQgcHJldmVudGVkIGV2ZW50c1xcbiAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm4oZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXZlbnRzLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XFxuICAgICAgICAgICAgY29uZmlncy5wdXNoKHsgZWxlbTogZWxlbSwgZXZlbnROYW1lOiBldmVudE5hbWUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XFxuICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZ2V0T3B0aW9ucygpKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbn1cXG5mdW5jdGlvbiBjbGVhckV2ZW50c09uKHNjcm9sbGJhcikge1xcbiAgICB2YXIgY29uZmlncyA9IGV2ZW50TWFwLmdldChzY3JvbGxiYXIpO1xcbiAgICBpZiAoIWNvbmZpZ3MpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XFxuICAgICAgICB2YXIgZWxlbSA9IF9hLmVsZW0sIGV2ZW50TmFtZSA9IF9hLmV2ZW50TmFtZSwgaGFuZGxlciA9IF9hLmhhbmRsZXI7XFxuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBnZXRPcHRpb25zKCkpO1xcbiAgICB9KTtcXG4gICAgZXZlbnRNYXAuZGVsZXRlKHNjcm9sbGJhcik7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LWh1Yi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9ldmVudC1odWIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0UG9pbnRlckRhdGEgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNHZXRQb2ludGVyRGF0YUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnZXRQb2ludGVyRGF0YVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UG9pbnRlckRhdGE7IH0pO1xcbi8qKlxcbiAqIEdldCBwb2ludGVyL3RvdWNoIGRhdGFcXG4gKi9cXG5mdW5jdGlvbiBnZXRQb2ludGVyRGF0YShldnQpIHtcXG4gICAgLy8gaWYgaXMgdG91Y2ggZXZlbnQsIHJldHVybiBsYXN0IGl0ZW0gaW4gdG91Y2hMaXN0XFxuICAgIC8vIGVsc2UgcmV0dXJuIG9yaWdpbmFsIGV2ZW50XFxuICAgIHJldHVybiBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzW2V2dC50b3VjaGVzLmxlbmd0aCAtIDFdIDogZXZ0O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcG9pbnRlci1kYXRhLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb2ludGVyLWRhdGEuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9zaXRpb24uanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvc2l0aW9uLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBnZXRQb3NpdGlvbiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0dldFBvc2l0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImdldFBvc2l0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRQb3NpdGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9pbnRlcl9kYXRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldC1wb2ludGVyLWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvaW50ZXItZGF0YS5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEdldCBwb2ludGVyL2ZpbmdlciBwb3NpdGlvblxcbiAqL1xcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGV2dCkge1xcbiAgICB2YXIgZGF0YSA9IE9iamVjdChfZ2V0X3BvaW50ZXJfZGF0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJnZXRQb2ludGVyRGF0YVxcXCJdKShldnQpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgeDogZGF0YS5jbGllbnRYLFxcbiAgICAgICAgeTogZGF0YS5jbGllbnRZLFxcbiAgICB9O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcG9zaXRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvc2l0aW9uLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBldmVudFNjb3BlLCBjbGVhckV2ZW50c09uLCBnZXRQb2ludGVyRGF0YSwgZ2V0UG9zaXRpb24sIGlzT25lT2YsIHNldFN0eWxlLCBUcmFja2VyLCBUb3VjaFJlY29yZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRfaHViX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50LWh1YiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9ldmVudC1odWIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50U2NvcGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudF9odWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZXZlbnRTY29wZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsZWFyRXZlbnRzT25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudF9odWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiY2xlYXJFdmVudHNPblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldF9wb2ludGVyX2RhdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvaW50ZXItZGF0YSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnZXRQb2ludGVyRGF0YVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2dldF9wb2ludGVyX2RhdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZ2V0UG9pbnRlckRhdGFcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvc2l0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb3NpdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0UG9zaXRpb25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZ2V0UG9zaXRpb25cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19vbmVfb2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb25lLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNPbmVPZlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2lzX29uZV9vZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc09uZU9mXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0X3N0eWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldC1zdHlsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNldFN0eWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0X3N0eWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcInNldFN0eWxlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdG91Y2hfcmVjb3JkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvdWNoLXJlY29yZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90b3VjaF9yZWNvcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVHJhY2tlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvdWNoUmVjb3JkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdG91Y2hfcmVjb3JkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRvdWNoUmVjb3JkXFxcIl07IH0pO1xcblxcblxcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaXMtb25lLW9mLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogaXNPbmVPZiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0lzT25lT2ZKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNPbmVPZlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPbmVPZjsgfSk7XFxuLyoqXFxuICogQ2hlY2sgaWYgYGFgIGlzIG9uZSBvZiBgWy4uLmJdYFxcbiAqL1xcbmZ1bmN0aW9uIGlzT25lT2YoYSwgYikge1xcbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSBbXTsgfVxcbiAgICByZXR1cm4gYi5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBhID09PSB2OyB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtb25lLW9mLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL3NldC1zdHlsZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldFN0eWxlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclV0aWxzU2V0U3R5bGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2V0U3R5bGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldFN0eWxlOyB9KTtcXG52YXIgVkVORE9SX1BSRUZJWCA9IFtcXG4gICAgJ3dlYmtpdCcsXFxuICAgICdtb3onLFxcbiAgICAnbXMnLFxcbiAgICAnbycsXFxuXTtcXG52YXIgUkUgPSBuZXcgUmVnRXhwKFxcXCJeLSg/ISg/OlxcXCIgKyBWRU5ET1JfUFJFRklYLmpvaW4oJ3wnKSArIFxcXCIpLSlcXFwiKTtcXG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlcykge1xcbiAgICB2YXIgcmVzID0ge307XFxuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xcbiAgICAgICAgaWYgKCFSRS50ZXN0KHByb3ApKSB7XFxuICAgICAgICAgICAgcmVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB2YWwgPSBzdHlsZXNbcHJvcF07XFxuICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKC9eLS8sICcnKTtcXG4gICAgICAgIHJlc1twcm9wXSA9IHZhbDtcXG4gICAgICAgIFZFTkRPUl9QUkVGSVguZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XFxuICAgICAgICAgICAgcmVzW1xcXCItXFxcIiArIHByZWZpeCArIFxcXCItXFxcIiArIHByb3BdID0gdmFsO1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzO1xcbn1cXG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtLCBzdHlsZXMpIHtcXG4gICAgc3R5bGVzID0gYXV0b1ByZWZpeChzdHlsZXMpO1xcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgIHZhciBjc3NQcm9wID0gcHJvcC5yZXBsYWNlKC9eLS8sICcnKS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xcbiAgICAgICAgZWxlbS5zdHlsZVtjc3NQcm9wXSA9IHN0eWxlc1twcm9wXTtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldC1zdHlsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvdG91Y2gtcmVjb3JkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBUcmFja2VyLCBUb3VjaFJlY29yZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc1RvdWNoUmVjb3JkSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYWNrZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvdWNoUmVjb3JkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUb3VjaFJlY29yZDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvc2l0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb3NpdGlvbi5qc1xcXCIpO1xcblxcblxcbnZhciBUcmFja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBUcmFja2VyKHRvdWNoKSB7XFxuICAgICAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIHRoaXMuZGVsdGEgPSB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XFxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IE9iamVjdChfZ2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKHRvdWNoKTtcXG4gICAgfVxcbiAgICBUcmFja2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodG91Y2gpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHZlbG9jaXR5ID0gX2EudmVsb2NpdHksIHVwZGF0ZVRpbWUgPSBfYS51cGRhdGVUaW1lLCBsYXN0UG9zaXRpb24gPSBfYS5sYXN0UG9zaXRpb247XFxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IE9iamVjdChfZ2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKHRvdWNoKTtcXG4gICAgICAgIHZhciBkZWx0YSA9IHtcXG4gICAgICAgICAgICB4OiAtKHBvc2l0aW9uLnggLSBsYXN0UG9zaXRpb24ueCksXFxuICAgICAgICAgICAgeTogLShwb3NpdGlvbi55IC0gbGFzdFBvc2l0aW9uLnkpLFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IChub3cgLSB1cGRhdGVUaW1lKSB8fCAxNi43O1xcbiAgICAgICAgdmFyIHZ4ID0gZGVsdGEueCAvIGR1cmF0aW9uICogMTYuNztcXG4gICAgICAgIHZhciB2eSA9IGRlbHRhLnkgLyBkdXJhdGlvbiAqIDE2Ljc7XFxuICAgICAgICB2ZWxvY2l0eS54ID0gdnggKiB0aGlzLnZlbG9jaXR5TXVsdGlwbGllcjtcXG4gICAgICAgIHZlbG9jaXR5LnkgPSB2eSAqIHRoaXMudmVsb2NpdHlNdWx0aXBsaWVyO1xcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gbm93O1xcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgfTtcXG4gICAgcmV0dXJuIFRyYWNrZXI7XFxufSgpKTtcXG5cXG52YXIgVG91Y2hSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFRvdWNoUmVjb3JkKCkge1xcbiAgICAgICAgdGhpcy5fdG91Y2hMaXN0ID0ge307XFxuICAgIH1cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvdWNoUmVjb3JkLnByb3RvdHlwZSwgXFxcIl9wcmltaXRpdmVWYWx1ZVxcXCIsIHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVG91Y2hJRCAhPT0gdW5kZWZpbmVkO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0RGVsdGEgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdHJhY2tlciA9IHRoaXMuX2dldEFjdGl2ZVRyYWNrZXIoKTtcXG4gICAgICAgIGlmICghdHJhY2tlcikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRyYWNrZXIuZGVsdGEpO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdHJhY2tlciA9IHRoaXMuX2dldEFjdGl2ZVRyYWNrZXIoKTtcXG4gICAgICAgIGlmICghdHJhY2tlcikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRyYWNrZXIudmVsb2NpdHkpO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0RWFzaW5nRGlzdGFuY2UgPSBmdW5jdGlvbiAoZGFtcGluZykge1xcbiAgICAgICAgdmFyIGRlQWNjZWxlcmF0aW9uID0gMSAtIGRhbXBpbmc7XFxuICAgICAgICB2YXIgZGlzdGFuY2UgPSB7XFxuICAgICAgICAgICAgeDogMCxcXG4gICAgICAgICAgICB5OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciB2ZWwgPSB0aGlzLmdldFZlbG9jaXR5KCk7XFxuICAgICAgICBPYmplY3Qua2V5cyh2ZWwpLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzbWFsbCB2ZWxvY2l0eVxcbiAgICAgICAgICAgIHZhciB2ID0gTWF0aC5hYnModmVsW2Rpcl0pIDw9IDEwID8gMCA6IHZlbFtkaXJdO1xcbiAgICAgICAgICAgIHdoaWxlICh2ICE9PSAwKSB7XFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlW2Rpcl0gKz0gdjtcXG4gICAgICAgICAgICAgICAgdiA9ICh2ICogZGVBY2NlbGVyYXRpb24pIHwgMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZXZ0LnRhcmdldFRvdWNoZXM7XFxuICAgICAgICBBcnJheS5mcm9tKHRhcmdldFRvdWNoZXMpLmZvckVhY2goZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2FkZCh0b3VjaCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaExpc3Q7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldnQudG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XFxuICAgICAgICBBcnJheS5mcm9tKHRvdWNoZXMpLmZvckVhY2goZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX3JlbmV3KHRvdWNoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSUQoY2hhbmdlZFRvdWNoZXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTGlzdDtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FjdGl2ZVRvdWNoSUQ7XFxuICAgICAgICBBcnJheS5mcm9tKGV2dC5jaGFuZ2VkVG91Y2hlcykuZm9yRWFjaChmdW5jdGlvbiAodG91Y2gpIHtcXG4gICAgICAgICAgICBfdGhpcy5fZGVsZXRlKHRvdWNoKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgaWYgKHRoaXMuX2hhcyh0b3VjaCkpIHtcXG4gICAgICAgICAgICAvLyByZXNldCB0cmFja2VyXFxuICAgICAgICAgICAgdGhpcy5fZGVsZXRlKHRvdWNoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0cmFja2VyID0gbmV3IFRyYWNrZXIodG91Y2gpO1xcbiAgICAgICAgdGhpcy5fdG91Y2hMaXN0W3RvdWNoLmlkZW50aWZpZXJdID0gdHJhY2tlcjtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLl9yZW5ldyA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgaWYgKCF0aGlzLl9oYXModG91Y2gpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB0aGlzLl90b3VjaExpc3RbdG91Y2guaWRlbnRpZmllcl07XFxuICAgICAgICB0cmFja2VyLnVwZGF0ZSh0b3VjaCk7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS5fZGVsZXRlID0gZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICBkZWxldGUgdGhpcy5fdG91Y2hMaXN0W3RvdWNoLmlkZW50aWZpZXJdO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuX2hhcyA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTGlzdC5oYXNPd25Qcm9wZXJ0eSh0b3VjaC5pZGVudGlmaWVyKTtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLl9zZXRBY3RpdmVJRCA9IGZ1bmN0aW9uICh0b3VjaGVzKSB7XFxuICAgICAgICB0aGlzLl9hY3RpdmVUb3VjaElEID0gdG91Y2hlc1t0b3VjaGVzLmxlbmd0aCAtIDFdLmlkZW50aWZpZXI7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS5fZ2V0QWN0aXZlVHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF90b3VjaExpc3QgPSBfYS5fdG91Y2hMaXN0LCBfYWN0aXZlVG91Y2hJRCA9IF9hLl9hY3RpdmVUb3VjaElEO1xcbiAgICAgICAgcmV0dXJuIF90b3VjaExpc3RbX2FjdGl2ZVRvdWNoSURdO1xcbiAgICB9O1xcbiAgICByZXR1cm4gVG91Y2hSZWNvcmQ7XFxufSgpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3VjaC1yZWNvcmQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvdG91Y2gtcmVjb3JkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IF9fZXh0ZW5kcywgX19hc3NpZ24sIF9fcmVzdCwgX19kZWNvcmF0ZSwgX19wYXJhbSwgX19tZXRhZGF0YSwgX19hd2FpdGVyLCBfX2dlbmVyYXRvciwgX19jcmVhdGVCaW5kaW5nLCBfX2V4cG9ydFN0YXIsIF9fdmFsdWVzLCBfX3JlYWQsIF9fc3ByZWFkLCBfX3NwcmVhZEFycmF5cywgX19hd2FpdCwgX19hc3luY0dlbmVyYXRvciwgX19hc3luY0RlbGVnYXRvciwgX19hc3luY1ZhbHVlcywgX19tYWtlVGVtcGxhdGVPYmplY3QsIF9faW1wb3J0U3RhciwgX19pbXBvcnREZWZhdWx0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1RzbGliVHNsaWJFczZKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19leHRlbmRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2V4dGVuZHM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXNzaWduXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2Fzc2lnbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19yZXN0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3Jlc3Q7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fZGVjb3JhdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZGVjb3JhdGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fcGFyYW1cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcGFyYW07IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fbWV0YWRhdGFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fbWV0YWRhdGE7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXdhaXRlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hd2FpdGVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2dlbmVyYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19nZW5lcmF0b3I7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fY3JlYXRlQmluZGluZ1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19jcmVhdGVCaW5kaW5nOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2V4cG9ydFN0YXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZXhwb3J0U3RhcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX192YWx1ZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fdmFsdWVzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX3JlYWRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcmVhZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19zcHJlYWRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fc3ByZWFkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX3NwcmVhZEFycmF5c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWRBcnJheXM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXdhaXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXdhaXQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXN5bmNHZW5lcmF0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3I7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXN5bmNEZWxlZ2F0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNEZWxlZ2F0b3I7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fYXN5bmNWYWx1ZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNWYWx1ZXM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX21ha2VUZW1wbGF0ZU9iamVjdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19pbXBvcnRTdGFyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2ltcG9ydFN0YXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9faW1wb3J0RGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0OyB9KTtcXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cXHJcXG5cXHJcXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcXHJcXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXFxyXFxuXFxyXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcXHJcXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcXHJcXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXFxyXFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXFxyXFxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcXHJcXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXFxyXFxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xcclxcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXFxyXFxuXFxyXFxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XFxyXFxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXHJcXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXHJcXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xcclxcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG59O1xcclxcblxcclxcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XFxyXFxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxyXFxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcclxcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxyXFxufVxcclxcblxcclxcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xcclxcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHQ7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XFxyXFxuICAgIHZhciB0ID0ge307XFxyXFxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxcclxcbiAgICAgICAgdFtwXSA9IHNbcF07XFxyXFxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFxcXCJmdW5jdGlvblxcXCIpXFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxcclxcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgcmV0dXJuIHQ7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcXHJcXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcXHJcXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xcclxcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xcclxcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xcclxcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcXHJcXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XFxyXFxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcclxcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxcclxcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXFxcInRocm93XFxcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxcclxcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cXHJcXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcXHJcXG4gICAgfSk7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcXHJcXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcXHJcXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFxcXCJ0aHJvd1xcXCI6IHZlcmIoMSksIFxcXCJyZXR1cm5cXFwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XFxyXFxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxcclxcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XFxyXFxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlxcXCIpO1xcclxcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XFxyXFxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcXFwicmV0dXJuXFxcIl0gOiBvcFswXSA/IHlbXFxcInRocm93XFxcIl0gfHwgKCh0ID0geVtcXFwicmV0dXJuXFxcIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xcclxcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcXHJcXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XFxyXFxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XFxyXFxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcXHJcXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcXHJcXG4gICAgb1trMl0gPSBtW2tdO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xcclxcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcXFwiZGVmYXVsdFxcXCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XFxyXFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcclxcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXHJcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXHJcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcclxcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XFxyXFxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XFxyXFxuICAgIGlmICghbSkgcmV0dXJuIG87XFxyXFxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XFxyXFxuICAgIGZpbmFsbHkge1xcclxcbiAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcXFwicmV0dXJuXFxcIl0pKSBtLmNhbGwoaSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gYXI7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xcclxcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcXHJcXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcXHJcXG4gICAgcmV0dXJuIGFyO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcXHJcXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XFxyXFxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcXHJcXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxcclxcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xcclxcbiAgICByZXR1cm4gcjtcXHJcXG59O1xcclxcblxcclxcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xcclxcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcXHJcXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxyXFxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XFxyXFxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXFxcIm5leHRcXFwiKSwgdmVyYihcXFwidGhyb3dcXFwiKSwgdmVyYihcXFwicmV0dXJuXFxcIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcXHJcXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XFxyXFxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cXHJcXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFxcXCJuZXh0XFxcIiwgdmFsdWUpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXFxcInRocm93XFxcIiwgdmFsdWUpOyB9XFxyXFxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XFxyXFxuICAgIHZhciBpLCBwO1xcclxcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFxcXCJuZXh0XFxcIiksIHZlcmIoXFxcInRocm93XFxcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXFxcInJldHVyblxcXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xcclxcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcXFwicmV0dXJuXFxcIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcXHJcXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxyXFxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XFxyXFxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFxcXCJmdW5jdGlvblxcXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXFxcIm5leHRcXFwiKSwgdmVyYihcXFwidGhyb3dcXFwiKSwgdmVyYihcXFwicmV0dXJuXFxcIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XFxyXFxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cXHJcXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xcclxcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFxcXCJyYXdcXFwiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cXHJcXG4gICAgcmV0dXJuIGNvb2tlZDtcXHJcXG59O1xcclxcblxcclxcbmZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcXHJcXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcXHJcXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xcclxcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xcclxcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcXHJcXG4gICAgcmV0dXJuIHJlc3VsdDtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xcclxcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XFxyXFxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XFxyXFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcXHJcXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcXHJcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xcclxcbiAgICByZXR1cm4gdmFsdWU7XFxyXFxufVxcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1dlYnBhY2tCdWlsZGluR2xvYmFsSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcInZhciBnO1xcblxcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXFxuZyA9IChmdW5jdGlvbigpIHtcXG5cXHRyZXR1cm4gdGhpcztcXG59KSgpO1xcblxcbnRyeSB7XFxuXFx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXFxuXFx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKCk7XFxufSBjYXRjaCAoZSkge1xcblxcdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXFxuXFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFxcXCJvYmplY3RcXFwiKSBnID0gd2luZG93O1xcbn1cXG5cXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXFxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9zcmMvc2NyaXB0cy9jb250YWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9zcmMvc2NyaXB0cy9jb250YWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBzcmNTY3JpcHRzQ29udGFjdEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dlbmVyYWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2VuZXJhbCAqLyBcXFwiLi9zcmMvc2NyaXB0cy9nZW5lcmFsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNtb290aF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNtb290aC1zY3JvbGxiYXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvaW5kZXguanNcXFwiKTtcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5jbGFzcyBDb250YWN0Q2xhc3MgZXh0ZW5kcyBfZ2VuZXJhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJHZW5lcmFsQ2xhc3NcXFwiXSB7XFxyXFxuICBjb25zdHJ1Y3RvcigpIHtcXHJcXG4gICAgc3VwZXIoKTtcXHJcXG4gICAgdGhpcy5MYXVuY2hDb250YWN0KCk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBhc3luYyBMYXVuY2hDb250YWN0KCkge1xcclxcbiAgICBjb25zdCBoYW1idXJnZXJfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnanMtaGFtYnVyZ2VyJylbMF07XFxyXFxuICAgIGNvbnN0IGhlYWRlcl9uYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdGlvbi1uYXYnKTtcXHJcXG4gICAgY29uc3QgY29udGFjdEZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybS1jb250YWN0Jyk7XFxyXFxuICAgIGNvbnN0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWFpbi1zY3JvbGxiYXInKTtcXHJcXG4gICAgY29uc3QgbGF0ID0gMTYuOTY4MjU5NztcXHJcXG4gICAgY29uc3QgbG5nID0gLTk2LjQ4NjM1Mzc7XFxyXFxuICAgIGNvbnN0IHpvb20gPSAxMTtcXHJcXG4gICAgbGV0IG1hcDtcXHJcXG4gICAgbGV0IHNjcm9sbGJhciA9IG51bGw7XFxyXFxuXFxyXFxuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcXHJcXG5cXHJcXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XFxyXFxuICAgICAgc2Nyb2xsYmFyID0gc21vb3RoX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0uaW5pdChtYWluLCB7XFxyXFxuICAgICAgICBkYW1waW5nOiAwLjIsXFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0sIDEwMCk7XFxyXFxuXFxyXFxuICAgIGhhbWJ1cmdlcl9idG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xcclxcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICBoYW1idXJnZXJfYnRuLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xcclxcbiAgICAgIGhlYWRlcl9uYXYuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvd24nKTtcXHJcXG4gICAgICAvL2RvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgnb3YtaGlkZGVuJyk7XFxyXFxuICAgIH0pO1xcclxcbiAgICAvLyBjb25zdCB7IFZhbGlkYXRlRm9ybSwgQ2xlYW5Gb3JtSW5mbyB9ID0gbmV3IEdlbmVyYWxDbGFzcygpO1xcclxcbiAgICAvLyBjb25zdCBjb250YWN0X2J0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1jb250YWN0LXNlbmQnKTtcXHJcXG5cXHJcXG4gICAgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJyksIHtcXHJcXG4gICAgICBjZW50ZXI6IHsgbGF0LCBsbmcgfSxcXHJcXG4gICAgICBzY3JvbGx3aGVlbDogdHJ1ZSxcXHJcXG4gICAgICBtYXBUeXBlQ29udHJvbDogZmFsc2UsXFxyXFxuICAgICAgem9vbVxcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgdGhpcy5TZXRJc0FjdGl2ZVNlYygpO1xcclxcblxcclxcbiAgICBjb250YWN0Rm9ybS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgaWYgKGUudGFyZ2V0Lm1hdGNoZXMoJy5mb3JtLWNvbnRhY3QgW3JlcXVpcmVkXScpKSB7XFxyXFxuICAgICAgICB2YXIgaW5wdXQgPSBlLnRhcmdldCxcXHJcXG4gICAgICAgICAgcGF0dGVybiA9IGlucHV0LnBhdHRlcm4gfHwgaW5wdXQuZGF0YXNldC5wYXR0ZXJuO1xcclxcblxcclxcbiAgICAgICAgaWYgKHBhdHRlcm4gJiYgaW5wdXQudmFsdWUgIT09ICcnKSB7XFxyXFxuICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybik7XFxyXFxuICAgICAgICAgIHJldHVybiAhcmVnZXguZXhlYyhpbnB1dC52YWx1ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcXHJcXG4gICAgICAgICAgcmV0dXJuIGlucHV0LnZhbHVlID09PSAnJztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0pO1xcclxcbiAgICBjb250YWN0Rm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICB2YXIgcmVzcG9uc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybS1jb250YWN0X19yZXNwb25zZScpLFxcclxcbiAgICAgICAgbG9hZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm0tY29udGFjdF9fbG9hZGVyJyk7XFxyXFxuICAgICAgbG9hZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xcclxcbiAgICAgIGZldGNoKCcuLi9hc3NldHMvcGhwL2NvbnRhY3QucGhwJywge1xcclxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxyXFxuICAgICAgICBib2R5OiBuZXcgRm9ybURhdGEoZS50YXJnZXQpXFxyXFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XFxyXFxuICAgICAgICByZXR1cm4gcmVzLm9rID8gcmVzLmpzb24oKSA6IFByb21pc2UucmVqZWN0KHJlcyk7XFxyXFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoanNvbikge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coanNvbik7XFxyXFxuICAgICAgICBsb2FkZXIuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XFxyXFxuICAgICAgICByZXNwb25zZS5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcXHJcXG4gICAgICAgIHJlc3BvbnNlLmlubmVySFRNTCA9IFxcXCI8cD5cXFwiLmNvbmNhdChqc29uLm1lc3NhZ2UsIFxcXCI8L3A+XFxcIik7XFxyXFxuICAgICAgICBjb250YWN0Rm9ybS5yZXNldCgpO1xcclxcbiAgICAgICAgd2luZG93LmRhdGFMYXllci5wdXNoKHtcXHJcXG4gICAgICAgICAgJ2V2ZW50JzogJ3RoYW5reW91cGFnZScsXFxyXFxuICAgICAgICAgICdldmVudENhdGVnb3J5JzogJ2NvbnRhY3RvJyxcXHJcXG4gICAgICAgICAgJ2V2ZW50QWN0aW9uJzogJ2NsaWNrX2JvdG9uX2VudmlhcicsXFxyXFxuICAgICAgICAgICdldmVudExhYmVsJzogJ0NvbnRhY3Rhbm9zJ1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgfSlbXFxcImNhdGNoXFxcIl0oZnVuY3Rpb24gKGVycikge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcXHJcXG4gICAgICAgIHZhciBtZXNzYWdlID0gZXJyLnN0YXR1c1RleHQgfHwgJ09jdXJyaW8gdW4gZXJyb3IgYWwgZW52aWFyIHR1cyBkYXRvcywgaW50ZW50YSBudWV2YW1lbnRlJztcXHJcXG4gICAgICAgIHJlc3BvbnNlLmlubmVySFRNTCA9IFxcXCI8cD5FcnJvciBcXFwiLmNvbmNhdChlcnIuc3RhdHVzVGV4dCwgXFxcIjogXFxcIikuY29uY2F0KG1lc3NhZ2UsIFxcXCI8L3A+XFxcIik7XFxyXFxuICAgICAgfSlbXFxcImZpbmFsbHlcXFwiXShmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIHJlc3BvbnNlLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xcclxcbiAgICAgICAgICByZXNwb25zZS5pbm5lckhUTUwgPSAnJztcXHJcXG4gICAgICAgIH0sIDQwMDApO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4gIFNldElzQWN0aXZlU2VjKCkge1xcclxcbiAgICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xcclxcbiAgICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XFxyXFxuICAgIGNvbnN0IGxvYyA9IGxvY2F0aW9uLnNwbGl0KCcvJyk7XFxyXFxuICAgIGNvbnN0IGxhc3RJdGVtID0gaGFzaCA/IGxvY1tsb2MubGVuZ3RoIC0gMl0gOiBsb2NhdGlvbi5yZXBsYWNlKC8uKlxcXFwvKFxcXFx3KylcXFxcLz8kLywgJyQxJyk7XFxyXFxuICAgIGNvbnN0IGFuY2hvcl9pbnYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2aWdhdGlvbl9fbGluaycpO1xcclxcblxcclxcbiAgICBmb3IgKGNvbnN0IGxpbmsgb2YgYW5jaG9yX2ludikge1xcclxcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPT09ICcvJyB8fFxcclxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoJ2luZGV4JykgPiAtMSkge1xcclxcbiAgICAgICAgYW5jaG9yX2ludlswXS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKGxpbmsuaHJlZi5pbmNsdWRlcyhsYXN0SXRlbSkpIHtcXHJcXG4gICAgICAgIGxpbmsucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50Jyk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICB9XFxyXFxuXFxyXFxuICAvKmFzeW5jIFNlbmRDb250YWN0KCkge1xcclxcbiAgICBjb25zdCB7IFJlbW92ZUFsbEVycm9ycywgUmVxdWVzdERhdGEsIEdldExhbmd1YWdlLCBTaG93TW9kYWwgfSA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG4gICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWN0LWZvcm0nKTtcXHJcXG4gICAgY29uc3QgeyBlcnJvciwgbWVzc2FnZSwgZmllbGRFcnJvcnMgfSA9IGF3YWl0IFJlcXVlc3REYXRhKHsgc2VydmljZTogJ2NvbnRhY3RVcycsIGZvcm0gfSkvKixcXHJcXG4gICAgICBtZXNzYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1jb250YWN0LW1lc3NhZ2VzJyksXFxyXFxuICAgICAgZm9ybV93cnAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFjdC1mb3JtLXdycCcpXFxyXFxuICAgIGNvbnN0IGxhbmd1YWdlID0gR2V0TGFuZ3VhZ2UoKTtcXHJcXG5cXHJcXG4gICAgUmVtb3ZlQWxsRXJyb3JzKCk7XFxyXFxuXFxyXFxuICAgIHdpbmRvdy5kYXRhTGF5ZXIucHVzaCh7XFxyXFxuICAgICAgJ2V2ZW50JzogJ3RoYW5reW91cGFnZScsXFxyXFxuICAgICAgJ2V2ZW50Q2F0ZWdvcnknOiAnY29udGFjdG8nLFxcclxcbiAgICAgICdldmVudEFjdGlvbic6ICdjbGlja19ib3Rvbl9lbnZpYXInLFxcclxcbiAgICAgICdldmVudExhYmVsJzogJ0NvbnRhY3Rhbm9zJ1xcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgaWYgKGVycm9yID09PSAnMCcpIHtcXHJcXG4gICAgICBmb3JtLnJlc2V0KCk7XFxyXFxuICAgICAgLyptZXNzYWdlcy5jbGFzc0xpc3QuYWRkKCdzdWNjZXNzZnVsJyk7XFxyXFxuICAgICAgbWVzc2FnZXMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XFxyXFxuICAgICAgZm9ybV93cnAuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XFxyXFxuICAgICAgbWVzc2FnZXMuaW5uZXJIVE1MID0gbWVzc2FnZTtcXHJcXG5cXHJcXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcXHJcXG4gICAgICAgIG1lc3NhZ2VzLmlubmVySFRNTCA9ICcnO1xcclxcbiAgICAgICAgZm9ybV93cnAuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XFxyXFxuICAgICAgICBtZXNzYWdlcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcXHJcXG5cXHJcXG4gICAgICB9LCA2MjAwKTtcXHJcXG5cXHJcXG4gICAgICBjb25zdCBtb2RhbF9tZXNzYWdlID0gbGFuZ3VhZ2UgPT09ICdlcycgPyAnR3JhY2lhcyBwb3IgY29tcGFydGlybm9zIHR1cyBkYXRvcywgZW4gYnJldmUgbm9zIHBvbmRyZW1vcyBlbiBjb250YWN0byBjb250aWdvLicgOiAnV2UgcmVjZWl2ZWQgeW91ciByZXF1ZXN0LCB3ZSB3aWxsIGNvbnRhY3QgeW91IHNob3J0bHkuJztcXHJcXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGA8ZGl2IGNsYXNzPVxcXCJtZXNzYWdlLWNvbnRlbnRcXFwiPjxidXR0b24gY2xhc3M9XFxcIm9sLWNsb3NlLWJveCBpY29uIGljb24tY3Jvc3NcXFwiPjwvYnV0dG9uPjxwPiR7bW9kYWxfbWVzc2FnZX08L3A+PC9kaXY+YDtcXHJcXG4gICAgICBTaG93TW9kYWwoeyBjaGlsZHJlbiB9KTtcXHJcXG5cXHJcXG4gICAgICB3aW5kb3cuZGF0YUxheWVyLnB1c2goe1xcclxcbiAgICAgICAgJ2V2ZW50JzogJ3N1Y2Nlc3Njb250YWN0cGFnZScsXFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgbGV0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XFxyXFxuICAgICAgcC5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xcclxcbiAgICAgIHAuaW5uZXJIVE1MID0gbWVzc2FnZTtcXHJcXG4gICAgICBmb3JtLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocCk7XFxyXFxuXFxyXFxuICAgICAgLyphcnIuZm9yRWFjaChpdGVtID0+IHtcXHJcXG5cXHJcXG4gICAgICBmaWVsZEVycm9ycyAmJiBPYmplY3QuZW50cmllcyhmaWVsZEVycm9ycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XFxyXFxuICAgICAgICBsZXQgcGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XFxyXFxuICAgICAgICBwYy5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xcclxcblxcclxcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGlucHV0W25hbWU9XFxcIiR7a2V5fVxcXCJdYCkpIHtcXHJcXG4gICAgICAgICAgcGMuaW5uZXJIVE1MID0gdmFsdWU7XFxyXFxuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGlucHV0W25hbWU9XFxcIiR7a2V5fVxcXCJdYCkucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwYyk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgfSk7XFxyXFxuICAgICAgZm9ybS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHApO1xcclxcbiAgICAgIGlmIChmaWVsZEVycm9ycykge1xcclxcbiAgICAgICAgZm9yIChsZXQgbiBpbiBmaWVsZEVycm9ycykge1xcclxcbiAgICAgICAgICBsZXQgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcXHJcXG4gICAgICAgICAgcC5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xcclxcbiAgICAgICAgICBwLmlubmVySFRNTCA9IGZpZWxkRXJyb3JzW25dO1xcclxcbiAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHApO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfSovXFxyXFxufVxcclxcbmxldCBtYWluO1xcclxcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXFxyXFxuICAnRE9NQ29udGVudExvYWRlZCcsXFxyXFxuICAoKSA9PiB7XFxyXFxuICAgIG1haW4gPSBuZXcgQ29udGFjdENsYXNzKCk7XFxyXFxuICAgIHdpbmRvdy5tYWluID0gbWFpbjtcXHJcXG4gIH0sXFxyXFxuICBmYWxzZVxcclxcbik7XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY29udGFjdC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL3NyYy9zY3JpcHRzL2dlbmVyYWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL3NyYy9zY3JpcHRzL2dlbmVyYWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBHZW5lcmFsQ2xhc3MgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gc3JjU2NyaXB0c0dlbmVyYWxKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiR2VuZXJhbENsYXNzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBHZW5lcmFsQ2xhc3M7IH0pO1xcblxcclxcblxcclxcbmNsYXNzIEdlbmVyYWxDbGFzcyB7XFxyXFxuXFxyXFxuICAgIFNldElzTW9iaWxlKCkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG5cXHJcXG4gICAgYXN5bmMgUmVxdWVzdERhdGEoeyBmb3JtLCBzZXJ2aWNlIH0pIHtcXHJcXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xcclxcbiAgICAgICAgY29uc3QgeyBHZXRMYW5ndWFnZSB9ID0gbmV3IEdlbmVyYWxDbGFzcygpO1xcclxcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBHZXRMYW5ndWFnZSgpO1xcclxcbiAgICAgICAgY29uc3QgZGF0YVRvU2VuZCA9IHtsYW5ndWFnZX07XFxyXFxuICAgICAgICBjb25zdCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcygnZGV2c2l0ZScpIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdsb2NhbCcpID8gJ2h0dHBzOi8vc2VydmljZXMuc3RnLm11YmFyby5teC9zZXJ2aWNlcy9tdWJhcm8vJyA6ICdodHRwczovL3NlcnZpY2VzLm11YmFyby5teC9zZXJ2aWNlcy9tdWJhcm8vJztcXHJcXG5cXHJcXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xcclxcbiAgICAgICAgICAgIGRhdGFUb1NlbmRbbmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGZvcm1Cb2R5ID0gT2JqZWN0LmtleXMoZGF0YVRvU2VuZClcXHJcXG4gICAgICAgICAgICAubWFwKFxcclxcbiAgICAgICAgICAgICAgICAoa2V5KSA9PlxcclxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVRvU2VuZFtrZXldKVxcclxcbiAgICAgICAgICAgIClcXHJcXG4gICAgICAgICAgICAuam9pbignJicpLFxcclxcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dXJsfSR7c2VydmljZX0ucGhwYCwge1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCcsXFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcclxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtQm9keSxcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZ28gc2FsaVxceEYzIG1hbC4gVmVyaWZpY2EgbG9zIGRhdG9zIHkgdnVlbHZlIGEgaW50ZW50YXJsby4nKTtcXHJcXG4gICAgICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyb3IpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcXHJcXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBTZXRDb29raWUoKSB7XFxyXFxuICAgICAgICBjb25zdCBkaXNjbGFpbWVyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Rpc2NsYWltZXInKTtcXHJcXG4gICAgICAgIGNvbnN0IHsgR2V0TGFuZ3VhZ2UgfSA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gR2V0TGFuZ3VhZ2UoKTtcXHJcXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBsYW5ndWFnZSA9PT0gJ2VuJyA/IGBZb3UgYXJlIGJyb3dzaW5nIGEgd2Vic2l0ZSB3aXRoIGl0XFx1MjAxOXMgb3duIGFuZCB0aGlyZC1wYXJ0eSBjb29raWVzIHRvIG9mZmVyIHlvdSBhbiBvcHRpbWFsIGV4cGVyaWVuY2UuIFRvIGNvbnRpbnVlIGJyb3dzaW5nLCBjbGljayBBY2NlcHQuIElmIHlvdSB3YW50IG1vcmUgaW5mb3JtYXRpb24gZW50ZXIgb3VyIFByaXZhY3kgUG9saWN5YDogYEVzdFxceEUxcyBuYXZlZ2FuZG8gZW4gdW4gc2l0aW8gY29uIGNvb2tpZXMgcHJvcGlhcyB5IGRlIHRlcmNlcm9zLCBwYXJhIG9mcmVjZXJ0ZSB1bmEgZXhwZXJpZW5jaWEgXFx4RjNwdGltYS4gPGJyLz5QYXJhIGNvbnRpbnVhciBuYXZlZ2FuZG8sIGRhbGUgQWNlcHRhci4gPGJyLz5TaSBkZXNlYXMgbVxceEUxcyBpbmZvcm1hY2lcXHhGM24gZW50cmEgYSBudWVzdHJhIHBvbFxceEVEdGljYSBkZSBwcml2YWNpZGFkLiBgO1xcclxcbiAgICAgICAgY29uc3QgZGVueVRleHQgPSBsYW5ndWFnZSA9PT0gJ2VuJyA/ICdEZW55JyA6ICdObyBhY2VwdG8nO1xcclxcbiAgICAgICAgY29uc3QgYWNjZXB0VGV4dCA9IGxhbmd1YWdlID09PSAnZW4nID8gJ0FjY2VwdCcgOiAnQWNlcHRvJztcXHJcXG5cXHJcXG4gICAgICAgIGlmICghZGlzY2xhaW1lcikge1xcclxcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZV93cnAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXHJcXG4gICAgICAgICAgICAgICAgY29va2llX21hcmt1cCA9IGBcXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29va2llcy1jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29va2llcy13cnAgdGV4dC1jZW50ZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPiR7bWVzc2FnZX08L3A+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGNvb2tpZXMtYnRuLXdycCBteC1hdXRvXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdHlwZT1cXFwieWVzXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1ibHVlIGJ0bi1jb29raWVcXFwiPiR7YWNjZXB0VGV4dH08L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdHlwZT1cXFwibm9cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWJsdWUgYnRuLWNvb2tpZSBidG5cXFwiPiR7ZGVueVRleHR9PC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+YDtcXHJcXG4gICAgICAgICAgICBjb29raWVfd3JwLmNsYXNzTGlzdC5hZGQoJ2Nvb2tpZXMtZGlzY2xhaW0nKTtcXHJcXG4gICAgICAgICAgICBjb29raWVfd3JwLmlubmVySFRNTCA9IGNvb2tpZV9tYXJrdXA7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb29raWVfd3JwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBjb25zdCBjb29raWVfYnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJ0bi1jb29raWUnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoY29va2llX2J0biwgKGMpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgYy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGd0ID0gZS5jdXJyZW50VGFyZ2V0LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0Z3QuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAneWVzJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdkaXNjbGFpbWVyJywgdHJ1ZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29va2llcy1kaXNjbGFpbScpLnJlbW92ZSgpO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBHZXRRdWVyeVN0cmluZyhuYW1lLCB1cmwpIHtcXHJcXG4gICAgICAgIGlmICghdXJsKSB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcXHJcXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFxcW1xcXFxdXS9nLCAnXFxcXFxcXFwkJicpO1xcclxcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnWz8mXScgKyBuYW1lICsgJyg9KFteJiNdKil8JnwjfCQpJyksXFxyXFxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcXHJcXG4gICAgICAgIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XFxyXFxuICAgICAgICBpZiAoIXJlc3VsdHNbMl0pIHJldHVybiAnJztcXHJcXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1syXS5yZXBsYWNlKC9cXFxcKy9nLCAnICcpKTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBEZWNvZGUoc3RyKSB7XFxyXFxuXFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4RTEnLCAnYScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEMxJywgJ0EnKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhFOScsICdlJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4QzknLCAnRScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEVEJywgJ2knKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhDRCcsICdJJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4RjMnLCAnbycpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEQzJywgJ08nKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhGQScsICd1Jyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4REEnLCAnVScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEYxJywgJ24nKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhEMScsICdOJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4QUUnLCAnJyk7XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gc3RyO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGFzeW5jIEdldERhdGEocGF0aCkge1xcclxcbiAgICAgICAgY29uc3QgU0VSVklDRVNfVVJMID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoJ2RldnNpdGUnKSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcygnbG9jYWwnKSA/ICcnIDogJyc7XFxyXFxuICAgICAgICBjb25zdCB1cmwgPSBTRVJWSUNFU19VUkwgKyAnLycgKyBwYXRoLFxcclxcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKSxcXHJcXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xcclxcblxcclxcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XFxyXFxuICAgICAgICByZXR1cm4gZGF0YTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBDaGFyc0FsbG93ZWQodmFsdWUpIHtcXHJcXG4gICAgICAgIGNvbnN0IGFsbG93ZWRDaGFycyA9IG5ldyBSZWdFeHAoL15bYS16QS1aXFx4RjFcXHhEMVxcXFxzXSskLylcXHJcXG4gICAgICAgIHJldHVybiBhbGxvd2VkQ2hhcnMudGVzdCh2YWx1ZSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgQ2xlYW5Gb3JtSW5mbygpIHtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZXF1aXJlZC1maWVsZCcpO1xcclxcbiAgICAgICAgY29uc3Qgc2VsZiA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IHsgR2V0TGFuZ3VhZ2UsIFJlbW92ZUFsbEVycm9ycyB9ID0gbmV3IEdlbmVyYWxDbGFzcygpO1xcclxcblxcclxcbiAgICAgICAgY29uc3QgbGFuZyA9IEdldExhbmd1YWdlKCk7XFxyXFxuXFxyXFxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLCAoZSwgaW5kZXgpID0+IHtcXHJcXG5cXHJcXG4gICAgICAgICAgICBsZXQgdGd0ID0gZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB0Z3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCRlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIFJlbW92ZUFsbEVycm9ycygpO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgIHRndC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsICgkZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0Z3QudmFsdWU7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0Z3QuZ2V0QXR0cmlidXRlKCduYW1lJyk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG1heGxlbmd0aCA9IDEwO1xcclxcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Bob25lJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiBtYXhsZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0Z3QudmFsdWUgPSB2YWwuc3Vic3RyKDAsIG1heGxlbmd0aCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB0Z3QuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoJGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgUmVtb3ZlQWxsRXJyb3JzKCk7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGd0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgUmVtb3ZlQWxsRXJyb3JzKCk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0Z3QuZ2V0QXR0cmlidXRlKCduYW1lJyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xcclxcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JfbWVzc2FnZSA9IG5hbWUgPT09ICdwaG9uZScgPyBsYW5nID09PSAnZXMnID8gJ1NvbG8gc2UgYWRtaXRlbiBuXFx4RkFtZXJvcycgOiAnT25seSBudW1iZXJzJyA6IG5hbWUgPT09ICdlbWFpbCcgPyBsYW5nID09PSAnZXMnID8gJ0luZ3Jlc2EgdW4gY29ycmVvIGVsZWN0clxceEYzbmljbyB2XFx4RTFsaWRvJyA6ICdFbWFpbCcgOiBsYW5nID09PSAnZXMnID8gJ1NvbG8gc2UgYWRtaXRlbiBsZXRyYXMnIDogJ09ubHkgbGV0dGVycyc7XFxyXFxuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IG5hbWUgPT09ICdwaG9uZScgPyAvXlswLTldKyQvIDogbmFtZSA9PT0gJ2VtYWlsJyA/IC9bQS1aMC05Ll8lKy1dK0BbQS1aMC05Li1dK1xcXFwuW0EtWl17Miw0fS9naSA6IC9eW0EtWmEtelxceEMxLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHhGRlxcXFxzXSokL1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvL1ZhbGlkYXRlIFRleHRCb3ggdmFsdWUgYWdhaW5zdCB0aGUgUmVnZXguXFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB0Z3QudmFsdWUgPyByZWdleC50ZXN0KHRndC52YWx1ZSkgOiB0cnVlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQgJiYgIW5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZGF0ZScpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwLmlubmVySFRNTCA9IGVycm9yX21lc3NhZ2U7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0Z3QucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIFJlbW92ZUFsbEVycm9ycygpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgIHRndC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsICgkZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBSZW1vdmVBbGxFcnJvcnMoKTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG5cXHJcXG5cXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFJlbW92ZUFsbEVycm9ycygpIHtcXHJcXG4gICAgICAgIC8vIGNvbnN0IHJlbW92ZUVycm9ycyA9ICgpID0+IHtcXHJcXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5lcnJvcicpO1xcclxcblxcclxcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGVycm9ycywgKGUsIGluZGV4KSA9PiB7XFxyXFxuICAgICAgICAgICAgZS5yZW1vdmUoKTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgLy99XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgVmFsaWRhdGVGb3JtKCkge1xcclxcbiAgICAgICAgY29uc3QgbGFiZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxhYmVsJyksXFxyXFxuICAgICAgICAgICAgZXJyb3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmVycm9yJyksXFxyXFxuICAgICAgICAgICAgZW1haWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtZW1haWwnKSxcXHJcXG4gICAgICAgICAgICBwaG9uZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1waG9uZScpLFxcclxcbiAgICAgICAgICAgIGVtYWlsVmFsID0gZW1haWwgPyBlbWFpbC52YWx1ZS5zZWFyY2goL1tBLVowLTkuXyUrLV0rQFtBLVowLTkuLV0rXFxcXC5bQS1aXXsyLDR9L2dpKSA+IC0xIDogbnVsbCxcXHJcXG4gICAgICAgICAgICBwaG9uZVZhbCA9IHBob25lID8gcGhvbmUudmFsdWUuc2VhcmNoKC9cXFxcWzAtOV0vKSA6IG51bGwsXFxyXFxuICAgICAgICAgICAgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlcXVpcmVkLWZpZWxkJyk7XFxyXFxuXFxyXFxuICAgICAgICBjb25zdCB7IEdldExhbmd1YWdlIH0gPSBuZXcgR2VuZXJhbENsYXNzKCk7XFxyXFxuXFxyXFxuICAgICAgICBjb25zdCBsYW5nID0gR2V0TGFuZ3VhZ2UoKTtcXHJcXG5cXHJcXG4gICAgICAgIGxldCByZXF1aXJlZCA9IGZpZWxkcy5sZW5ndGgsXFxyXFxuICAgICAgICAgICAgZmllbGRFcnJvciA9IFtdLFxcclxcbiAgICAgICAgICAgIGZpbGxlZCA9IFtdLFxcclxcbiAgICAgICAgICAgIGVtbCA9IDAsXFxyXFxuICAgICAgICAgICAgcGhuID0gMDtcXHJcXG5cXHJcXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChmaWVsZHMsIChmLCBpbmRleCkgPT4ge1xcclxcblxcclxcbiAgICAgICAgICAgIGxldCB0Z3QgPSBmLFxcclxcbiAgICAgICAgICAgICAgICB2YWwsXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlO1xcclxcblxcclxcbiAgICAgICAgICAgIHZhbCA9IGYudmFsdWU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnLTEnKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG1zaiA9IGxhYmVsc1tpbmRleF0uaW5uZXJIVE1MLnJlcGxhY2UoJzonLCAnJykudG9Mb3dlckNhc2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbXNqLm5vcm1hbGl6ZSgnTkZEJykucmVwbGFjZSgvKFtcXFxcdTAzMDAtXFxcXHUwMzZmXXxbXjAtOWEtekEtWl0pL2csICcnKS5yZXBsYWNlKC8oW15cXFxcd10rfFxcXFxzKykvZywgJy0nKTtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XFxyXFxuICAgICAgICAgICAgICAgIHAuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcXHJcXG4gICAgICAgICAgICAgICAgcC5jbGFzc0xpc3QuYWRkKGBlcnJvci0ke3BhcnNlZH1gKTtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBsYW5nID09PSAnZXMnID8gYFBvciBmYXZvciwgaW5ncmVzYSBjb3JyZWN0YW1lbnRlICR7bXNqfS5gIDogYEZpbGwgY29ycmVjdGx5ICR7bXNqfS5gO1xcclxcbiAgICAgICAgICAgICAgICBwLmlubmVySFRNTCA9IHRpdGxlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZXJyb3JzLCAoZSwgaW5kZXgpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlKCk7XFxyXFxuICAgICAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICB0Z3QucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvci5wdXNoKHRpdGxlKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBmaWxsZWQucHVzaCh0Z3QpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgaWYgKGVtYWlsICYmICFlbWFpbFZhbCkge1xcclxcbiAgICAgICAgICAgIGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xcclxcbiAgICAgICAgICAgIHAuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcXHJcXG4gICAgICAgICAgICBwLmlubmVySFRNTCA9IGxhbmcgPT09ICdlcycgPyAnUG9yIGZhdm9yLCBpbmdyZXNhIGNvcnJlY3RhbWVudGUgdHUgY29ycmVvIGVsZWN0clxceEYzbmljby4nIDogJ1BsZWFzZSwgZmlsbCB5b3VyIGVtYWlsJztcXHJcXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLWNvcnJlb2VsZWN0cm9uaWNvJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLWVtYWlsJykpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1lbWFpbC13cnAnKS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZW1sID0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgZW1sID0gMTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChwaG9uZSAmJiAhcGhvbmVWYWwpIHtcXHJcXG4gICAgICAgICAgICBsZXQgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcXHJcXG4gICAgICAgICAgICBwLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XFxyXFxuICAgICAgICAgICAgcC5pbm5lckhUTUwgPSBsYW5nID09PSAnZXMnID8gJ1BvciBmYXZvciwgaW5ncmVzYSBjb3JyZWN0YW1lbnRlIHR1IHRlbFxceEU5Zm9uby4nIDogJ1BsZWFzZSBmaWxsIHlvdXIgcGhvbmUgY29ycmVjdGx5JztcXHJcXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLXRlbGVmb25vJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLXBob25lbnVtYmVyJykpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1waG9uZS13cnAnKS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcGhuID0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgcGhuID0gMTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiByZXF1aXJlZCA9PT0gZmlsbGVkLmxlbmd0aCAmJiBlbWwgPT09IDEgJiYgcGhuID09PSAxO1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIEdldExhbmd1YWdlKCkge1xcclxcbiAgICAgICAgbGV0IGxhbmc7XFxyXFxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoJy9lbi8nKSkge1xcclxcbiAgICAgICAgICAgIGxhbmcgPSAnZW4nO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBsYW5nID0gJ2VzJztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xhbmcnKSkgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhbmcnLCBsYW5nKTtcXHJcXG4gICAgICAgIHJldHVybiBsYW5nO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFNldEFuaW1hdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnN0IGJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJveCcpO1xcclxcbiAgICAgICAgaWYgKGJveGVzKSB7XFxyXFxuICAgICAgICAgIGNvbnN0IHRyaWdnZXJCb3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IC8gNSkgKiA0O1xcclxcbiAgICBcXHJcXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ib3guaW5pdCcpKSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm94LmluaXQnKS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XFxyXFxuICAgIFxcclxcbiAgICAgICAgICBib3hlcy5mb3JFYWNoKChib3gpID0+IHtcXHJcXG4gICAgICAgICAgICBjb25zdCBib3hUb3AgPSBib3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xcclxcbiAgICAgICAgICAgIC8vIEZvciBjaGVja2luZyB3aGVuIHRvIHNob3cgYW5kIGhpZGUgdGhlIGJveFxcclxcbiAgICAgICAgICAgIGlmIChib3hUb3AgPCB0cmlnZ2VyQm90dG9tKSB7XFxyXFxuICAgICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xcclxcbiAgICAgICAgICAgIH0gXFxyXFxuICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBTaG93TW9kYWwoeyBjaGlsZHJlbiwgb25PcGVuLCBvbkFjY2VwdCwgb25DYW5jZWwgfSkge1xcclxcblxcclxcbiAgICAgICAgY29uc3Qgb2wgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb2wtbWFpbicpO1xcclxcbiAgICAgICAgY29uc3Qgc2VsZiA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChvbCkge1xcclxcbiAgICAgICAgICAgIG9sLnJlbW92ZSgpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgbGV0IG9sX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcclxcblxcclxcbiAgICAgICAgb2xfZGl2LmlkID0gJ29sLW1haW4nO1xcclxcblxcclxcbiAgICAgICAgb2xfZGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVxcXCJvbC1tb2RhbC13cmFwcGVyIG9sLW1vZGFsLWNvbnRcXFwiID5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJvbC1tb2RhbC1jb250YWluZXIgb2wtbW9kYWwtY29udFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm9sLW1vZGFsLXBhbmVsLWJveFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICR7Y2hpbGRyZW59XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+YDtcXHJcXG5cXHJcXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob2xfZGl2KTtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGNhbmNlbF9idG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub2wtY2FuY2VsLWJveCcpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vbC1jbG9zZS1ib3gnKTtcXHJcXG4gICAgICAgIGNvbnN0IGFjY2VwdF9idG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub2wtYWNjZXB0LWJveCcpO1xcclxcblxcclxcbiAgICAgICAgaWYgKG9uT3Blbikge1xcclxcbiAgICAgICAgICAgIG9uT3BlbigpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgY2FuY2VsX2J0biAmJiBjYW5jZWxfYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcXHJcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgICAgaWYgKG9uQ2FuY2VsKSB7XFxyXFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsKCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHNlbGYuQ2xvc2VNb2RhbCgpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICBhY2NlcHRfYnRuICYmIGFjY2VwdF9idG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xcclxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAob25BY2NlcHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgb25BY2NlcHQoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBDbG9zZU1vZGFsKCkge1xcclxcbiAgICAgICAgY29uc3Qgb2xfd3JwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9sLW1vZGFsLXdyYXBwZXInKTtcXHJcXG4gICAgICAgIG9sX3dycC5yZW1vdmUoKTtcXHJcXG4gICAgfVxcclxcblxcclxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9nZW5lcmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH1cblxuICAvKioqKioqL1xufSk7Il19
