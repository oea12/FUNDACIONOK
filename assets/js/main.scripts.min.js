"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(t){var r={};function o(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"===_typeof(n)&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/scripts/main.js")}({"./node_modules/core-js/es/array/from.js":function node_modulesCoreJsEsArrayFromJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\n__webpack_require__(/*! ../../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Array.from;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/array/from.js?')},"./node_modules/core-js/es/map/index.js":function node_modulesCoreJsEsMapIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.map */ "./node_modules/core-js/modules/es.map.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Map;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/map/index.js?')},"./node_modules/core-js/es/object/assign.js":function node_modulesCoreJsEsObjectAssignJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Object.assign;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/object/assign.js?')},"./node_modules/core-js/es/set/index.js":function node_modulesCoreJsEsSetIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.set */ "./node_modules/core-js/modules/es.set.js");\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Set;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/set/index.js?')},"./node_modules/core-js/es/weak-map/index.js":function node_modulesCoreJsEsWeakMapIndexJs(module,exports,__webpack_require__){eval('__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");\n__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");\n__webpack_require__(/*! ../../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.WeakMap;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/es/weak-map/index.js?')},"./node_modules/core-js/internals/a-callable.js":function node_modulesCoreJsInternalsACallableJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw $TypeError(tryToString(argument) + \' is not a function\');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/a-callable.js?')},"./node_modules/core-js/internals/a-possible-prototype.js":function node_modulesCoreJsInternalsAPossiblePrototypeJs(module,exports,__webpack_require__){eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument) {\n  if (typeof argument == 'object' || isCallable(argument)) return argument;\n  throw $TypeError(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/a-possible-prototype.js?")},"./node_modules/core-js/internals/add-to-unscopables.js":function node_modulesCoreJsInternalsAddToUnscopablesJs(module,exports,__webpack_require__){eval('var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\n\nvar UNSCOPABLES = wellKnownSymbol(\'unscopables\');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/add-to-unscopables.js?')},"./node_modules/core-js/internals/an-instance.js":function node_modulesCoreJsInternalsAnInstanceJs(module,exports,__webpack_require__){eval("var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ \"./node_modules/core-js/internals/object-is-prototype-of.js\");\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (it, Prototype) {\n  if (isPrototypeOf(Prototype, it)) return it;\n  throw $TypeError('Incorrect invocation');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/an-instance.js?")},"./node_modules/core-js/internals/an-object.js":function node_modulesCoreJsInternalsAnObjectJs(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw $TypeError($String(argument) + ' is not an object');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/an-object.js?")},"./node_modules/core-js/internals/array-buffer-non-extensible.js":function node_modulesCoreJsInternalsArrayBufferNonExtensibleJs(module,exports,__webpack_require__){eval("// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = fails(function () {\n  if (typeof ArrayBuffer == 'function') {\n    var buffer = new ArrayBuffer(8);\n    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe\n    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-buffer-non-extensible.js?")},"./node_modules/core-js/internals/array-from.js":function node_modulesCoreJsInternalsArrayFromJs(module,exports,__webpack_require__){eval('\nvar bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\nvar getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\nvar $Array = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it\'s an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-from.js?')},"./node_modules/core-js/internals/array-includes.js":function node_modulesCoreJsInternalsArrayIncludesJs(module,exports,__webpack_require__){eval('var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-includes.js?')},"./node_modules/core-js/internals/array-iteration.js":function node_modulesCoreJsInternalsArrayIterationJs(module,exports,__webpack_require__){eval('var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");\n\nvar push = uncurryThis([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-iteration.js?')},"./node_modules/core-js/internals/array-slice-simple.js":function node_modulesCoreJsInternalsArraySliceSimpleJs(module,exports,__webpack_require__){eval('var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\n\nvar $Array = Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = $Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-slice-simple.js?')},"./node_modules/core-js/internals/array-species-constructor.js":function node_modulesCoreJsInternalsArraySpeciesConstructorJs(module,exports,__webpack_require__){eval('var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");\nvar isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar SPECIES = wellKnownSymbol(\'species\');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-species-constructor.js?')},"./node_modules/core-js/internals/array-species-create.js":function node_modulesCoreJsInternalsArraySpeciesCreateJs(module,exports,__webpack_require__){eval('var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-species-create.js?')},"./node_modules/core-js/internals/call-with-safe-iteration-closing.js":function node_modulesCoreJsInternalsCallWithSafeIterationClosingJs(module,exports,__webpack_require__){eval('var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator, \'throw\', error);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/call-with-safe-iteration-closing.js?')},"./node_modules/core-js/internals/check-correctness-of-iteration.js":function node_modulesCoreJsInternalsCheckCorrectnessOfIterationJs(module,exports,__webpack_require__){eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/check-correctness-of-iteration.js?")},"./node_modules/core-js/internals/classof-raw.js":function node_modulesCoreJsInternalsClassofRawJs(module,exports,__webpack_require__){eval("var uncurryThisRaw = __webpack_require__(/*! ../internals/function-uncurry-this-raw */ \"./node_modules/core-js/internals/function-uncurry-this-raw.js\");\n\nvar toString = uncurryThisRaw({}.toString);\nvar stringSlice = uncurryThisRaw(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/classof-raw.js?")},"./node_modules/core-js/internals/classof.js":function node_modulesCoreJsInternalsClassofJs(module,exports,__webpack_require__){eval("var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/classof.js?")},"./node_modules/core-js/internals/collection-strong.js":function node_modulesCoreJsInternalsCollectionStrongJs(module,exports,__webpack_require__){eval('\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");\nvar setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fastKey = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey;\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS) that.size = 0;\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== \'F\') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== \'F\') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    defineBuiltIns(Prototype, {\n      // `{ Map, Set }.prototype.clear()` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.clear\n      // https://tc39.es/ecma262/#sec-set.prototype.clear\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS) state.size = 0;\n        else that.size = 0;\n      },\n      // `{ Map, Set }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.delete\n      // https://tc39.es/ecma262/#sec-set.prototype.delete\n      \'delete\': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.foreach\n      // https://tc39.es/ecma262/#sec-set.prototype.foreach\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // `{ Map, Set}.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.has\n      // https://tc39.es/ecma262/#sec-set.prototype.has\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    defineBuiltIns(Prototype, IS_MAP ? {\n      // `Map.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.get\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // `Map.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.set\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // `Set.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-set.prototype.add\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS) defineProperty(Prototype, \'size\', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return Constructor;\n  },\n  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + \' Iterator\';\n    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods\n    // https://tc39.es/ecma262/#sec-map.prototype.entries\n    // https://tc39.es/ecma262/#sec-map.prototype.keys\n    // https://tc39.es/ecma262/#sec-map.prototype.values\n    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator\n    // https://tc39.es/ecma262/#sec-set.prototype.entries\n    // https://tc39.es/ecma262/#sec-set.prototype.keys\n    // https://tc39.es/ecma262/#sec-set.prototype.values\n    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator\n    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return createIterResultObject(undefined, true);\n      }\n      // return step by kind\n      if (kind == \'keys\') return createIterResultObject(entry.key, false);\n      if (kind == \'values\') return createIterResultObject(entry.value, false);\n      return createIterResultObject([entry.key, entry.value], false);\n    }, IS_MAP ? \'entries\' : \'values\', !IS_MAP, true);\n\n    // `{ Map, Set }.prototype[@@species]` accessors\n    // https://tc39.es/ecma262/#sec-get-map-@@species\n    // https://tc39.es/ecma262/#sec-get-set-@@species\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection-strong.js?')},"./node_modules/core-js/internals/collection-weak.js":function node_modulesCoreJsInternalsCollectionWeakJs(module,exports,__webpack_require__){eval('\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar getWeakData = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData;\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar splice = uncurryThis([].splice);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (store) {\n  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.entries.push([key, value]);\n  },\n  \'delete\': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) splice(this.entries, index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id++,\n        frozen: undefined\n      });\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);\n      else data[state.id] = value;\n      return that;\n    };\n\n    defineBuiltIns(Prototype, {\n      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n      \'delete\': function (key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)[\'delete\'](key);\n        return data && hasOwn(data, state.id) && delete data[state.id];\n      },\n      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n      has: function has(key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && hasOwn(data, state.id);\n      }\n    });\n\n    defineBuiltIns(Prototype, IS_MAP ? {\n      // `WeakMap.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n      get: function get(key) {\n        var state = getInternalState(this);\n        if (isObject(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // `WeakMap.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // `WeakSet.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n\n    return Constructor;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection-weak.js?')},"./node_modules/core-js/internals/collection.js":function node_modulesCoreJsInternalsCollectionJs(module,exports,__webpack_require__){eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");\nvar iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");\nvar anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");\n\nmodule.exports = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf(\'Map\') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf(\'Weak\') !== -1;\n  var ADDER = IS_MAP ? \'set\' : \'add\';\n  var NativeConstructor = global[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var Constructor = NativeConstructor;\n  var exported = {};\n\n  var fixMethod = function (KEY) {\n    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);\n    defineBuiltIn(NativePrototype, KEY,\n      KEY == \'add\' ? function add(value) {\n        uncurriedNativeMethod(this, value === 0 ? 0 : value);\n        return this;\n      } : KEY == \'delete\' ? function (key) {\n        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : KEY == \'get\' ? function get(key) {\n        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : KEY == \'has\' ? function has(key) {\n        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n      } : function set(key, value) {\n        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);\n        return this;\n      }\n    );\n  };\n\n  var REPLACE = isForced(\n    CONSTRUCTOR_NAME,\n    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n      new NativeConstructor().entries().next();\n    }))\n  );\n\n  if (REPLACE) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule.enable();\n  } else if (isForced(CONSTRUCTOR_NAME, true)) {\n    var instance = new Constructor();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn\'t supports iterables, most modern - not close it correctly\n    // eslint-disable-next-line no-new -- required for testing\n    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new NativeConstructor();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n\n    if (!ACCEPT_ITERABLES) {\n      Constructor = wrapper(function (dummy, iterable) {\n        anInstance(dummy, NativePrototype);\n        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n        return that;\n      });\n      Constructor.prototype = NativePrototype;\n      NativePrototype.constructor = Constructor;\n    }\n\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod(\'delete\');\n      fixMethod(\'has\');\n      IS_MAP && fixMethod(\'get\');\n    }\n\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n    // weak collections should not contains .clear method\n    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n  }\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/collection.js?')},"./node_modules/core-js/internals/copy-constructor-properties.js":function node_modulesCoreJsInternalsCopyConstructorPropertiesJs(module,exports,__webpack_require__){eval('var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/copy-constructor-properties.js?')},"./node_modules/core-js/internals/correct-prototype-getter.js":function node_modulesCoreJsInternalsCorrectPrototypeGetterJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/correct-prototype-getter.js?')},"./node_modules/core-js/internals/create-iter-result-object.js":function node_modulesCoreJsInternalsCreateIterResultObjectJs(module,exports){eval("// `CreateIterResultObject` abstract operation\n// https://tc39.es/ecma262/#sec-createiterresultobject\nmodule.exports = function (value, done) {\n  return { value: value, done: done };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-iter-result-object.js?")},"./node_modules/core-js/internals/create-non-enumerable-property.js":function node_modulesCoreJsInternalsCreateNonEnumerablePropertyJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-non-enumerable-property.js?')},"./node_modules/core-js/internals/create-property-descriptor.js":function node_modulesCoreJsInternalsCreatePropertyDescriptorJs(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-property-descriptor.js?")},"./node_modules/core-js/internals/create-property.js":function node_modulesCoreJsInternalsCreatePropertyJs(module,exports,__webpack_require__){eval('\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-property.js?')},"./node_modules/core-js/internals/define-built-in.js":function node_modulesCoreJsInternalsDefineBuiltInJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-built-in.js?')},"./node_modules/core-js/internals/define-built-ins.js":function node_modulesCoreJsInternalsDefineBuiltInsJs(module,exports,__webpack_require__){eval('var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\n\nmodule.exports = function (target, src, options) {\n  for (var key in src) defineBuiltIn(target, key, src[key], options);\n  return target;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-built-ins.js?')},"./node_modules/core-js/internals/define-global-property.js":function node_modulesCoreJsInternalsDefineGlobalPropertyJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-global-property.js?')},"./node_modules/core-js/internals/descriptors.js":function node_modulesCoreJsInternalsDescriptorsJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Detect IE8\'s incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/descriptors.js?')},"./node_modules/core-js/internals/document-all.js":function node_modulesCoreJsInternalsDocumentAllJs(module,exports){eval("var documentAll = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;\n\nmodule.exports = {\n  all: documentAll,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/document-all.js?")},"./node_modules/core-js/internals/document-create-element.js":function node_modulesCoreJsInternalsDocumentCreateElementJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/document-create-element.js?')},"./node_modules/core-js/internals/engine-user-agent.js":function node_modulesCoreJsInternalsEngineUserAgentJs(module,exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/engine-user-agent.js?")},"./node_modules/core-js/internals/engine-v8-version.js":function node_modulesCoreJsInternalsEngineV8VersionJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split(\'.\');\n  // in old Chrome, versions of V8 isn\'t V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/engine-v8-version.js?')},"./node_modules/core-js/internals/enum-bug-keys.js":function node_modulesCoreJsInternalsEnumBugKeysJs(module,exports){eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/enum-bug-keys.js?")},"./node_modules/core-js/internals/export.js":function node_modulesCoreJsInternalsExportJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, \'sham\', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/export.js?')},"./node_modules/core-js/internals/fails.js":function node_modulesCoreJsInternalsFailsJs(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/fails.js?")},"./node_modules/core-js/internals/freezing.js":function node_modulesCoreJsInternalsFreezingJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/freezing.js?')},"./node_modules/core-js/internals/function-bind-context.js":function node_modulesCoreJsInternalsFunctionBindContextJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar bind = uncurryThis(uncurryThis.bind);\n\n// optional / simple context binding\nmodule.exports = function (fn, that) {\n  aCallable(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-bind-context.js?')},"./node_modules/core-js/internals/function-bind-native.js":function node_modulesCoreJsInternalsFunctionBindNativeJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-bind-native.js?")},"./node_modules/core-js/internals/function-call.js":function node_modulesCoreJsInternalsFunctionCallJs(module,exports,__webpack_require__){eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-call.js?')},"./node_modules/core-js/internals/function-name.js":function node_modulesCoreJsInternalsFunctionNameJs(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-name.js?")},"./node_modules/core-js/internals/function-uncurry-this-raw.js":function node_modulesCoreJsInternalsFunctionUncurryThisRawJs(module,exports,__webpack_require__){eval('var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-uncurry-this-raw.js?')},"./node_modules/core-js/internals/function-uncurry-this.js":function node_modulesCoreJsInternalsFunctionUncurryThisJs(module,exports,__webpack_require__){eval('var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar uncurryThisRaw = __webpack_require__(/*! ../internals/function-uncurry-this-raw */ "./node_modules/core-js/internals/function-uncurry-this-raw.js");\n\nmodule.exports = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw(fn) === \'Function\') return uncurryThisRaw(fn);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-uncurry-this.js?')},"./node_modules/core-js/internals/get-built-in.js":function node_modulesCoreJsInternalsGetBuiltInJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-built-in.js?')},"./node_modules/core-js/internals/get-iterator-method.js":function node_modulesCoreJsInternalsGetIteratorMethodJs(module,exports,__webpack_require__){eval('var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\n\nmodule.exports = function (it) {\n  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)\n    || getMethod(it, \'@@iterator\')\n    || Iterators[classof(it)];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-iterator-method.js?')},"./node_modules/core-js/internals/get-iterator.js":function node_modulesCoreJsInternalsGetIteratorJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n  throw $TypeError(tryToString(argument) + \' is not iterable\');\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-iterator.js?')},"./node_modules/core-js/internals/get-method.js":function node_modulesCoreJsInternalsGetMethodJs(module,exports,__webpack_require__){eval('var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-method.js?')},"./node_modules/core-js/internals/global.js":function node_modulesCoreJsInternalsGlobalJs(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/global.js?")},"./node_modules/core-js/internals/has-own-property.js":function node_modulesCoreJsInternalsHasOwnPropertyJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/has-own-property.js?')},"./node_modules/core-js/internals/hidden-keys.js":function node_modulesCoreJsInternalsHiddenKeysJs(module,exports){eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/hidden-keys.js?")},"./node_modules/core-js/internals/html.js":function node_modulesCoreJsInternalsHtmlJs(module,exports,__webpack_require__){eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/html.js?")},"./node_modules/core-js/internals/ie8-dom-define.js":function node_modulesCoreJsInternalsIe8DomDefineJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/ie8-dom-define.js?')},"./node_modules/core-js/internals/indexed-object.js":function node_modulesCoreJsInternalsIndexedObjectJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/indexed-object.js?")},"./node_modules/core-js/internals/inherit-if-required.js":function node_modulesCoreJsInternalsInheritIfRequiredJs(module,exports,__webpack_require__){eval('var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven\'t completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/inherit-if-required.js?')},"./node_modules/core-js/internals/inspect-source.js":function node_modulesCoreJsInternalsInspectSourceJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can\'t use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/inspect-source.js?')},"./node_modules/core-js/internals/internal-metadata.js":function node_modulesCoreJsInternalsInternalMetadataJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");\nvar isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");\n\nvar REQUIRED = false;\nvar METADATA = uid(\'meta\');\nvar id = 0;\n\nvar setMetadata = function (it) {\n  defineProperty(it, METADATA, { value: {\n    objectID: \'O\' + id++, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject(it)) return typeof it == \'symbol\' ? it : (typeof it == \'string\' ? \'S\' : \'P\') + it;\n  if (!hasOwn(it, METADATA)) {\n    // can\'t set metadata to uncaught frozen object\n    if (!isExtensible(it)) return \'F\';\n    // not necessary to add metadata\n    if (!create) return \'E\';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData = function (it, create) {\n  if (!hasOwn(it, METADATA)) {\n    // can\'t set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar enable = function () {\n  meta.enable = function () { /* empty */ };\n  REQUIRED = true;\n  var getOwnPropertyNames = getOwnPropertyNamesModule.f;\n  var splice = uncurryThis([].splice);\n  var test = {};\n  test[METADATA] = 1;\n\n  // prevent exposing of metadata key\n  if (getOwnPropertyNames(test).length) {\n    getOwnPropertyNamesModule.f = function (it) {\n      var result = getOwnPropertyNames(it);\n      for (var i = 0, length = result.length; i < length; i++) {\n        if (result[i] === METADATA) {\n          splice(result, i, 1);\n          break;\n        }\n      } return result;\n    };\n\n    $({ target: \'Object\', stat: true, forced: true }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f\n    });\n  }\n};\n\nvar meta = module.exports = {\n  enable: enable,\n  fastKey: fastKey,\n  getWeakData: getWeakData,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/internal-metadata.js?')},"./node_modules/core-js/internals/internal-state.js":function node_modulesCoreJsInternalsInternalStateJs(module,exports,__webpack_require__){eval('var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar OBJECT_ALREADY_INITIALIZED = \'Object already initialized\';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/internal-state.js?')},"./node_modules/core-js/internals/is-array-iterator-method.js":function node_modulesCoreJsInternalsIsArrayIteratorMethodJs(module,exports,__webpack_require__){eval('var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-array-iterator-method.js?')},"./node_modules/core-js/internals/is-array.js":function node_modulesCoreJsInternalsIsArrayJs(module,exports,__webpack_require__){eval("var classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-array.js?")},"./node_modules/core-js/internals/is-callable.js":function node_modulesCoreJsInternalsIsCallableJs(module,exports,__webpack_require__){eval("var $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = $documentAll.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-callable.js?")},"./node_modules/core-js/internals/is-constructor.js":function node_modulesCoreJsInternalsIsConstructorJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nmodule.exports = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-constructor.js?")},"./node_modules/core-js/internals/is-forced.js":function node_modulesCoreJsInternalsIsForcedJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-forced.js?")},"./node_modules/core-js/internals/is-null-or-undefined.js":function node_modulesCoreJsInternalsIsNullOrUndefinedJs(module,exports){eval("// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-null-or-undefined.js?")},"./node_modules/core-js/internals/is-object.js":function node_modulesCoreJsInternalsIsObjectJs(module,exports,__webpack_require__){eval("var isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar $documentAll = __webpack_require__(/*! ../internals/document-all */ \"./node_modules/core-js/internals/document-all.js\");\n\nvar documentAll = $documentAll.all;\n\nmodule.exports = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-object.js?")},"./node_modules/core-js/internals/is-pure.js":function node_modulesCoreJsInternalsIsPureJs(module,exports){eval("module.exports = false;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-pure.js?")},"./node_modules/core-js/internals/is-symbol.js":function node_modulesCoreJsInternalsIsSymbolJs(module,exports,__webpack_require__){eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == \'symbol\';\n} : function (it) {\n  var $Symbol = getBuiltIn(\'Symbol\');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-symbol.js?')},"./node_modules/core-js/internals/iterate.js":function node_modulesCoreJsInternalsIterateJs(module,exports,__webpack_require__){eval('var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");\nvar getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\nvar iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");\n\nvar $TypeError = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nmodule.exports = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_RECORD = !!(options && options.IS_RECORD);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, \'normal\', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_RECORD) {\n    iterator = iterable.iterator;\n  } else if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw $TypeError(tryToString(iterable) + \' is not iterable\');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = IS_RECORD ? iterable.next : iterator.next;\n  while (!(step = call(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, \'throw\', error);\n    }\n    if (typeof result == \'object\' && result && isPrototypeOf(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterate.js?')},"./node_modules/core-js/internals/iterator-close.js":function node_modulesCoreJsInternalsIteratorCloseJs(module,exports,__webpack_require__){eval("var call = __webpack_require__(/*! ../internals/function-call */ \"./node_modules/core-js/internals/function-call.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ \"./node_modules/core-js/internals/get-method.js\");\n\nmodule.exports = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject(innerResult);\n  return value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-close.js?")},"./node_modules/core-js/internals/iterator-create-constructor.js":function node_modulesCoreJsInternalsIteratorCreateConstructorJs(module,exports,__webpack_require__){eval('\nvar IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-create-constructor.js?')},"./node_modules/core-js/internals/iterator-define.js":function node_modulesCoreJsInternalsIteratorDefineJs(module,exports,__webpack_require__){eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\nvar FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar KEYS = \'keys\';\nvar VALUES = \'values\';\nvar ENTRIES = \'entries\';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype[\'@@iterator\']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \'Array\' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {\n          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty(IterablePrototype, \'name\', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });\n  }\n  Iterators[NAME] = defaultIterator;\n\n  return methods;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterator-define.js?')},"./node_modules/core-js/internals/iterators-core.js":function node_modulesCoreJsInternalsIteratorsCoreJs(module,exports,__webpack_require__){eval('\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar BUGGY_SAFARI_ITERATORS = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!(\'next\' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype[ITERATOR].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\nelse if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable(IteratorPrototype[ITERATOR])) {\n  defineBuiltIn(IteratorPrototype, ITERATOR, function () {\n    return this;\n  });\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators-core.js?')},"./node_modules/core-js/internals/iterators.js":function node_modulesCoreJsInternalsIteratorsJs(module,exports){eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators.js?")},"./node_modules/core-js/internals/length-of-array-like.js":function node_modulesCoreJsInternalsLengthOfArrayLikeJs(module,exports,__webpack_require__){eval('var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/length-of-array-like.js?')},"./node_modules/core-js/internals/make-built-in.js":function node_modulesCoreJsInternalsMakeBuiltInJs(module,exports,__webpack_require__){eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar CONFIGURABLE_FUNCTION_NAME = __webpack_require__(/*! ../internals/function-name */ \"./node_modules/core-js/internals/function-name.js\").CONFIGURABLE;\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/make-built-in.js?")},"./node_modules/core-js/internals/math-trunc.js":function node_modulesCoreJsInternalsMathTruncJs(module,exports){eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/math-trunc.js?")},"./node_modules/core-js/internals/object-assign.js":function node_modulesCoreJsInternalsObjectAssignJs(module,exports,__webpack_require__){eval('\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, \'a\', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, \'b\', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = \'abcdefghijklmnopqrst\';\n  A[symbol] = 7;\n  alphabet.split(\'\').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\'\') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-assign.js?')},"./node_modules/core-js/internals/object-create.js":function node_modulesCoreJsInternalsObjectCreateJs(module,exports,__webpack_require__){eval("/* global ActiveXObject -- old IE, WSH */\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\nvar html = __webpack_require__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-create.js?")},"./node_modules/core-js/internals/object-define-properties.js":function node_modulesCoreJsInternalsObjectDefinePropertiesJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nexports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var props = toIndexedObject(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-properties.js?')},"./node_modules/core-js/internals/object-define-property.js":function node_modulesCoreJsInternalsObjectDefinePropertyJs(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ \"./node_modules/core-js/internals/v8-prototype-define-bug.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-property.js?")},"./node_modules/core-js/internals/object-get-own-property-descriptor.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyDescriptorJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-descriptor.js?')},"./node_modules/core-js/internals/object-get-own-property-names-external.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesExternalJs(module,exports,__webpack_require__){eval('/* eslint-disable es/no-object-getownpropertynames -- safe */\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar $getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;\nvar arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");\n\nvar windowNames = typeof window == \'object\' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return $getOwnPropertyNames(it);\n  } catch (error) {\n    return arraySlice(windowNames);\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && classof(it) == \'Window\'\n    ? getWindowNames(it)\n    : $getOwnPropertyNames(toIndexedObject(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-names-external.js?')},"./node_modules/core-js/internals/object-get-own-property-names.js":function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesJs(module,exports,__webpack_require__){eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-names.js?")},"./node_modules/core-js/internals/object-get-own-property-symbols.js":function node_modulesCoreJsInternalsObjectGetOwnPropertySymbolsJs(module,exports){eval("// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-symbols.js?")},"./node_modules/core-js/internals/object-get-prototype-of.js":function node_modulesCoreJsInternalsObjectGetPrototypeOfJs(module,exports,__webpack_require__){eval('var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");\n\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype : null;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-prototype-of.js?')},"./node_modules/core-js/internals/object-is-extensible.js":function node_modulesCoreJsInternalsObjectIsExtensibleJs(module,exports,__webpack_require__){eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");\n\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar $isExtensible = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });\n\n// `Object.isExtensible` method\n// https://tc39.es/ecma262/#sec-object.isextensible\nmodule.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {\n  if (!isObject(it)) return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == \'ArrayBuffer\') return false;\n  return $isExtensible ? $isExtensible(it) : true;\n} : $isExtensible;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-is-extensible.js?')},"./node_modules/core-js/internals/object-is-prototype-of.js":function node_modulesCoreJsInternalsObjectIsPrototypeOfJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-is-prototype-of.js?')},"./node_modules/core-js/internals/object-keys-internal.js":function node_modulesCoreJsInternalsObjectKeysInternalJs(module,exports,__webpack_require__){eval('var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys-internal.js?')},"./node_modules/core-js/internals/object-keys.js":function node_modulesCoreJsInternalsObjectKeysJs(module,exports,__webpack_require__){eval('var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys.js?')},"./node_modules/core-js/internals/object-property-is-enumerable.js":function node_modulesCoreJsInternalsObjectPropertyIsEnumerableJs(module,exports,__webpack_require__){eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-property-is-enumerable.js?")},"./node_modules/core-js/internals/object-set-prototype-of.js":function node_modulesCoreJsInternalsObjectSetPrototypeOfJs(module,exports,__webpack_require__){eval('/* eslint-disable no-proto -- safe */\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || (\'__proto__\' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, \'__proto__\').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-set-prototype-of.js?')},"./node_modules/core-js/internals/object-to-string.js":function node_modulesCoreJsInternalsObjectToStringJs(module,exports,__webpack_require__){eval("\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-to-string.js?")},"./node_modules/core-js/internals/ordinary-to-primitive.js":function node_modulesCoreJsInternalsOrdinaryToPrimitiveJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== \'string\' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw $TypeError("Can\'t convert object to primitive value");\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/ordinary-to-primitive.js?')},"./node_modules/core-js/internals/own-keys.js":function node_modulesCoreJsInternalsOwnKeysJs(module,exports,__webpack_require__){eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn(\'Reflect\', \'ownKeys\') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/own-keys.js?')},"./node_modules/core-js/internals/path.js":function node_modulesCoreJsInternalsPathJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nmodule.exports = global;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/path.js?')},"./node_modules/core-js/internals/require-object-coercible.js":function node_modulesCoreJsInternalsRequireObjectCoercibleJs(module,exports,__webpack_require__){eval('var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw $TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/require-object-coercible.js?')},"./node_modules/core-js/internals/set-species.js":function node_modulesCoreJsInternalsSetSpeciesJs(module,exports,__webpack_require__){eval('\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\n\nvar SPECIES = wellKnownSymbol(\'species\');\n\nmodule.exports = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n    defineProperty(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-species.js?')},"./node_modules/core-js/internals/set-to-string-tag.js":function node_modulesCoreJsInternalsSetToStringTagJs(module,exports,__webpack_require__){eval('var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n\nmodule.exports = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn(target, TO_STRING_TAG)) {\n    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-to-string-tag.js?')},"./node_modules/core-js/internals/shared-key.js":function node_modulesCoreJsInternalsSharedKeyJs(module,exports,__webpack_require__){eval('var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared-key.js?')},"./node_modules/core-js/internals/shared-store.js":function node_modulesCoreJsInternalsSharedStoreJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared-store.js?')},"./node_modules/core-js/internals/shared.js":function node_modulesCoreJsInternalsSharedJs(module,exports,__webpack_require__){eval("var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.26.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared.js?")},"./node_modules/core-js/internals/string-multibyte.js":function node_modulesCoreJsInternalsStringMultibyteJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\nvar toString = __webpack_require__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\nvar charAt = uncurryThis(''.charAt);\nvar charCodeAt = uncurryThis(''.charCodeAt);\nvar stringSlice = uncurryThis(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString(requireObjectCoercible($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/string-multibyte.js?")},"./node_modules/core-js/internals/symbol-constructor-detection.js":function node_modulesCoreJsInternalsSymbolConstructorDetectionJs(module,exports,__webpack_require__){eval('/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/symbol-constructor-detection.js?')},"./node_modules/core-js/internals/to-absolute-index.js":function node_modulesCoreJsInternalsToAbsoluteIndexJs(module,exports,__webpack_require__){eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-absolute-index.js?')},"./node_modules/core-js/internals/to-indexed-object.js":function node_modulesCoreJsInternalsToIndexedObjectJs(module,exports,__webpack_require__){eval('// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-indexed-object.js?')},"./node_modules/core-js/internals/to-integer-or-infinity.js":function node_modulesCoreJsInternalsToIntegerOrInfinityJs(module,exports,__webpack_require__){eval('var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-integer-or-infinity.js?')},"./node_modules/core-js/internals/to-length.js":function node_modulesCoreJsInternalsToLengthJs(module,exports,__webpack_require__){eval('var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-length.js?')},"./node_modules/core-js/internals/to-object.js":function node_modulesCoreJsInternalsToObjectJs(module,exports,__webpack_require__){eval('var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-object.js?')},"./node_modules/core-js/internals/to-primitive.js":function node_modulesCoreJsInternalsToPrimitiveJs(module,exports,__webpack_require__){eval('var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");\nvar ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol(\'toPrimitive\');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = \'default\';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw $TypeError("Can\'t convert object to primitive value");\n  }\n  if (pref === undefined) pref = \'number\';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-primitive.js?')},"./node_modules/core-js/internals/to-property-key.js":function node_modulesCoreJsInternalsToPropertyKeyJs(module,exports,__webpack_require__){eval("var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-property-key.js?")},"./node_modules/core-js/internals/to-string-tag-support.js":function node_modulesCoreJsInternalsToStringTagSupportJs(module,exports,__webpack_require__){eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-string-tag-support.js?")},"./node_modules/core-js/internals/to-string.js":function node_modulesCoreJsInternalsToStringJs(module,exports,__webpack_require__){eval("var classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\nvar $String = String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-string.js?")},"./node_modules/core-js/internals/try-to-string.js":function node_modulesCoreJsInternalsTryToStringJs(module,exports){eval("var $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/try-to-string.js?")},"./node_modules/core-js/internals/uid.js":function node_modulesCoreJsInternalsUidJs(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/uid.js?")},"./node_modules/core-js/internals/use-symbol-as-uid.js":function node_modulesCoreJsInternalsUseSymbolAsUidJs(module,exports,__webpack_require__){eval("/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ \"./node_modules/core-js/internals/symbol-constructor-detection.js\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/use-symbol-as-uid.js?")},"./node_modules/core-js/internals/v8-prototype-define-bug.js":function node_modulesCoreJsInternalsV8PrototypeDefineBugJs(module,exports,__webpack_require__){eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, \'prototype\', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/v8-prototype-define-bug.js?')},"./node_modules/core-js/internals/weak-map-basic-detection.js":function node_modulesCoreJsInternalsWeakMapBasicDetectionJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/weak-map-basic-detection.js?')},"./node_modules/core-js/internals/well-known-symbol.js":function node_modulesCoreJsInternalsWellKnownSymbolJs(module,exports,__webpack_require__){eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar WellKnownSymbolsStore = shared(\'wks\');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol[\'for\'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \'string\')) {\n    var description = \'Symbol.\' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/well-known-symbol.js?')},"./node_modules/core-js/modules/es.array.from.js":function node_modulesCoreJsModulesEsArrayFromJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$({ target: \'Array\', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.array.from.js?')},"./node_modules/core-js/modules/es.array.iterator.js":function node_modulesCoreJsModulesEsArrayIteratorJs(module,exports,__webpack_require__){eval("\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ \"./node_modules/core-js/internals/iterator-define.js\");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ \"./node_modules/core-js/internals/create-iter-result-object.js\");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return createIterResultObject(undefined, true);\n  }\n  if (kind == 'keys') return createIterResultObject(index, false);\n  if (kind == 'values') return createIterResultObject(target[index], false);\n  return createIterResultObject([index, target[index]], false);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n// V8 ~ Chrome 45- bug\nif (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {\n  defineProperty(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.array.iterator.js?")},"./node_modules/core-js/modules/es.map.constructor.js":function node_modulesCoreJsModulesEsMapConstructorJs(module,exports,__webpack_require__){eval('\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");\n\n// `Map` constructor\n// https://tc39.es/ecma262/#sec-map-objects\ncollection(\'Map\', function (init) {\n  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.map.constructor.js?')},"./node_modules/core-js/modules/es.map.js":function node_modulesCoreJsModulesEsMapJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.map.constructor */ "./node_modules/core-js/modules/es.map.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.map.js?')},"./node_modules/core-js/modules/es.object.assign.js":function node_modulesCoreJsModulesEsObjectAssignJs(module,exports,__webpack_require__){eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: \'Object\', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.object.assign.js?')},"./node_modules/core-js/modules/es.object.to-string.js":function node_modulesCoreJsModulesEsObjectToStringJs(module,exports,__webpack_require__){eval('var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");\nvar toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");\n\n// `Object.prototype.toString` method\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nif (!TO_STRING_TAG_SUPPORT) {\n  defineBuiltIn(Object.prototype, \'toString\', toString, { unsafe: true });\n}\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.object.to-string.js?')},"./node_modules/core-js/modules/es.set.constructor.js":function node_modulesCoreJsModulesEsSetConstructorJs(module,exports,__webpack_require__){eval('\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");\n\n// `Set` constructor\n// https://tc39.es/ecma262/#sec-set-objects\ncollection(\'Set\', function (init) {\n  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.set.constructor.js?')},"./node_modules/core-js/modules/es.set.js":function node_modulesCoreJsModulesEsSetJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.set.constructor */ "./node_modules/core-js/modules/es.set.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.set.js?')},"./node_modules/core-js/modules/es.string.iterator.js":function node_modulesCoreJsModulesEsStringIteratorJs(module,exports,__webpack_require__){eval('\nvar charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;\nvar toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\nvar defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");\nvar createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");\n\nvar STRING_ITERATOR = \'String Iterator\';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, \'String\', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: toString(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return createIterResultObject(undefined, true);\n  point = charAt(string, index);\n  state.index += point.length;\n  return createIterResultObject(point, false);\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.string.iterator.js?')},"./node_modules/core-js/modules/es.weak-map.constructor.js":function node_modulesCoreJsModulesEsWeakMapConstructorJs(module,exports,__webpack_require__){eval('\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");\nvar defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");\nvar InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");\nvar collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");\nvar collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");\nvar enforceInternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce;\nvar NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");\n\nvar IS_IE11 = !global.ActiveXObject && \'ActiveXObject\' in global;\nvar InternalWeakMap;\n\nvar wrapper = function (init) {\n  return function WeakMap() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n};\n\n// `WeakMap` constructor\n// https://tc39.es/ecma262/#sec-weakmap-constructor\nvar $WeakMap = collection(\'WeakMap\', wrapper, collectionWeak);\n\n// IE11 WeakMap frozen keys fix\n// We can\'t use feature detection because it crash some old IE builds\n// https://github.com/zloirock/core-js/issues/485\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, \'WeakMap\', true);\n  InternalMetadataModule.enable();\n  var WeakMapPrototype = $WeakMap.prototype;\n  var nativeDelete = uncurryThis(WeakMapPrototype[\'delete\']);\n  var nativeHas = uncurryThis(WeakMapPrototype.has);\n  var nativeGet = uncurryThis(WeakMapPrototype.get);\n  var nativeSet = uncurryThis(WeakMapPrototype.set);\n  defineBuiltIns(WeakMapPrototype, {\n    \'delete\': function (key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeDelete(this, key) || state.frozen[\'delete\'](key);\n      } return nativeDelete(this, key);\n    },\n    has: function has(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) || state.frozen.has(key);\n      } return nativeHas(this, key);\n    },\n    get: function get(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n      } return nativeGet(this, key);\n    },\n    set: function set(key, value) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n      } else nativeSet(this, key, value);\n      return this;\n    }\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.weak-map.constructor.js?')},"./node_modules/core-js/modules/es.weak-map.js":function node_modulesCoreJsModulesEsWeakMapJs(module,exports,__webpack_require__){eval('// TODO: Remove this module from `core-js@4` since it\'s replaced to module below\n__webpack_require__(/*! ../modules/es.weak-map.constructor */ "./node_modules/core-js/modules/es.weak-map.constructor.js");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.weak-map.js?')},"./node_modules/lodash.clamp/index.js":function node_modulesLodashClampIndexJs(module,exports){eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n\n\n//# sourceURL=webpack:///./node_modules/lodash.clamp/index.js?")},"./node_modules/lodash.debounce/index.js":function node_modulesLodashDebounceIndexJs(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/lodash.debounce/index.js?")},"./node_modules/smooth-scrollbar/decorators/boolean.js":function node_modulesSmoothScrollbarDecoratorsBooleanJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boolean", function() { return boolean; });\nfunction boolean(proto, key) {\n    var alias = "_" + key;\n    Object.defineProperty(proto, key, {\n        get: function () {\n            return this[alias];\n        },\n        set: function (val) {\n            Object.defineProperty(this, alias, {\n                value: !!val,\n                enumerable: false,\n                writable: true,\n                configurable: true,\n            });\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n//# sourceMappingURL=boolean.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/boolean.js?')},"./node_modules/smooth-scrollbar/decorators/debounce.js":function node_modulesSmoothScrollbarDecoratorsDebounceJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction debounce() {\n    var options = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        options[_i] = arguments[_i];\n    }\n    return function (_proto, key, descriptor) {\n        var fn = descriptor.value;\n        return {\n            get: function () {\n                if (!this.hasOwnProperty(key)) {\n                    Object.defineProperty(this, key, {\n                        value: lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default.a.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])([fn], options)),\n                    });\n                }\n                return this[key];\n            },\n        };\n    };\n}\n//# sourceMappingURL=debounce.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/debounce.js?')},"./node_modules/smooth-scrollbar/decorators/index.js":function node_modulesSmoothScrollbarDecoratorsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./range */ "./node_modules/smooth-scrollbar/decorators/range.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_0__["range"]; });\n\n/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boolean */ "./node_modules/smooth-scrollbar/decorators/boolean.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "boolean", function() { return _boolean__WEBPACK_IMPORTED_MODULE_1__["boolean"]; });\n\n/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce */ "./node_modules/smooth-scrollbar/decorators/debounce.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _debounce__WEBPACK_IMPORTED_MODULE_2__["debounce"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/index.js?')},"./node_modules/smooth-scrollbar/decorators/range.js":function node_modulesSmoothScrollbarDecoratorsRangeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction range(min, max) {\n    if (min === void 0) { min = -Infinity; }\n    if (max === void 0) { max = Infinity; }\n    return function (proto, key) {\n        var alias = "_" + key;\n        Object.defineProperty(proto, key, {\n            get: function () {\n                return this[alias];\n            },\n            set: function (val) {\n                Object.defineProperty(this, alias, {\n                    value: lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(val, min, max),\n                    enumerable: false,\n                    writable: true,\n                    configurable: true,\n                });\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/decorators/range.js?')},"./node_modules/smooth-scrollbar/events/index.js":function node_modulesSmoothScrollbarEventsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyboard */ "./node_modules/smooth-scrollbar/events/keyboard.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keyboardHandler", function() { return _keyboard__WEBPACK_IMPORTED_MODULE_0__["keyboardHandler"]; });\n\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouse */ "./node_modules/smooth-scrollbar/events/mouse.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouseHandler", function() { return _mouse__WEBPACK_IMPORTED_MODULE_1__["mouseHandler"]; });\n\n/* harmony import */ var _resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resize */ "./node_modules/smooth-scrollbar/events/resize.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeHandler", function() { return _resize__WEBPACK_IMPORTED_MODULE_2__["resizeHandler"]; });\n\n/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./select */ "./node_modules/smooth-scrollbar/events/select.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectHandler", function() { return _select__WEBPACK_IMPORTED_MODULE_3__["selectHandler"]; });\n\n/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./touch */ "./node_modules/smooth-scrollbar/events/touch.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touchHandler", function() { return _touch__WEBPACK_IMPORTED_MODULE_4__["touchHandler"]; });\n\n/* harmony import */ var _wheel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wheel */ "./node_modules/smooth-scrollbar/events/wheel.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wheelHandler", function() { return _wheel__WEBPACK_IMPORTED_MODULE_5__["wheelHandler"]; });\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/index.js?')},"./node_modules/smooth-scrollbar/events/keyboard.js":function node_modulesSmoothScrollbarEventsKeyboardJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyboardHandler", function() { return keyboardHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\nvar KEY_CODE;\n(function (KEY_CODE) {\n    KEY_CODE[KEY_CODE["TAB"] = 9] = "TAB";\n    KEY_CODE[KEY_CODE["SPACE"] = 32] = "SPACE";\n    KEY_CODE[KEY_CODE["PAGE_UP"] = 33] = "PAGE_UP";\n    KEY_CODE[KEY_CODE["PAGE_DOWN"] = 34] = "PAGE_DOWN";\n    KEY_CODE[KEY_CODE["END"] = 35] = "END";\n    KEY_CODE[KEY_CODE["HOME"] = 36] = "HOME";\n    KEY_CODE[KEY_CODE["LEFT"] = 37] = "LEFT";\n    KEY_CODE[KEY_CODE["UP"] = 38] = "UP";\n    KEY_CODE[KEY_CODE["RIGHT"] = 39] = "RIGHT";\n    KEY_CODE[KEY_CODE["DOWN"] = 40] = "DOWN";\n})(KEY_CODE || (KEY_CODE = {}));\nfunction keyboardHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__["eventScope"])(scrollbar);\n    var container = scrollbar.containerEl;\n    addEvent(container, \'keydown\', function (evt) {\n        var activeElement = document.activeElement;\n        if (activeElement !== container && !container.contains(activeElement)) {\n            return;\n        }\n        if (isEditable(activeElement)) {\n            return;\n        }\n        var delta = getKeyDelta(scrollbar, evt.keyCode || evt.which);\n        if (!delta) {\n            return;\n        }\n        var x = delta[0], y = delta[1];\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll) {\n                evt.preventDefault();\n            }\n            else {\n                scrollbar.containerEl.blur();\n                if (scrollbar.parent) {\n                    scrollbar.parent.containerEl.focus();\n                }\n            }\n        });\n    });\n}\nfunction getKeyDelta(scrollbar, keyCode) {\n    var size = scrollbar.size, limit = scrollbar.limit, offset = scrollbar.offset;\n    switch (keyCode) {\n        case KEY_CODE.TAB:\n            return handleTabKey(scrollbar);\n        case KEY_CODE.SPACE:\n            return [0, 200];\n        case KEY_CODE.PAGE_UP:\n            return [0, -size.container.height + 40];\n        case KEY_CODE.PAGE_DOWN:\n            return [0, size.container.height - 40];\n        case KEY_CODE.END:\n            return [0, limit.y - offset.y];\n        case KEY_CODE.HOME:\n            return [0, -offset.y];\n        case KEY_CODE.LEFT:\n            return [-40, 0];\n        case KEY_CODE.UP:\n            return [0, -40];\n        case KEY_CODE.RIGHT:\n            return [40, 0];\n        case KEY_CODE.DOWN:\n            return [0, 40];\n        default:\n            return null;\n    }\n}\nfunction handleTabKey(scrollbar) {\n    // handle in next frame\n    requestAnimationFrame(function () {\n        scrollbar.scrollIntoView(document.activeElement, {\n            offsetTop: scrollbar.size.container.height / 2,\n            offsetLeft: scrollbar.size.container.width / 2,\n            onlyScrollIfNeeded: true,\n        });\n    });\n}\nfunction isEditable(elem) {\n    if (elem.tagName === \'INPUT\' ||\n        elem.tagName === \'SELECT\' ||\n        elem.tagName === \'TEXTAREA\' ||\n        elem.isContentEditable) {\n        return !elem.disabled;\n    }\n    return false;\n}\n//# sourceMappingURL=keyboard.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/keyboard.js?')},"./node_modules/smooth-scrollbar/events/mouse.js":function node_modulesSmoothScrollbarEventsMouseJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseHandler", function() { return mouseHandler; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar Direction;\n(function (Direction) {\n    Direction[Direction["X"] = 0] = "X";\n    Direction[Direction["Y"] = 1] = "Y";\n})(Direction || (Direction = {}));\nfunction mouseHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["eventScope"])(scrollbar);\n    var container = scrollbar.containerEl;\n    var _a = scrollbar.track, xAxis = _a.xAxis, yAxis = _a.yAxis;\n    function calcMomentum(direction, clickPosition) {\n        var size = scrollbar.size, limit = scrollbar.limit, offset = scrollbar.offset;\n        if (direction === Direction.X) {\n            var totalWidth = size.container.width + (xAxis.thumb.realSize - xAxis.thumb.displaySize);\n            return lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(clickPosition / totalWidth * size.content.width, 0, limit.x) - offset.x;\n        }\n        if (direction === Direction.Y) {\n            var totalHeight = size.container.height + (yAxis.thumb.realSize - yAxis.thumb.displaySize);\n            return lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(clickPosition / totalHeight * size.content.height, 0, limit.y) - offset.y;\n        }\n        return 0;\n    }\n    function getTrackDirection(elem) {\n        if (Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(elem, [xAxis.element, xAxis.thumb.element])) {\n            return Direction.X;\n        }\n        if (Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(elem, [yAxis.element, yAxis.thumb.element])) {\n            return Direction.Y;\n        }\n        return void 0;\n    }\n    var isMouseDown;\n    var isMouseMoving;\n    var startOffsetToThumb;\n    var trackDirection;\n    var containerRect;\n    addEvent(container, \'click\', function (evt) {\n        if (isMouseMoving || !Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(evt.target, [xAxis.element, yAxis.element])) {\n            return;\n        }\n        var track = evt.target;\n        var direction = getTrackDirection(track);\n        var rect = track.getBoundingClientRect();\n        var clickPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        if (direction === Direction.X) {\n            var offsetOnTrack = clickPos.x - rect.left - xAxis.thumb.displaySize / 2;\n            scrollbar.setMomentum(calcMomentum(direction, offsetOnTrack), 0);\n        }\n        if (direction === Direction.Y) {\n            var offsetOnTrack = clickPos.y - rect.top - yAxis.thumb.displaySize / 2;\n            scrollbar.setMomentum(0, calcMomentum(direction, offsetOnTrack));\n        }\n    });\n    addEvent(container, \'mousedown\', function (evt) {\n        if (!Object(_utils___WEBPACK_IMPORTED_MODULE_1__["isOneOf"])(evt.target, [xAxis.thumb.element, yAxis.thumb.element])) {\n            return;\n        }\n        isMouseDown = true;\n        var thumb = evt.target;\n        var cursorPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        var thumbRect = thumb.getBoundingClientRect();\n        trackDirection = getTrackDirection(thumb);\n        // pointer offset to thumb\n        startOffsetToThumb = {\n            x: cursorPos.x - thumbRect.left,\n            y: cursorPos.y - thumbRect.top,\n        };\n        // container bounding rectangle\n        containerRect = container.getBoundingClientRect();\n        // prevent selection, see:\n        // https://github.com/idiotWu/smooth-scrollbar/issues/48\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(scrollbar.containerEl, {\n            \'-user-select\': \'none\',\n        });\n    });\n    addEvent(window, \'mousemove\', function (evt) {\n        if (!isMouseDown)\n            return;\n        isMouseMoving = true;\n        var cursorPos = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["getPosition"])(evt);\n        if (trackDirection === Direction.X) {\n            // get percentage of pointer position in track\n            // then tranform to px\n            // don\'t need easing\n            var offsetOnTrack = cursorPos.x - startOffsetToThumb.x - containerRect.left;\n            scrollbar.setMomentum(calcMomentum(trackDirection, offsetOnTrack), 0);\n        }\n        if (trackDirection === Direction.Y) {\n            var offsetOnTrack = cursorPos.y - startOffsetToThumb.y - containerRect.top;\n            scrollbar.setMomentum(0, calcMomentum(trackDirection, offsetOnTrack));\n        }\n    });\n    addEvent(window, \'mouseup blur\', function () {\n        isMouseDown = isMouseMoving = false;\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(scrollbar.containerEl, {\n            \'-user-select\': \'\',\n        });\n    });\n}\n//# sourceMappingURL=mouse.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/mouse.js?')},"./node_modules/smooth-scrollbar/events/resize.js":function node_modulesSmoothScrollbarEventsResizeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeHandler", function() { return resizeHandler; });\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nfunction resizeHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__["eventScope"])(scrollbar);\n    addEvent(window, \'resize\', lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(scrollbar.update.bind(scrollbar), 300));\n}\n//# sourceMappingURL=resize.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/resize.js?')},"./node_modules/smooth-scrollbar/events/select.js":function node_modulesSmoothScrollbarEventsSelectJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectHandler\", function() { return selectHandler; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ \"./node_modules/lodash.clamp/index.js\");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ \"./node_modules/smooth-scrollbar/utils/index.js\");\n\n\nfunction selectHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_1__[\"eventScope\"])(scrollbar);\n    var containerEl = scrollbar.containerEl, contentEl = scrollbar.contentEl;\n    var isSelected = false;\n    var isContextMenuOpened = false; // flag to prevent selection when context menu is opened\n    var animationID;\n    function scroll(_a) {\n        var x = _a.x, y = _a.y;\n        if (!x && !y)\n            return;\n        var offset = scrollbar.offset, limit = scrollbar.limit;\n        // DISALLOW delta transformation\n        scrollbar.setMomentum(lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(offset.x + x, 0, limit.x) - offset.x, lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(offset.y + y, 0, limit.y) - offset.y);\n        animationID = requestAnimationFrame(function () {\n            scroll({ x: x, y: y });\n        });\n    }\n    addEvent(window, 'mousemove', function (evt) {\n        if (!isSelected)\n            return;\n        cancelAnimationFrame(animationID);\n        var dir = calcMomentum(scrollbar, evt);\n        scroll(dir);\n    });\n    // prevent scrolling when context menu is opened\n    // NOTE: `contextmenu` event may be fired\n    //          1. BEFORE `selectstart`: when user right-clicks on the text content -> prevent future scrolling,\n    //          2. AFTER `selectstart`: when user right-clicks on the blank area -> cancel current scrolling,\n    //        so we need to both set the flag and cancel current scrolling\n    addEvent(contentEl, 'contextmenu', function () {\n        // set the flag to prevent future scrolling\n        isContextMenuOpened = true;\n        // stop current scrolling\n        cancelAnimationFrame(animationID);\n        isSelected = false;\n    });\n    // reset context menu flag on mouse down\n    // to ensure the scrolling is allowed in the next selection\n    addEvent(contentEl, 'mousedown', function () {\n        isContextMenuOpened = false;\n    });\n    addEvent(contentEl, 'selectstart', function () {\n        if (isContextMenuOpened) {\n            return;\n        }\n        cancelAnimationFrame(animationID);\n        isSelected = true;\n    });\n    addEvent(window, 'mouseup blur', function () {\n        cancelAnimationFrame(animationID);\n        isSelected = false;\n        isContextMenuOpened = false;\n    });\n    // patch for touch devices\n    addEvent(containerEl, 'scroll', function (evt) {\n        evt.preventDefault();\n        containerEl.scrollTop = containerEl.scrollLeft = 0;\n    });\n}\nfunction calcMomentum(scrollbar, evt) {\n    var _a = scrollbar.bounding, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\n    var _b = Object(_utils___WEBPACK_IMPORTED_MODULE_1__[\"getPosition\"])(evt), x = _b.x, y = _b.y;\n    var res = {\n        x: 0,\n        y: 0,\n    };\n    var padding = 20;\n    if (x === 0 && y === 0)\n        return res;\n    if (x > right - padding) {\n        res.x = (x - right + padding);\n    }\n    else if (x < left + padding) {\n        res.x = (x - left - padding);\n    }\n    if (y > bottom - padding) {\n        res.y = (y - bottom + padding);\n    }\n    else if (y < top + padding) {\n        res.y = (y - top - padding);\n    }\n    res.x *= 2;\n    res.y *= 2;\n    return res;\n}\n//# sourceMappingURL=select.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/select.js?")},"./node_modules/smooth-scrollbar/events/touch.js":function node_modulesSmoothScrollbarEventsTouchJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchHandler", function() { return touchHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\nvar activeScrollbar;\nfunction touchHandler(scrollbar) {\n    var target = scrollbar.options.delegateTo || scrollbar.containerEl;\n    var touchRecord = new _utils___WEBPACK_IMPORTED_MODULE_0__["TouchRecord"]();\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__["eventScope"])(scrollbar);\n    var damping;\n    var pointerCount = 0;\n    addEvent(target, \'touchstart\', function (evt) {\n        // start records\n        touchRecord.track(evt);\n        // stop scrolling\n        scrollbar.setMomentum(0, 0);\n        // save damping\n        if (pointerCount === 0) {\n            damping = scrollbar.options.damping;\n            scrollbar.options.damping = Math.max(damping, 0.5); // less frames on touchmove\n        }\n        pointerCount++;\n    });\n    addEvent(target, \'touchmove\', function (evt) {\n        if (activeScrollbar && activeScrollbar !== scrollbar)\n            return;\n        touchRecord.update(evt);\n        var _a = touchRecord.getDelta(), x = _a.x, y = _a.y;\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll && evt.cancelable) {\n                evt.preventDefault();\n                activeScrollbar = scrollbar;\n            }\n        });\n    });\n    addEvent(target, \'touchcancel touchend\', function (evt) {\n        var delta = touchRecord.getEasingDistance(damping);\n        scrollbar.addTransformableMomentum(delta.x, delta.y, evt);\n        pointerCount--;\n        // restore damping\n        if (pointerCount === 0) {\n            scrollbar.options.damping = damping;\n        }\n        touchRecord.release(evt);\n        activeScrollbar = null;\n    });\n}\n//# sourceMappingURL=touch.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/touch.js?')},"./node_modules/smooth-scrollbar/events/wheel.js":function node_modulesSmoothScrollbarEventsWheelJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wheelHandler\", function() { return wheelHandler; });\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ */ \"./node_modules/smooth-scrollbar/utils/index.js\");\n\nfunction wheelHandler(scrollbar) {\n    var addEvent = Object(_utils___WEBPACK_IMPORTED_MODULE_0__[\"eventScope\"])(scrollbar);\n    var target = scrollbar.options.delegateTo || scrollbar.containerEl;\n    var eventName = ('onwheel' in window || document.implementation.hasFeature('Events.wheel', '3.0')) ? 'wheel' : 'mousewheel';\n    addEvent(target, eventName, function (evt) {\n        var _a = normalizeDelta(evt), x = _a.x, y = _a.y;\n        scrollbar.addTransformableMomentum(x, y, evt, function (willScroll) {\n            if (willScroll) {\n                evt.preventDefault();\n            }\n        });\n    });\n}\n// Normalizing wheel delta\nvar DELTA_SCALE = {\n    STANDARD: 1,\n    OTHERS: -3,\n};\nvar DELTA_MODE = [1.0, 28.0, 500.0];\nvar getDeltaMode = function (mode) { return DELTA_MODE[mode] || DELTA_MODE[0]; };\nfunction normalizeDelta(evt) {\n    if ('deltaX' in evt) {\n        var mode = getDeltaMode(evt.deltaMode);\n        return {\n            x: evt.deltaX / DELTA_SCALE.STANDARD * mode,\n            y: evt.deltaY / DELTA_SCALE.STANDARD * mode,\n        };\n    }\n    if ('wheelDeltaX' in evt) {\n        return {\n            x: evt.wheelDeltaX / DELTA_SCALE.OTHERS,\n            y: evt.wheelDeltaY / DELTA_SCALE.OTHERS,\n        };\n    }\n    // ie with touchpad\n    return {\n        x: 0,\n        y: evt.wheelDelta / DELTA_SCALE.OTHERS,\n    };\n}\n//# sourceMappingURL=wheel.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/events/wheel.js?")},"./node_modules/smooth-scrollbar/geometry/get-size.js":function node_modulesSmoothScrollbarGeometryGetSizeJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSize\", function() { return getSize; });\nfunction getSize(scrollbar) {\n    var containerEl = scrollbar.containerEl, contentEl = scrollbar.contentEl;\n    var containerStyles = getComputedStyle(containerEl);\n    var paddings = [\n        'paddingTop',\n        'paddingBottom',\n        'paddingLeft',\n        'paddingRight',\n    ].map(function (prop) {\n        return containerStyles[prop] ? parseFloat(containerStyles[prop]) : 0;\n    });\n    var verticalPadding = paddings[0] + paddings[1];\n    var horizontalPadding = paddings[2] + paddings[3];\n    return {\n        container: {\n            // requires `overflow: hidden`\n            width: containerEl.clientWidth,\n            height: containerEl.clientHeight,\n        },\n        content: {\n            // border width and paddings should be included\n            width: contentEl.offsetWidth - contentEl.clientWidth + contentEl.scrollWidth + horizontalPadding,\n            height: contentEl.offsetHeight - contentEl.clientHeight + contentEl.scrollHeight + verticalPadding,\n        },\n    };\n}\n//# sourceMappingURL=get-size.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/get-size.js?")},"./node_modules/smooth-scrollbar/geometry/index.js":function node_modulesSmoothScrollbarGeometryIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _get_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-size */ "./node_modules/smooth-scrollbar/geometry/get-size.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return _get_size__WEBPACK_IMPORTED_MODULE_0__["getSize"]; });\n\n/* harmony import */ var _is_visible__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-visible */ "./node_modules/smooth-scrollbar/geometry/is-visible.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isVisible", function() { return _is_visible__WEBPACK_IMPORTED_MODULE_1__["isVisible"]; });\n\n/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./update */ "./node_modules/smooth-scrollbar/geometry/update.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "update", function() { return _update__WEBPACK_IMPORTED_MODULE_2__["update"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/index.js?')},"./node_modules/smooth-scrollbar/geometry/is-visible.js":function node_modulesSmoothScrollbarGeometryIsVisibleJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVisible", function() { return isVisible; });\nfunction isVisible(scrollbar, elem) {\n    var bounding = scrollbar.bounding;\n    var targetBounding = elem.getBoundingClientRect();\n    // check overlapping\n    var top = Math.max(bounding.top, targetBounding.top);\n    var left = Math.max(bounding.left, targetBounding.left);\n    var right = Math.min(bounding.right, targetBounding.right);\n    var bottom = Math.min(bounding.bottom, targetBounding.bottom);\n    return top < bottom && left < right;\n}\n//# sourceMappingURL=is-visible.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/is-visible.js?')},"./node_modules/smooth-scrollbar/geometry/update.js":function node_modulesSmoothScrollbarGeometryUpdateJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });\nfunction update(scrollbar) {\n    var newSize = scrollbar.getSize();\n    var limit = {\n        x: Math.max(newSize.content.width - newSize.container.width, 0),\n        y: Math.max(newSize.content.height - newSize.container.height, 0),\n    };\n    // metrics\n    var containerBounding = scrollbar.containerEl.getBoundingClientRect();\n    var bounding = {\n        top: Math.max(containerBounding.top, 0),\n        right: Math.min(containerBounding.right, window.innerWidth),\n        bottom: Math.min(containerBounding.bottom, window.innerHeight),\n        left: Math.max(containerBounding.left, 0),\n    };\n    // assign props\n    scrollbar.size = newSize;\n    scrollbar.limit = limit;\n    scrollbar.bounding = bounding;\n    // update tracks\n    scrollbar.track.update();\n    // re-positioning\n    scrollbar.setPosition();\n}\n//# sourceMappingURL=update.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/geometry/update.js?')},"./node_modules/smooth-scrollbar/index.js":function node_modulesSmoothScrollbarIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfills */ "./node_modules/smooth-scrollbar/polyfills.js");\n/* harmony import */ var _scrollbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scrollbar */ "./node_modules/smooth-scrollbar/scrollbar.js");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugin */ "./node_modules/smooth-scrollbar/plugin.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScrollbarPlugin", function() { return _plugin__WEBPACK_IMPORTED_MODULE_3__["ScrollbarPlugin"]; });\n\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ "./node_modules/smooth-scrollbar/style.js");\n\n\n\n\n\n\n/**\n * cast `I.Scrollbar` to `Scrollbar` to avoid error\n *\n * `I.Scrollbar` is not assignable to `Scrollbar`:\n *     "privateProp" is missing in `I.Scrollbar`\n *\n * @see https://github.com/Microsoft/TypeScript/issues/2672\n */\nvar SmoothScrollbar = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(SmoothScrollbar, _super);\n    function SmoothScrollbar() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Initializes a scrollbar on the given element.\n     *\n     * @param elem The DOM element that you want to initialize scrollbar to\n     * @param [options] Initial options\n     */\n    SmoothScrollbar.init = function (elem, options) {\n        if (!elem || elem.nodeType !== 1) {\n            throw new TypeError("expect element to be DOM Element, but got " + elem);\n        }\n        // attach stylesheet\n        Object(_style__WEBPACK_IMPORTED_MODULE_4__["attachStyle"])();\n        if (_scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].has(elem)) {\n            return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n        }\n        return new _scrollbar__WEBPACK_IMPORTED_MODULE_2__["Scrollbar"](elem, options);\n    };\n    /**\n     * Automatically init scrollbar on all elements base on the selector `[data-scrollbar]`\n     *\n     * @param options Initial options\n     */\n    SmoothScrollbar.initAll = function (options) {\n        return Array.from(document.querySelectorAll(\'[data-scrollbar]\'), function (elem) {\n            return SmoothScrollbar.init(elem, options);\n        });\n    };\n    /**\n     * Check if there is a scrollbar on given element\n     *\n     * @param elem The DOM element that you want to check\n     */\n    SmoothScrollbar.has = function (elem) {\n        return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].has(elem);\n    };\n    /**\n     * Gets scrollbar on the given element.\n     * If no scrollbar instance exsits, returns `undefined`\n     *\n     * @param elem The DOM element that you want to check.\n     */\n    SmoothScrollbar.get = function (elem) {\n        return _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n    };\n    /**\n     * Returns an array that contains all scrollbar instances\n     */\n    SmoothScrollbar.getAll = function () {\n        return Array.from(_scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].values());\n    };\n    /**\n     * Removes scrollbar on the given element\n     */\n    SmoothScrollbar.destroy = function (elem) {\n        var scrollbar = _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].get(elem);\n        if (scrollbar) {\n            scrollbar.destroy();\n        }\n    };\n    /**\n     * Removes all scrollbar instances from current document\n     */\n    SmoothScrollbar.destroyAll = function () {\n        _scrollbar__WEBPACK_IMPORTED_MODULE_2__["scrollbarMap"].forEach(function (scrollbar) {\n            scrollbar.destroy();\n        });\n    };\n    /**\n     * Attaches plugins to scrollbars\n     *\n     * @param ...Plugins Scrollbar plugin classes\n     */\n    SmoothScrollbar.use = function () {\n        var Plugins = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            Plugins[_i] = arguments[_i];\n        }\n        return _plugin__WEBPACK_IMPORTED_MODULE_3__["addPlugins"].apply(void 0, Plugins);\n    };\n    /**\n     * Attaches default style sheets to current document.\n     * You don\'t need to call this method manually unless\n     * you removed the default styles via `Scrollbar.detachStyle()`\n     */\n    SmoothScrollbar.attachStyle = function () {\n        return Object(_style__WEBPACK_IMPORTED_MODULE_4__["attachStyle"])();\n    };\n    /**\n     * Removes default styles from current document.\n     * Use this method when you want to use your own css for scrollbars.\n     */\n    SmoothScrollbar.detachStyle = function () {\n        return Object(_style__WEBPACK_IMPORTED_MODULE_4__["detachStyle"])();\n    };\n    SmoothScrollbar.version = "8.8.1";\n    SmoothScrollbar.ScrollbarPlugin = _plugin__WEBPACK_IMPORTED_MODULE_3__["ScrollbarPlugin"];\n    return SmoothScrollbar;\n}(_scrollbar__WEBPACK_IMPORTED_MODULE_2__["Scrollbar"]));\n/* harmony default export */ __webpack_exports__["default"] = (SmoothScrollbar);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/index.js?')},"./node_modules/smooth-scrollbar/options.js":function node_modulesSmoothScrollbarOptionsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Options", function() { return Options; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n\n\nvar Options = /** @class */ (function () {\n    function Options(config) {\n        var _this = this;\n        if (config === void 0) { config = {}; }\n        /**\n         * Momentum reduction damping factor, a float value between `(0, 1)`.\n         * The lower the value is, the more smooth the scrolling will be\n         * (also the more paint frames).\n         */\n        this.damping = 0.1;\n        /**\n         * Minimal size for scrollbar thumbs.\n         */\n        this.thumbMinSize = 20;\n        /**\n         * Render every frame in integer pixel values\n         * set to `true` to improve scrolling performance.\n         */\n        this.renderByPixels = true;\n        /**\n         * Keep scrollbar tracks visible\n         */\n        this.alwaysShowTracks = false;\n        /**\n         * Set to `true` to allow outer scrollbars continue scrolling\n         * when current scrollbar reaches edge.\n         */\n        this.continuousScrolling = true;\n        /**\n         * Delegate wheel events and touch events to the given element.\n         * By default, the container element is used.\n         * This option will be useful for dealing with fixed elements.\n         */\n        this.delegateTo = null;\n        /**\n         * Options for plugins. Syntax:\n         *   plugins[pluginName] = pluginOptions: any\n         */\n        this.plugins = {};\n        Object.keys(config).forEach(function (prop) {\n            _this[prop] = config[prop];\n        });\n    }\n    Object.defineProperty(Options.prototype, "wheelEventTarget", {\n        get: function () {\n            return this.delegateTo;\n        },\n        set: function (el) {\n            console.warn(\'[smooth-scrollbar]: `options.wheelEventTarget` is deprecated and will be removed in the future, use `options.delegateTo` instead.\');\n            this.delegateTo = el;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_1__["range"])(0, 1)\n    ], Options.prototype, "damping", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_1__["range"])(0, Infinity)\n    ], Options.prototype, "thumbMinSize", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "renderByPixels", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "alwaysShowTracks", void 0);\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        _decorators___WEBPACK_IMPORTED_MODULE_1__["boolean"]\n    ], Options.prototype, "continuousScrolling", void 0);\n    return Options;\n}());\n\n//# sourceMappingURL=options.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/options.js?')},"./node_modules/smooth-scrollbar/plugin.js":function node_modulesSmoothScrollbarPluginJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarPlugin", function() { return ScrollbarPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalPlugins", function() { return globalPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPlugins", function() { return addPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initPlugins", function() { return initPlugins; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n\nvar ScrollbarPlugin = /** @class */ (function () {\n    function ScrollbarPlugin(scrollbar, options) {\n        var _newTarget = this.constructor;\n        this.scrollbar = scrollbar;\n        this.name = _newTarget.pluginName;\n        this.options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, _newTarget.defaultOptions), options);\n    }\n    ScrollbarPlugin.prototype.onInit = function () { };\n    ScrollbarPlugin.prototype.onDestroy = function () { };\n    ScrollbarPlugin.prototype.onUpdate = function () { };\n    ScrollbarPlugin.prototype.onRender = function (_remainMomentum) { };\n    ScrollbarPlugin.prototype.transformDelta = function (delta, _evt) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, delta);\n    };\n    ScrollbarPlugin.pluginName = \'\';\n    ScrollbarPlugin.defaultOptions = {};\n    return ScrollbarPlugin;\n}());\n\nvar globalPlugins = {\n    order: new Set(),\n    constructors: {},\n};\nfunction addPlugins() {\n    var Plugins = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Plugins[_i] = arguments[_i];\n    }\n    Plugins.forEach(function (P) {\n        var pluginName = P.pluginName;\n        if (!pluginName) {\n            throw new TypeError("plugin name is required");\n        }\n        globalPlugins.order.add(pluginName);\n        globalPlugins.constructors[pluginName] = P;\n    });\n}\nfunction initPlugins(scrollbar, options) {\n    return Array.from(globalPlugins.order)\n        .filter(function (pluginName) {\n        return options[pluginName] !== false;\n    })\n        .map(function (pluginName) {\n        var Plugin = globalPlugins.constructors[pluginName];\n        var instance = new Plugin(scrollbar, options[pluginName]);\n        // bind plugin options to `scrollbar.options`\n        options[pluginName] = instance.options;\n        return instance;\n    });\n}\n//# sourceMappingURL=plugin.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/plugin.js?')},"./node_modules/smooth-scrollbar/polyfills.js":function node_modulesSmoothScrollbarPolyfillsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_es_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/es/map */ "./node_modules/core-js/es/map/index.js");\n/* harmony import */ var core_js_es_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_es_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/es/set */ "./node_modules/core-js/es/set/index.js");\n/* harmony import */ var core_js_es_set__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_es_set__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/es/weak-map */ "./node_modules/core-js/es/weak-map/index.js");\n/* harmony import */ var core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_es_weak_map__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/es/array/from */ "./node_modules/core-js/es/array/from.js");\n/* harmony import */ var core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_es_array_from__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/es/object/assign */ "./node_modules/core-js/es/object/assign.js");\n/* harmony import */ var core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_es_object_assign__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n//# sourceMappingURL=polyfills.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/polyfills.js?')},"./node_modules/smooth-scrollbar/scrollbar.js":function node_modulesSmoothScrollbarScrollbarJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollbarMap", function() { return scrollbarMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scrollbar", function() { return Scrollbar; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options */ "./node_modules/smooth-scrollbar/options.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n/* harmony import */ var _track___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./track/ */ "./node_modules/smooth-scrollbar/track/index.js");\n/* harmony import */ var _geometry___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geometry/ */ "./node_modules/smooth-scrollbar/geometry/index.js");\n/* harmony import */ var _scrolling___WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scrolling/ */ "./node_modules/smooth-scrollbar/scrolling/index.js");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugin */ "./node_modules/smooth-scrollbar/plugin.js");\n/* harmony import */ var _events___WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events/ */ "./node_modules/smooth-scrollbar/events/index.js");\n\n\n\n\n\n\n\n\n\n\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nvar scrollbarMap = new Map();\nvar Scrollbar = /** @class */ (function () {\n    function Scrollbar(containerEl, options) {\n        var _this = this;\n        /**\n         * Current scrolling offsets\n         */\n        this.offset = {\n            x: 0,\n            y: 0,\n        };\n        /**\n         * Max-allowed scrolling offsets\n         */\n        this.limit = {\n            x: Infinity,\n            y: Infinity,\n        };\n        /**\n         * Container bounding rect\n         */\n        this.bounding = {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n        };\n        // private _observer: ResizeObserver;\n        this._plugins = [];\n        this._momentum = { x: 0, y: 0 };\n        this._listeners = new Set();\n        this.containerEl = containerEl;\n        var contentEl = this.contentEl = document.createElement(\'div\');\n        this.options = new _options__WEBPACK_IMPORTED_MODULE_2__["Options"](options);\n        // mark as a scroll element\n        containerEl.setAttribute(\'data-scrollbar\', \'true\');\n        // make container focusable\n        containerEl.setAttribute(\'tabindex\', \'-1\');\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["setStyle"])(containerEl, {\n            overflow: \'hidden\',\n            outline: \'none\',\n        });\n        // enable touch event capturing in IE, see:\n        // https://github.com/idiotWu/smooth-scrollbar/issues/39\n        if (window.navigator.msPointerEnabled) {\n            containerEl.style.msTouchAction = \'none\';\n        }\n        // mount content\n        contentEl.className = \'scroll-content\';\n        Array.from(containerEl.childNodes).forEach(function (node) {\n            contentEl.appendChild(node);\n        });\n        containerEl.appendChild(contentEl);\n        // attach track\n        this.track = new _track___WEBPACK_IMPORTED_MODULE_5__["TrackController"](this);\n        // initial measuring\n        this.size = this.getSize();\n        // init plugins\n        this._plugins = Object(_plugin__WEBPACK_IMPORTED_MODULE_8__["initPlugins"])(this, this.options.plugins);\n        // preserve scroll offset\n        var scrollLeft = containerEl.scrollLeft, scrollTop = containerEl.scrollTop;\n        containerEl.scrollLeft = containerEl.scrollTop = 0;\n        this.setPosition(scrollLeft, scrollTop, {\n            withoutCallbacks: true,\n        });\n        // FIXME: update typescript\n        var ResizeObserver = window.ResizeObserver;\n        // observe\n        if (typeof ResizeObserver === \'function\') {\n            this._observer = new ResizeObserver(function () {\n                _this.update();\n            });\n            this._observer.observe(contentEl);\n        }\n        scrollbarMap.set(containerEl, this);\n        // wait for DOM ready\n        requestAnimationFrame(function () {\n            _this._init();\n        });\n    }\n    Object.defineProperty(Scrollbar.prototype, "parent", {\n        /**\n         * Parent scrollbar\n         */\n        get: function () {\n            var elem = this.containerEl.parentElement;\n            while (elem) {\n                var parentScrollbar = scrollbarMap.get(elem);\n                if (parentScrollbar) {\n                    return parentScrollbar;\n                }\n                elem = elem.parentElement;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Scrollbar.prototype, "scrollTop", {\n        /**\n         * Gets or sets `scrollbar.offset.y`\n         */\n        get: function () {\n            return this.offset.y;\n        },\n        set: function (y) {\n            this.setPosition(this.scrollLeft, y);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Scrollbar.prototype, "scrollLeft", {\n        /**\n         * Gets or sets `scrollbar.offset.x`\n         */\n        get: function () {\n            return this.offset.x;\n        },\n        set: function (x) {\n            this.setPosition(x, this.scrollTop);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the size of the scrollbar container element\n     * and the content wrapper element\n     */\n    Scrollbar.prototype.getSize = function () {\n        return Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["getSize"])(this);\n    };\n    /**\n     * Forces scrollbar to update geometry infomation.\n     *\n     * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n     * You can call this method to force an update when you modified contents\n     */\n    Scrollbar.prototype.update = function () {\n        Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["update"])(this);\n        this._plugins.forEach(function (plugin) {\n            plugin.onUpdate();\n        });\n    };\n    /**\n     * Checks if an element is visible in the current view area\n     */\n    Scrollbar.prototype.isVisible = function (elem) {\n        return Object(_geometry___WEBPACK_IMPORTED_MODULE_6__["isVisible"])(this, elem);\n    };\n    /**\n     * Sets the scrollbar to the given offset without easing\n     */\n    Scrollbar.prototype.setPosition = function (x, y, options) {\n        var _this = this;\n        if (x === void 0) { x = this.offset.x; }\n        if (y === void 0) { y = this.offset.y; }\n        if (options === void 0) { options = {}; }\n        var status = Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["setPosition"])(this, x, y);\n        if (!status || options.withoutCallbacks) {\n            return;\n        }\n        this._listeners.forEach(function (fn) {\n            fn.call(_this, status);\n        });\n    };\n    /**\n     * Scrolls to given position with easing function\n     */\n    Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n        if (x === void 0) { x = this.offset.x; }\n        if (y === void 0) { y = this.offset.y; }\n        if (duration === void 0) { duration = 0; }\n        if (options === void 0) { options = {}; }\n        Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["scrollTo"])(this, x, y, duration, options);\n    };\n    /**\n     * Scrolls the target element into visible area of scrollbar,\n     * likes the DOM method `element.scrollIntoView().\n     */\n    Scrollbar.prototype.scrollIntoView = function (elem, options) {\n        if (options === void 0) { options = {}; }\n        Object(_scrolling___WEBPACK_IMPORTED_MODULE_7__["scrollIntoView"])(this, elem, options);\n    };\n    /**\n     * Adds scrolling listener\n     */\n    Scrollbar.prototype.addListener = function (fn) {\n        if (typeof fn !== \'function\') {\n            throw new TypeError(\'[smooth-scrollbar] scrolling listener should be a function\');\n        }\n        this._listeners.add(fn);\n    };\n    /**\n     * Removes listener previously registered with `scrollbar.addListener()`\n     */\n    Scrollbar.prototype.removeListener = function (fn) {\n        this._listeners.delete(fn);\n    };\n    /**\n     * Adds momentum and applys delta transformers.\n     */\n    Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n        this._updateDebounced();\n        var finalDelta = this._plugins.reduce(function (delta, plugin) {\n            return plugin.transformDelta(delta, fromEvent) || delta;\n        }, { x: x, y: y });\n        var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n        if (willScroll) {\n            this.addMomentum(finalDelta.x, finalDelta.y);\n        }\n        if (callback) {\n            callback.call(this, willScroll);\n        }\n    };\n    /**\n     * Increases scrollbar\'s momentum\n     */\n    Scrollbar.prototype.addMomentum = function (x, y) {\n        this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n    };\n    /**\n     * Sets scrollbar\'s momentum to given value\n     */\n    Scrollbar.prototype.setMomentum = function (x, y) {\n        if (this.limit.x === 0) {\n            x = 0;\n        }\n        if (this.limit.y === 0) {\n            y = 0;\n        }\n        if (this.options.renderByPixels) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        this._momentum.x = x;\n        this._momentum.y = y;\n    };\n    /**\n     * Update options for specific plugin\n     *\n     * @param pluginName Name of the plugin\n     * @param [options] An object includes the properties that you want to update\n     */\n    Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n        this._plugins.forEach(function (plugin) {\n            if (plugin.name === pluginName) {\n                Object.assign(plugin.options, options);\n            }\n        });\n    };\n    Scrollbar.prototype.destroy = function () {\n        var _a = this, containerEl = _a.containerEl, contentEl = _a.contentEl;\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["clearEventsOn"])(this);\n        this._listeners.clear();\n        this.setMomentum(0, 0);\n        cancelAnimationFrame(this._renderID);\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n        scrollbarMap.delete(this.containerEl);\n        // restore contents\n        var childNodes = Array.from(contentEl.childNodes);\n        while (containerEl.firstChild) {\n            containerEl.removeChild(containerEl.firstChild);\n        }\n        childNodes.forEach(function (el) {\n            containerEl.appendChild(el);\n        });\n        // reset scroll position\n        Object(_utils___WEBPACK_IMPORTED_MODULE_3__["setStyle"])(containerEl, {\n            overflow: \'\',\n        });\n        containerEl.scrollTop = this.scrollTop;\n        containerEl.scrollLeft = this.scrollLeft;\n        // invoke plugin.onDestroy\n        this._plugins.forEach(function (plugin) {\n            plugin.onDestroy();\n        });\n        this._plugins.length = 0;\n    };\n    Scrollbar.prototype._init = function () {\n        var _this = this;\n        this.update();\n        // init evet handlers\n        Object.keys(_events___WEBPACK_IMPORTED_MODULE_9__).forEach(function (prop) {\n            _events___WEBPACK_IMPORTED_MODULE_9__[prop](_this);\n        });\n        // invoke `plugin.onInit`\n        this._plugins.forEach(function (plugin) {\n            plugin.onInit();\n        });\n        this._render();\n    };\n    Scrollbar.prototype._updateDebounced = function () {\n        this.update();\n    };\n    // check whether to propagate monmentum to parent scrollbar\n    // the following situations are considered as `true`:\n    //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n    //         2. scrollbar reaches one side and is not about to scroll on the other direction\n    Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n        if (deltaX === void 0) { deltaX = 0; }\n        if (deltaY === void 0) { deltaY = 0; }\n        var _a = this, options = _a.options, offset = _a.offset, limit = _a.limit;\n        if (!options.continuousScrolling)\n            return false;\n        // force an update when scrollbar is "unscrollable", see #106\n        if (limit.x === 0 && limit.y === 0) {\n            this._updateDebounced();\n        }\n        var destX = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(deltaX + offset.x, 0, limit.x);\n        var destY = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(deltaY + offset.y, 0, limit.y);\n        var res = true;\n        // offsets are not about to change\n        // `&=` operator is not allowed for boolean types\n        res = res && (destX === offset.x);\n        res = res && (destY === offset.y);\n        // current offsets are on the edge\n        res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n        return res;\n    };\n    Scrollbar.prototype._render = function () {\n        var _momentum = this._momentum;\n        if (_momentum.x || _momentum.y) {\n            var nextX = this._nextTick(\'x\');\n            var nextY = this._nextTick(\'y\');\n            _momentum.x = nextX.momentum;\n            _momentum.y = nextY.momentum;\n            this.setPosition(nextX.position, nextY.position);\n        }\n        var remain = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, this._momentum);\n        this._plugins.forEach(function (plugin) {\n            plugin.onRender(remain);\n        });\n        this._renderID = requestAnimationFrame(this._render.bind(this));\n    };\n    Scrollbar.prototype._nextTick = function (direction) {\n        var _a = this, options = _a.options, offset = _a.offset, _momentum = _a._momentum;\n        var current = offset[direction];\n        var remain = _momentum[direction];\n        if (Math.abs(remain) <= 0.1) {\n            return {\n                momentum: 0,\n                position: current + remain,\n            };\n        }\n        var nextMomentum = remain * (1 - options.damping);\n        if (options.renderByPixels) {\n            nextMomentum |= 0;\n        }\n        return {\n            momentum: nextMomentum,\n            position: current + remain - nextMomentum,\n        };\n    };\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_4__["debounce"])(100, { leading: true })\n    ], Scrollbar.prototype, "_updateDebounced", null);\n    return Scrollbar;\n}());\n\n//# sourceMappingURL=scrollbar.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrollbar.js?')},"./node_modules/smooth-scrollbar/scrolling/index.js":function node_modulesSmoothScrollbarScrollingIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _set_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set-position */ "./node_modules/smooth-scrollbar/scrolling/set-position.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPosition", function() { return _set_position__WEBPACK_IMPORTED_MODULE_0__["setPosition"]; });\n\n/* harmony import */ var _scroll_to__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scroll-to */ "./node_modules/smooth-scrollbar/scrolling/scroll-to.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scrollTo", function() { return _scroll_to__WEBPACK_IMPORTED_MODULE_1__["scrollTo"]; });\n\n/* harmony import */ var _scroll_into_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scroll-into-view */ "./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scrollIntoView", function() { return _scroll_into_view__WEBPACK_IMPORTED_MODULE_2__["scrollIntoView"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/index.js?')},"./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js":function node_modulesSmoothScrollbarScrollingScrollIntoViewJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollIntoView", function() { return scrollIntoView; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction scrollIntoView(scrollbar, elem, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.alignToTop, alignToTop = _c === void 0 ? true : _c, _d = _b.onlyScrollIfNeeded, onlyScrollIfNeeded = _d === void 0 ? false : _d, _e = _b.offsetTop, offsetTop = _e === void 0 ? 0 : _e, _f = _b.offsetLeft, offsetLeft = _f === void 0 ? 0 : _f, _g = _b.offsetBottom, offsetBottom = _g === void 0 ? 0 : _g;\n    var containerEl = scrollbar.containerEl, bounding = scrollbar.bounding, offset = scrollbar.offset, limit = scrollbar.limit;\n    if (!elem || !containerEl.contains(elem))\n        return;\n    var targetBounding = elem.getBoundingClientRect();\n    if (onlyScrollIfNeeded && scrollbar.isVisible(elem))\n        return;\n    var delta = alignToTop ? targetBounding.top - bounding.top - offsetTop : targetBounding.bottom - bounding.bottom + offsetBottom;\n    scrollbar.setMomentum(targetBounding.left - bounding.left - offsetLeft, lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(delta, -offset.y, limit.y - offset.y));\n}\n//# sourceMappingURL=scroll-into-view.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/scroll-into-view.js?')},"./node_modules/smooth-scrollbar/scrolling/scroll-to.js":function node_modulesSmoothScrollbarScrollingScrollToJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollTo", function() { return scrollTo; });\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);\n\nvar animationIDStorage = new WeakMap();\nfunction scrollTo(scrollbar, x, y, duration, _a) {\n    if (duration === void 0) { duration = 0; }\n    var _b = _a === void 0 ? {} : _a, _c = _b.easing, easing = _c === void 0 ? defaultEasing : _c, callback = _b.callback;\n    var options = scrollbar.options, offset = scrollbar.offset, limit = scrollbar.limit;\n    if (options.renderByPixels) {\n        // ensure resolved with integer\n        x = Math.round(x);\n        y = Math.round(y);\n    }\n    var startX = offset.x;\n    var startY = offset.y;\n    var disX = lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(x, 0, limit.x) - startX;\n    var disY = lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(y, 0, limit.y) - startY;\n    var start = Date.now();\n    function scroll() {\n        var elapse = Date.now() - start;\n        var progress = duration ? easing(Math.min(elapse / duration, 1)) : 1;\n        scrollbar.setPosition(startX + disX * progress, startY + disY * progress);\n        if (elapse >= duration) {\n            if (typeof callback === \'function\') {\n                callback.call(scrollbar);\n            }\n        }\n        else {\n            var animationID = requestAnimationFrame(scroll);\n            animationIDStorage.set(scrollbar, animationID);\n        }\n    }\n    cancelAnimationFrame(animationIDStorage.get(scrollbar));\n    scroll();\n}\n/**\n * easeOutCubic\n */\nfunction defaultEasing(t) {\n    return Math.pow((t - 1), 3) + 1;\n}\n//# sourceMappingURL=scroll-to.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/scroll-to.js?')},"./node_modules/smooth-scrollbar/scrolling/set-position.js":function node_modulesSmoothScrollbarScrollingSetPositionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPosition", function() { return setPosition; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.clamp */ "./node_modules/lodash.clamp/index.js");\n/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\n\nfunction setPosition(scrollbar, x, y) {\n    var options = scrollbar.options, offset = scrollbar.offset, limit = scrollbar.limit, track = scrollbar.track, contentEl = scrollbar.contentEl;\n    if (options.renderByPixels) {\n        x = Math.round(x);\n        y = Math.round(y);\n    }\n    x = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(x, 0, limit.x);\n    y = lodash_clamp__WEBPACK_IMPORTED_MODULE_1___default()(y, 0, limit.y);\n    // position changed -> show track for 300ms\n    if (x !== offset.x)\n        track.xAxis.show();\n    if (y !== offset.y)\n        track.yAxis.show();\n    if (!options.alwaysShowTracks) {\n        track.autoHideOnIdle();\n    }\n    if (x === offset.x && y === offset.y) {\n        return null;\n    }\n    offset.x = x;\n    offset.y = y;\n    Object(_utils___WEBPACK_IMPORTED_MODULE_2__["setStyle"])(contentEl, {\n        \'-transform\': "translate3d(" + -x + "px, " + -y + "px, 0)",\n    });\n    track.update();\n    return {\n        offset: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, offset),\n        limit: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, limit),\n    };\n}\n//# sourceMappingURL=set-position.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/scrolling/set-position.js?')},"./node_modules/smooth-scrollbar/style.js":function node_modulesSmoothScrollbarStyleJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachStyle\", function() { return attachStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detachStyle\", function() { return detachStyle; });\nvar TRACK_BG = 'rgba(222, 222, 222, .75)';\nvar THUMB_BG = 'rgba(0, 0, 0, .5)';\n// sets content's display type to `flow-root` to suppress margin collapsing\nvar SCROLLBAR_STYLE = \"\\n[data-scrollbar] {\\n  display: block;\\n  position: relative;\\n}\\n\\n.scroll-content {\\n  display: flow-root;\\n  -webkit-transform: translate3d(0, 0, 0);\\n          transform: translate3d(0, 0, 0);\\n}\\n\\n.scrollbar-track {\\n  position: absolute;\\n  opacity: 0;\\n  z-index: 1;\\n  background: \" + TRACK_BG + \";\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  -webkit-transition: opacity 0.5s 0.5s ease-out;\\n          transition: opacity 0.5s 0.5s ease-out;\\n}\\n.scrollbar-track.show,\\n.scrollbar-track:hover {\\n  opacity: 1;\\n  -webkit-transition-delay: 0s;\\n          transition-delay: 0s;\\n}\\n\\n.scrollbar-track-x {\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 8px;\\n}\\n.scrollbar-track-y {\\n  top: 0;\\n  right: 0;\\n  width: 8px;\\n  height: 100%;\\n}\\n.scrollbar-thumb {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 8px;\\n  height: 8px;\\n  background: \" + THUMB_BG + \";\\n  border-radius: 4px;\\n}\\n\";\nvar STYLE_ID = 'smooth-scrollbar-style';\nvar isStyleAttached = false;\nfunction attachStyle() {\n    if (isStyleAttached || typeof window === 'undefined') {\n        return;\n    }\n    var styleEl = document.createElement('style');\n    styleEl.id = STYLE_ID;\n    styleEl.textContent = SCROLLBAR_STYLE;\n    if (document.head) {\n        document.head.appendChild(styleEl);\n    }\n    isStyleAttached = true;\n}\nfunction detachStyle() {\n    if (!isStyleAttached || typeof window === 'undefined') {\n        return;\n    }\n    var styleEl = document.getElementById(STYLE_ID);\n    if (!styleEl || !styleEl.parentNode) {\n        return;\n    }\n    styleEl.parentNode.removeChild(styleEl);\n    isStyleAttached = false;\n}\n//# sourceMappingURL=style.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/style.js?")},"./node_modules/smooth-scrollbar/track/direction.js":function node_modulesSmoothScrollbarTrackDirectionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackDirection", function() { return TrackDirection; });\nvar TrackDirection;\n(function (TrackDirection) {\n    TrackDirection["X"] = "x";\n    TrackDirection["Y"] = "y";\n})(TrackDirection || (TrackDirection = {}));\n//# sourceMappingURL=direction.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/direction.js?')},"./node_modules/smooth-scrollbar/track/index.js":function node_modulesSmoothScrollbarTrackIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackController", function() { return TrackController; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _track__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track */ "./node_modules/smooth-scrollbar/track/track.js");\n/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./direction */ "./node_modules/smooth-scrollbar/track/direction.js");\n/* harmony import */ var _decorators___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../decorators/ */ "./node_modules/smooth-scrollbar/decorators/index.js");\n\n\n\n\nvar TrackController = /** @class */ (function () {\n    function TrackController(_scrollbar) {\n        this._scrollbar = _scrollbar;\n        var thumbMinSize = _scrollbar.options.thumbMinSize;\n        this.xAxis = new _track__WEBPACK_IMPORTED_MODULE_1__["ScrollbarTrack"](_direction__WEBPACK_IMPORTED_MODULE_2__["TrackDirection"].X, thumbMinSize);\n        this.yAxis = new _track__WEBPACK_IMPORTED_MODULE_1__["ScrollbarTrack"](_direction__WEBPACK_IMPORTED_MODULE_2__["TrackDirection"].Y, thumbMinSize);\n        this.xAxis.attachTo(_scrollbar.containerEl);\n        this.yAxis.attachTo(_scrollbar.containerEl);\n        if (_scrollbar.options.alwaysShowTracks) {\n            this.xAxis.show();\n            this.yAxis.show();\n        }\n    }\n    /**\n     * Updates track appearance\n     */\n    TrackController.prototype.update = function () {\n        var _a = this._scrollbar, size = _a.size, offset = _a.offset;\n        this.xAxis.update(offset.x, size.container.width, size.content.width);\n        this.yAxis.update(offset.y, size.container.height, size.content.height);\n    };\n    /**\n     * Automatically hide tracks when scrollbar is in idle state\n     */\n    TrackController.prototype.autoHideOnIdle = function () {\n        if (this._scrollbar.options.alwaysShowTracks) {\n            return;\n        }\n        this.xAxis.hide();\n        this.yAxis.hide();\n    };\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([\n        Object(_decorators___WEBPACK_IMPORTED_MODULE_3__["debounce"])(300)\n    ], TrackController.prototype, "autoHideOnIdle", null);\n    return TrackController;\n}());\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/index.js?')},"./node_modules/smooth-scrollbar/track/thumb.js":function node_modulesSmoothScrollbarTrackThumbJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarThumb", function() { return ScrollbarThumb; });\n/* harmony import */ var _direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./direction */ "./node_modules/smooth-scrollbar/track/direction.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar ScrollbarThumb = /** @class */ (function () {\n    function ScrollbarThumb(_direction, _minSize) {\n        if (_minSize === void 0) { _minSize = 0; }\n        this._direction = _direction;\n        this._minSize = _minSize;\n        /**\n         * Thumb element\n         */\n        this.element = document.createElement(\'div\');\n        /**\n         * Display size of the thumb\n         * will always be greater than `scrollbar.options.thumbMinSize`\n         */\n        this.displaySize = 0;\n        /**\n         * Actual size of the thumb\n         */\n        this.realSize = 0;\n        /**\n         * Thumb offset to the top\n         */\n        this.offset = 0;\n        this.element.className = "scrollbar-thumb scrollbar-thumb-" + _direction;\n    }\n    /**\n     * Attach to track element\n     *\n     * @param trackEl Track element\n     */\n    ScrollbarThumb.prototype.attachTo = function (trackEl) {\n        trackEl.appendChild(this.element);\n    };\n    ScrollbarThumb.prototype.update = function (scrollOffset, containerSize, pageSize) {\n        // calculate thumb size\n        // pageSize > containerSize -> scrollable\n        this.realSize = Math.min(containerSize / pageSize, 1) * containerSize;\n        this.displaySize = Math.max(this.realSize, this._minSize);\n        // calculate thumb offset\n        this.offset = scrollOffset / pageSize * (containerSize + (this.realSize - this.displaySize));\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(this.element, this._getStyle());\n    };\n    ScrollbarThumb.prototype._getStyle = function () {\n        switch (this._direction) {\n            case _direction__WEBPACK_IMPORTED_MODULE_0__["TrackDirection"].X:\n                return {\n                    width: this.displaySize + "px",\n                    \'-transform\': "translate3d(" + this.offset + "px, 0, 0)",\n                };\n            case _direction__WEBPACK_IMPORTED_MODULE_0__["TrackDirection"].Y:\n                return {\n                    height: this.displaySize + "px",\n                    \'-transform\': "translate3d(0, " + this.offset + "px, 0)",\n                };\n            default:\n                return null;\n        }\n    };\n    return ScrollbarThumb;\n}());\n\n//# sourceMappingURL=thumb.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/thumb.js?')},"./node_modules/smooth-scrollbar/track/track.js":function node_modulesSmoothScrollbarTrackTrackJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollbarTrack", function() { return ScrollbarTrack; });\n/* harmony import */ var _thumb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thumb */ "./node_modules/smooth-scrollbar/track/thumb.js");\n/* harmony import */ var _utils___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ */ "./node_modules/smooth-scrollbar/utils/index.js");\n\n\nvar ScrollbarTrack = /** @class */ (function () {\n    function ScrollbarTrack(direction, thumbMinSize) {\n        if (thumbMinSize === void 0) { thumbMinSize = 0; }\n        /**\n         * Track element\n         */\n        this.element = document.createElement(\'div\');\n        this._isShown = false;\n        this.element.className = "scrollbar-track scrollbar-track-" + direction;\n        this.thumb = new _thumb__WEBPACK_IMPORTED_MODULE_0__["ScrollbarThumb"](direction, thumbMinSize);\n        this.thumb.attachTo(this.element);\n    }\n    /**\n     * Attach to scrollbar container element\n     *\n     * @param scrollbarContainer Scrollbar container element\n     */\n    ScrollbarTrack.prototype.attachTo = function (scrollbarContainer) {\n        scrollbarContainer.appendChild(this.element);\n    };\n    /**\n     * Show track immediately\n     */\n    ScrollbarTrack.prototype.show = function () {\n        if (this._isShown) {\n            return;\n        }\n        this._isShown = true;\n        this.element.classList.add(\'show\');\n    };\n    /**\n     * Hide track immediately\n     */\n    ScrollbarTrack.prototype.hide = function () {\n        if (!this._isShown) {\n            return;\n        }\n        this._isShown = false;\n        this.element.classList.remove(\'show\');\n    };\n    ScrollbarTrack.prototype.update = function (scrollOffset, containerSize, pageSize) {\n        Object(_utils___WEBPACK_IMPORTED_MODULE_1__["setStyle"])(this.element, {\n            display: pageSize <= containerSize ? \'none\' : \'block\',\n        });\n        this.thumb.update(scrollOffset, containerSize, pageSize);\n    };\n    return ScrollbarTrack;\n}());\n\n//# sourceMappingURL=track.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/track/track.js?')},"./node_modules/smooth-scrollbar/utils/event-hub.js":function node_modulesSmoothScrollbarUtilsEventHubJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eventScope\", function() { return eventScope; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearEventsOn\", function() { return clearEventsOn; });\nvar eventListenerOptions;\nvar eventMap = new WeakMap();\nfunction getOptions() {\n    if (eventListenerOptions !== undefined) {\n        return eventListenerOptions;\n    }\n    var supportPassiveEvent = false;\n    try {\n        var noop = function () { };\n        var options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                supportPassiveEvent = true;\n            },\n        });\n        window.addEventListener('testPassive', noop, options);\n        window.removeEventListener('testPassive', noop, options);\n    }\n    catch (e) { }\n    eventListenerOptions = supportPassiveEvent ? { passive: false } : false;\n    return eventListenerOptions;\n}\nfunction eventScope(scrollbar) {\n    var configs = eventMap.get(scrollbar) || [];\n    eventMap.set(scrollbar, configs);\n    return function addEvent(elem, events, fn) {\n        function handler(event) {\n            // ignore default prevented events\n            if (event.defaultPrevented) {\n                return;\n            }\n            fn(event);\n        }\n        events.split(/\\s+/g).forEach(function (eventName) {\n            configs.push({ elem: elem, eventName: eventName, handler: handler });\n            elem.addEventListener(eventName, handler, getOptions());\n        });\n    };\n}\nfunction clearEventsOn(scrollbar) {\n    var configs = eventMap.get(scrollbar);\n    if (!configs) {\n        return;\n    }\n    configs.forEach(function (_a) {\n        var elem = _a.elem, eventName = _a.eventName, handler = _a.handler;\n        elem.removeEventListener(eventName, handler, getOptions());\n    });\n    eventMap.delete(scrollbar);\n}\n//# sourceMappingURL=event-hub.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/event-hub.js?")},"./node_modules/smooth-scrollbar/utils/get-pointer-data.js":function node_modulesSmoothScrollbarUtilsGetPointerDataJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointerData", function() { return getPointerData; });\n/**\n * Get pointer/touch data\n */\nfunction getPointerData(evt) {\n    // if is touch event, return last item in touchList\n    // else return original event\n    return evt.touches ? evt.touches[evt.touches.length - 1] : evt;\n}\n//# sourceMappingURL=get-pointer-data.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/get-pointer-data.js?')},"./node_modules/smooth-scrollbar/utils/get-position.js":function node_modulesSmoothScrollbarUtilsGetPositionJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return getPosition; });\n/* harmony import */ var _get_pointer_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-pointer-data */ "./node_modules/smooth-scrollbar/utils/get-pointer-data.js");\n\n/**\n * Get pointer/finger position\n */\nfunction getPosition(evt) {\n    var data = Object(_get_pointer_data__WEBPACK_IMPORTED_MODULE_0__["getPointerData"])(evt);\n    return {\n        x: data.clientX,\n        y: data.clientY,\n    };\n}\n//# sourceMappingURL=get-position.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/get-position.js?')},"./node_modules/smooth-scrollbar/utils/index.js":function node_modulesSmoothScrollbarUtilsIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _event_hub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-hub */ "./node_modules/smooth-scrollbar/utils/event-hub.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventScope", function() { return _event_hub__WEBPACK_IMPORTED_MODULE_0__["eventScope"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearEventsOn", function() { return _event_hub__WEBPACK_IMPORTED_MODULE_0__["clearEventsOn"]; });\n\n/* harmony import */ var _get_pointer_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-pointer-data */ "./node_modules/smooth-scrollbar/utils/get-pointer-data.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPointerData", function() { return _get_pointer_data__WEBPACK_IMPORTED_MODULE_1__["getPointerData"]; });\n\n/* harmony import */ var _get_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-position */ "./node_modules/smooth-scrollbar/utils/get-position.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPosition", function() { return _get_position__WEBPACK_IMPORTED_MODULE_2__["getPosition"]; });\n\n/* harmony import */ var _is_one_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-one-of */ "./node_modules/smooth-scrollbar/utils/is-one-of.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isOneOf", function() { return _is_one_of__WEBPACK_IMPORTED_MODULE_3__["isOneOf"]; });\n\n/* harmony import */ var _set_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./set-style */ "./node_modules/smooth-scrollbar/utils/set-style.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setStyle", function() { return _set_style__WEBPACK_IMPORTED_MODULE_4__["setStyle"]; });\n\n/* harmony import */ var _touch_record__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./touch-record */ "./node_modules/smooth-scrollbar/utils/touch-record.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tracker", function() { return _touch_record__WEBPACK_IMPORTED_MODULE_5__["Tracker"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TouchRecord", function() { return _touch_record__WEBPACK_IMPORTED_MODULE_5__["TouchRecord"]; });\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/index.js?')},"./node_modules/smooth-scrollbar/utils/is-one-of.js":function node_modulesSmoothScrollbarUtilsIsOneOfJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOneOf", function() { return isOneOf; });\n/**\n * Check if `a` is one of `[...b]`\n */\nfunction isOneOf(a, b) {\n    if (b === void 0) { b = []; }\n    return b.some(function (v) { return a === v; });\n}\n//# sourceMappingURL=is-one-of.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/is-one-of.js?')},"./node_modules/smooth-scrollbar/utils/set-style.js":function node_modulesSmoothScrollbarUtilsSetStyleJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setStyle\", function() { return setStyle; });\nvar VENDOR_PREFIX = [\n    'webkit',\n    'moz',\n    'ms',\n    'o',\n];\nvar RE = new RegExp(\"^-(?!(?:\" + VENDOR_PREFIX.join('|') + \")-)\");\nfunction autoPrefix(styles) {\n    var res = {};\n    Object.keys(styles).forEach(function (prop) {\n        if (!RE.test(prop)) {\n            res[prop] = styles[prop];\n            return;\n        }\n        var val = styles[prop];\n        prop = prop.replace(/^-/, '');\n        res[prop] = val;\n        VENDOR_PREFIX.forEach(function (prefix) {\n            res[\"-\" + prefix + \"-\" + prop] = val;\n        });\n    });\n    return res;\n}\nfunction setStyle(elem, styles) {\n    styles = autoPrefix(styles);\n    Object.keys(styles).forEach(function (prop) {\n        var cssProp = prop.replace(/^-/, '').replace(/-([a-z])/g, function (_, $1) { return $1.toUpperCase(); });\n        elem.style[cssProp] = styles[prop];\n    });\n}\n//# sourceMappingURL=set-style.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/set-style.js?")},"./node_modules/smooth-scrollbar/utils/touch-record.js":function node_modulesSmoothScrollbarUtilsTouchRecordJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tracker", function() { return Tracker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchRecord", function() { return TouchRecord; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _get_position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-position */ "./node_modules/smooth-scrollbar/utils/get-position.js");\n\n\nvar Tracker = /** @class */ (function () {\n    function Tracker(touch) {\n        this.velocityMultiplier = window.devicePixelRatio;\n        this.updateTime = Date.now();\n        this.delta = { x: 0, y: 0 };\n        this.velocity = { x: 0, y: 0 };\n        this.lastPosition = { x: 0, y: 0 };\n        this.lastPosition = Object(_get_position__WEBPACK_IMPORTED_MODULE_1__["getPosition"])(touch);\n    }\n    Tracker.prototype.update = function (touch) {\n        var _a = this, velocity = _a.velocity, updateTime = _a.updateTime, lastPosition = _a.lastPosition;\n        var now = Date.now();\n        var position = Object(_get_position__WEBPACK_IMPORTED_MODULE_1__["getPosition"])(touch);\n        var delta = {\n            x: -(position.x - lastPosition.x),\n            y: -(position.y - lastPosition.y),\n        };\n        var duration = (now - updateTime) || 16.7;\n        var vx = delta.x / duration * 16.7;\n        var vy = delta.y / duration * 16.7;\n        velocity.x = vx * this.velocityMultiplier;\n        velocity.y = vy * this.velocityMultiplier;\n        this.delta = delta;\n        this.updateTime = now;\n        this.lastPosition = position;\n    };\n    return Tracker;\n}());\n\nvar TouchRecord = /** @class */ (function () {\n    function TouchRecord() {\n        this._touchList = {};\n    }\n    Object.defineProperty(TouchRecord.prototype, "_primitiveValue", {\n        get: function () {\n            return { x: 0, y: 0 };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TouchRecord.prototype.isActive = function () {\n        return this._activeTouchID !== undefined;\n    };\n    TouchRecord.prototype.getDelta = function () {\n        var tracker = this._getActiveTracker();\n        if (!tracker) {\n            return this._primitiveValue;\n        }\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, tracker.delta);\n    };\n    TouchRecord.prototype.getVelocity = function () {\n        var tracker = this._getActiveTracker();\n        if (!tracker) {\n            return this._primitiveValue;\n        }\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, tracker.velocity);\n    };\n    TouchRecord.prototype.getEasingDistance = function (damping) {\n        var deAcceleration = 1 - damping;\n        var distance = {\n            x: 0,\n            y: 0,\n        };\n        var vel = this.getVelocity();\n        Object.keys(vel).forEach(function (dir) {\n            // ignore small velocity\n            var v = Math.abs(vel[dir]) <= 10 ? 0 : vel[dir];\n            while (v !== 0) {\n                distance[dir] += v;\n                v = (v * deAcceleration) | 0;\n            }\n        });\n        return distance;\n    };\n    TouchRecord.prototype.track = function (evt) {\n        var _this = this;\n        var targetTouches = evt.targetTouches;\n        Array.from(targetTouches).forEach(function (touch) {\n            _this._add(touch);\n        });\n        return this._touchList;\n    };\n    TouchRecord.prototype.update = function (evt) {\n        var _this = this;\n        var touches = evt.touches, changedTouches = evt.changedTouches;\n        Array.from(touches).forEach(function (touch) {\n            _this._renew(touch);\n        });\n        this._setActiveID(changedTouches);\n        return this._touchList;\n    };\n    TouchRecord.prototype.release = function (evt) {\n        var _this = this;\n        delete this._activeTouchID;\n        Array.from(evt.changedTouches).forEach(function (touch) {\n            _this._delete(touch);\n        });\n    };\n    TouchRecord.prototype._add = function (touch) {\n        if (this._has(touch)) {\n            // reset tracker\n            this._delete(touch);\n        }\n        var tracker = new Tracker(touch);\n        this._touchList[touch.identifier] = tracker;\n    };\n    TouchRecord.prototype._renew = function (touch) {\n        if (!this._has(touch)) {\n            return;\n        }\n        var tracker = this._touchList[touch.identifier];\n        tracker.update(touch);\n    };\n    TouchRecord.prototype._delete = function (touch) {\n        delete this._touchList[touch.identifier];\n    };\n    TouchRecord.prototype._has = function (touch) {\n        return this._touchList.hasOwnProperty(touch.identifier);\n    };\n    TouchRecord.prototype._setActiveID = function (touches) {\n        this._activeTouchID = touches[touches.length - 1].identifier;\n    };\n    TouchRecord.prototype._getActiveTracker = function () {\n        var _a = this, _touchList = _a._touchList, _activeTouchID = _a._activeTouchID;\n        return _touchList[_activeTouchID];\n    };\n    return TouchRecord;\n}());\n\n//# sourceMappingURL=touch-record.js.map\n\n//# sourceURL=webpack:///./node_modules/smooth-scrollbar/utils/touch-record.js?')},"./node_modules/tiny-slider/dist/tiny-slider.js":function node_modulesTinySliderDistTinySliderJs(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar win$1 = window;\nvar raf = win$1.requestAnimationFrame || win$1.webkitRequestAnimationFrame || win$1.mozRequestAnimationFrame || win$1.msRequestAnimationFrame || function (cb) {\n  return setTimeout(cb, 16);\n};\n\nvar win = window;\nvar caf = win.cancelAnimationFrame || win.mozCancelAnimationFrame || function (id) {\n  clearTimeout(id);\n};\n\nfunction extend() {\n  var obj,\n      name,\n      copy,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length;\n\n  for (; i < length; i++) {\n    if ((obj = arguments[i]) !== null) {\n      for (name in obj) {\n        copy = obj[name];\n\n        if (target === copy) {\n          continue;\n        } else if (copy !== undefined) {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction checkStorageValue(value) {\n  return ['true', 'false'].indexOf(value) >= 0 ? JSON.parse(value) : value;\n}\n\nfunction setLocalStorage(storage, key, value, access) {\n  if (access) {\n    try {\n      storage.setItem(key, value);\n    } catch (e) {}\n  }\n\n  return value;\n}\n\nfunction getSlideId() {\n  var id = window.tnsId;\n  window.tnsId = !id ? 1 : id + 1;\n  return 'tns' + window.tnsId;\n}\n\nfunction getBody() {\n  var doc = document,\n      body = doc.body;\n\n  if (!body) {\n    body = doc.createElement('body');\n    body.fake = true;\n  }\n\n  return body;\n}\n\nvar docElement = document.documentElement;\n\nfunction setFakeBody(body) {\n  var docOverflow = '';\n\n  if (body.fake) {\n    docOverflow = docElement.style.overflow; //avoid crashing IE8, if background image is used\n\n    body.style.background = ''; //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible\n\n    body.style.overflow = docElement.style.overflow = 'hidden';\n    docElement.appendChild(body);\n  }\n\n  return docOverflow;\n}\n\nfunction resetFakeBody(body, docOverflow) {\n  if (body.fake) {\n    body.remove();\n    docElement.style.overflow = docOverflow; // Trigger layout so kinetic scrolling isn't disabled in iOS6+\n    // eslint-disable-next-line\n\n    docElement.offsetHeight;\n  }\n}\n\n// get css-calc \nfunction calc() {\n  var doc = document,\n      body = getBody(),\n      docOverflow = setFakeBody(body),\n      div = doc.createElement('div'),\n      result = false;\n  body.appendChild(div);\n\n  try {\n    var str = '(10px * 10)',\n        vals = ['calc' + str, '-moz-calc' + str, '-webkit-calc' + str],\n        val;\n\n    for (var i = 0; i < 3; i++) {\n      val = vals[i];\n      div.style.width = val;\n\n      if (div.offsetWidth === 100) {\n        result = val.replace(str, '');\n        break;\n      }\n    }\n  } catch (e) {}\n\n  body.fake ? resetFakeBody(body, docOverflow) : div.remove();\n  return result;\n}\n\n// get subpixel support value\nfunction percentageLayout() {\n  // check subpixel layout supporting\n  var doc = document,\n      body = getBody(),\n      docOverflow = setFakeBody(body),\n      wrapper = doc.createElement('div'),\n      outer = doc.createElement('div'),\n      str = '',\n      count = 70,\n      perPage = 3,\n      supported = false;\n  wrapper.className = \"tns-t-subp2\";\n  outer.className = \"tns-t-ct\";\n\n  for (var i = 0; i < count; i++) {\n    str += '<div></div>';\n  }\n\n  outer.innerHTML = str;\n  wrapper.appendChild(outer);\n  body.appendChild(wrapper);\n  supported = Math.abs(wrapper.getBoundingClientRect().left - outer.children[count - perPage].getBoundingClientRect().left) < 2;\n  body.fake ? resetFakeBody(body, docOverflow) : wrapper.remove();\n  return supported;\n}\n\nfunction mediaquerySupport() {\n  if (window.matchMedia || window.msMatchMedia) {\n    return true;\n  }\n\n  var doc = document,\n      body = getBody(),\n      docOverflow = setFakeBody(body),\n      div = doc.createElement('div'),\n      style = doc.createElement('style'),\n      rule = '@media all and (min-width:1px){.tns-mq-test{position:absolute}}',\n      position;\n  style.type = 'text/css';\n  div.className = 'tns-mq-test';\n  body.appendChild(style);\n  body.appendChild(div);\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = rule;\n  } else {\n    style.appendChild(doc.createTextNode(rule));\n  }\n\n  position = window.getComputedStyle ? window.getComputedStyle(div).position : div.currentStyle['position'];\n  body.fake ? resetFakeBody(body, docOverflow) : div.remove();\n  return position === \"absolute\";\n}\n\n// create and append style sheet\nfunction createStyleSheet(media, nonce) {\n  // Create the <style> tag\n  var style = document.createElement(\"style\"); // style.setAttribute(\"type\", \"text/css\");\n  // Add a media (and/or media query) here if you'd like!\n  // style.setAttribute(\"media\", \"screen\")\n  // style.setAttribute(\"media\", \"only screen and (max-width : 1024px)\")\n\n  if (media) {\n    style.setAttribute(\"media\", media);\n  } // Add nonce attribute for Content Security Policy\n\n\n  if (nonce) {\n    style.setAttribute(\"nonce\", nonce);\n  } // WebKit hack :(\n  // style.appendChild(document.createTextNode(\"\"));\n  // Add the <style> element to the page\n\n\n  document.querySelector('head').appendChild(style);\n  return style.sheet ? style.sheet : style.styleSheet;\n}\n\n// cross browsers addRule method\nfunction addCSSRule(sheet, selector, rules, index) {\n  // return raf(function() {\n  'insertRule' in sheet ? sheet.insertRule(selector + '{' + rules + '}', index) : sheet.addRule(selector, rules, index); // });\n}\n\n// cross browsers addRule method\nfunction removeCSSRule(sheet, index) {\n  // return raf(function() {\n  'deleteRule' in sheet ? sheet.deleteRule(index) : sheet.removeRule(index); // });\n}\n\nfunction getCssRulesLength(sheet) {\n  var rule = 'insertRule' in sheet ? sheet.cssRules : sheet.rules;\n  return rule.length;\n}\n\nfunction toDegree(y, x) {\n  return Math.atan2(y, x) * (180 / Math.PI);\n}\n\nfunction getTouchDirection(angle, range) {\n  var direction = false,\n      gap = Math.abs(90 - Math.abs(angle));\n\n  if (gap >= 90 - range) {\n    direction = 'horizontal';\n  } else if (gap <= range) {\n    direction = 'vertical';\n  }\n\n  return direction;\n}\n\n// https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/\nfunction forEach(arr, callback, scope) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    callback.call(scope, arr[i], i);\n  }\n}\n\nvar classListSupport = ('classList' in document.createElement('_'));\n\nvar hasClass = classListSupport ? function (el, str) {\n  return el.classList.contains(str);\n} : function (el, str) {\n  return el.className.indexOf(str) >= 0;\n};\n\nvar addClass = classListSupport ? function (el, str) {\n  if (!hasClass(el, str)) {\n    el.classList.add(str);\n  }\n} : function (el, str) {\n  if (!hasClass(el, str)) {\n    el.className += ' ' + str;\n  }\n};\n\nvar removeClass = classListSupport ? function (el, str) {\n  if (hasClass(el, str)) {\n    el.classList.remove(str);\n  }\n} : function (el, str) {\n  if (hasClass(el, str)) {\n    el.className = el.className.replace(str, '');\n  }\n};\n\nfunction hasAttr(el, attr) {\n  return el.hasAttribute(attr);\n}\n\nfunction getAttr(el, attr) {\n  return el.getAttribute(attr);\n}\n\nfunction isNodeList(el) {\n  // Only NodeList has the \"item()\" function\n  return typeof el.item !== \"undefined\";\n}\n\nfunction setAttrs(els, attrs) {\n  els = isNodeList(els) || els instanceof Array ? els : [els];\n\n  if (Object.prototype.toString.call(attrs) !== '[object Object]') {\n    return;\n  }\n\n  for (var i = els.length; i--;) {\n    for (var key in attrs) {\n      els[i].setAttribute(key, attrs[key]);\n    }\n  }\n}\n\nfunction removeAttrs(els, attrs) {\n  els = isNodeList(els) || els instanceof Array ? els : [els];\n  attrs = attrs instanceof Array ? attrs : [attrs];\n  var attrLength = attrs.length;\n\n  for (var i = els.length; i--;) {\n    for (var j = attrLength; j--;) {\n      els[i].removeAttribute(attrs[j]);\n    }\n  }\n}\n\nfunction arrayFromNodeList(nl) {\n  var arr = [];\n\n  for (var i = 0, l = nl.length; i < l; i++) {\n    arr.push(nl[i]);\n  }\n\n  return arr;\n}\n\nfunction hideElement(el, forceHide) {\n  if (el.style.display !== 'none') {\n    el.style.display = 'none';\n  }\n}\n\nfunction showElement(el, forceHide) {\n  if (el.style.display === 'none') {\n    el.style.display = '';\n  }\n}\n\nfunction isVisible(el) {\n  return window.getComputedStyle(el).display !== 'none';\n}\n\nfunction whichProperty(props) {\n  if (typeof props === 'string') {\n    var arr = [props],\n        Props = props.charAt(0).toUpperCase() + props.substr(1),\n        prefixes = ['Webkit', 'Moz', 'ms', 'O'];\n    prefixes.forEach(function (prefix) {\n      if (prefix !== 'ms' || props === 'transform') {\n        arr.push(prefix + Props);\n      }\n    });\n    props = arr;\n  }\n\n  var el = document.createElement('fakeelement');\n      props.length;\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n\n    if (el.style[prop] !== undefined) {\n      return prop;\n    }\n  }\n\n  return false; // explicit for ie9-\n}\n\nfunction has3DTransforms(tf) {\n  if (!tf) {\n    return false;\n  }\n\n  if (!window.getComputedStyle) {\n    return false;\n  }\n\n  var doc = document,\n      body = getBody(),\n      docOverflow = setFakeBody(body),\n      el = doc.createElement('p'),\n      has3d,\n      cssTF = tf.length > 9 ? '-' + tf.slice(0, -9).toLowerCase() + '-' : '';\n  cssTF += 'transform'; // Add it to the body to get the computed style\n\n  body.insertBefore(el, null);\n  el.style[tf] = 'translate3d(1px,1px,1px)';\n  has3d = window.getComputedStyle(el).getPropertyValue(cssTF);\n  body.fake ? resetFakeBody(body, docOverflow) : el.remove();\n  return has3d !== undefined && has3d.length > 0 && has3d !== \"none\";\n}\n\n// get transitionend, animationend based on transitionDuration\n// @propin: string\n// @propOut: string, first-letter uppercase\n// Usage: getEndProperty('WebkitTransitionDuration', 'Transition') => webkitTransitionEnd\nfunction getEndProperty(propIn, propOut) {\n  var endProp = false;\n\n  if (/^Webkit/.test(propIn)) {\n    endProp = 'webkit' + propOut + 'End';\n  } else if (/^O/.test(propIn)) {\n    endProp = 'o' + propOut + 'End';\n  } else if (propIn) {\n    endProp = propOut.toLowerCase() + 'end';\n  }\n\n  return endProp;\n}\n\n// Test via a getter in the options object to see if the passive property is accessed\nvar supportsPassive = false;\n\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    get: function () {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener(\"test\", null, opts);\n} catch (e) {}\n\nvar passiveOption = supportsPassive ? {\n  passive: true\n} : false;\n\nfunction addEvents(el, obj, preventScrolling) {\n  for (var prop in obj) {\n    var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 && !preventScrolling ? passiveOption : false;\n    el.addEventListener(prop, obj[prop], option);\n  }\n}\n\nfunction removeEvents(el, obj) {\n  for (var prop in obj) {\n    var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 ? passiveOption : false;\n    el.removeEventListener(prop, obj[prop], option);\n  }\n}\n\nfunction Events() {\n  return {\n    topics: {},\n    on: function (eventName, fn) {\n      this.topics[eventName] = this.topics[eventName] || [];\n      this.topics[eventName].push(fn);\n    },\n    off: function (eventName, fn) {\n      if (this.topics[eventName]) {\n        for (var i = 0; i < this.topics[eventName].length; i++) {\n          if (this.topics[eventName][i] === fn) {\n            this.topics[eventName].splice(i, 1);\n            break;\n          }\n        }\n      }\n    },\n    emit: function (eventName, data) {\n      data.type = eventName;\n\n      if (this.topics[eventName]) {\n        this.topics[eventName].forEach(function (fn) {\n          fn(data, eventName);\n        });\n      }\n    }\n  };\n}\n\nfunction jsTransform(element, attr, prefix, postfix, to, duration, callback) {\n  var tick = Math.min(duration, 10),\n      unit = to.indexOf('%') >= 0 ? '%' : 'px',\n      to = to.replace(unit, ''),\n      from = Number(element.style[attr].replace(prefix, '').replace(postfix, '').replace(unit, '')),\n      positionTick = (to - from) / duration * tick;\n  setTimeout(moveElement, tick);\n\n  function moveElement() {\n    duration -= tick;\n    from += positionTick;\n    element.style[attr] = prefix + from + unit + postfix;\n\n    if (duration > 0) {\n      setTimeout(moveElement, tick);\n    } else {\n      callback();\n    }\n  }\n}\n\n// Object.keys\nif (!Object.keys) {\n  Object.keys = function (object) {\n    var keys = [];\n\n    for (var name in object) {\n      if (Object.prototype.hasOwnProperty.call(object, name)) {\n        keys.push(name);\n      }\n    }\n\n    return keys;\n  };\n} // ChildNode.remove\n\n\nif (!(\"remove\" in Element.prototype)) {\n  Element.prototype.remove = function () {\n    if (this.parentNode) {\n      this.parentNode.removeChild(this);\n    }\n  };\n}\nvar tns = function (options) {\n  options = extend({\n    container: '.slider',\n    mode: 'carousel',\n    axis: 'horizontal',\n    items: 1,\n    gutter: 0,\n    edgePadding: 0,\n    fixedWidth: false,\n    autoWidth: false,\n    viewportMax: false,\n    slideBy: 1,\n    center: false,\n    controls: true,\n    controlsPosition: 'top',\n    controlsText: ['prev', 'next'],\n    controlsContainer: false,\n    prevButton: false,\n    nextButton: false,\n    nav: true,\n    navPosition: 'top',\n    navContainer: false,\n    navAsThumbnails: false,\n    arrowKeys: false,\n    speed: 300,\n    autoplay: false,\n    autoplayPosition: 'top',\n    autoplayTimeout: 5000,\n    autoplayDirection: 'forward',\n    autoplayText: ['start', 'stop'],\n    autoplayHoverPause: false,\n    autoplayButton: false,\n    autoplayButtonOutput: true,\n    autoplayResetOnVisibility: true,\n    animateIn: 'tns-fadeIn',\n    animateOut: 'tns-fadeOut',\n    animateNormal: 'tns-normal',\n    animateDelay: false,\n    loop: true,\n    rewind: false,\n    autoHeight: false,\n    responsive: false,\n    lazyload: false,\n    lazyloadSelector: '.tns-lazy-img',\n    touch: true,\n    mouseDrag: false,\n    swipeAngle: 15,\n    nested: false,\n    preventActionWhenRunning: false,\n    preventScrollOnTouch: false,\n    freezable: true,\n    onInit: false,\n    useLocalStorage: true,\n    nonce: false\n  }, options || {});\n  var doc = document,\n      win = window,\n      KEYS = {\n    ENTER: 13,\n    SPACE: 32,\n    LEFT: 37,\n    RIGHT: 39\n  },\n      tnsStorage = {},\n      localStorageAccess = options.useLocalStorage;\n\n  if (localStorageAccess) {\n    // check browser version and local storage access\n    var browserInfo = navigator.userAgent;\n    var uid = new Date();\n\n    try {\n      tnsStorage = win.localStorage;\n\n      if (tnsStorage) {\n        tnsStorage.setItem(uid, uid);\n        localStorageAccess = tnsStorage.getItem(uid) == uid;\n        tnsStorage.removeItem(uid);\n      } else {\n        localStorageAccess = false;\n      }\n\n      if (!localStorageAccess) {\n        tnsStorage = {};\n      }\n    } catch (e) {\n      localStorageAccess = false;\n    }\n\n    if (localStorageAccess) {\n      // remove storage when browser version changes\n      if (tnsStorage['tnsApp'] && tnsStorage['tnsApp'] !== browserInfo) {\n        ['tC', 'tPL', 'tMQ', 'tTf', 't3D', 'tTDu', 'tTDe', 'tADu', 'tADe', 'tTE', 'tAE'].forEach(function (item) {\n          tnsStorage.removeItem(item);\n        });\n      } // update browserInfo\n\n\n      localStorage['tnsApp'] = browserInfo;\n    }\n  }\n\n  var CALC = tnsStorage['tC'] ? checkStorageValue(tnsStorage['tC']) : setLocalStorage(tnsStorage, 'tC', calc(), localStorageAccess),\n      PERCENTAGELAYOUT = tnsStorage['tPL'] ? checkStorageValue(tnsStorage['tPL']) : setLocalStorage(tnsStorage, 'tPL', percentageLayout(), localStorageAccess),\n      CSSMQ = tnsStorage['tMQ'] ? checkStorageValue(tnsStorage['tMQ']) : setLocalStorage(tnsStorage, 'tMQ', mediaquerySupport(), localStorageAccess),\n      TRANSFORM = tnsStorage['tTf'] ? checkStorageValue(tnsStorage['tTf']) : setLocalStorage(tnsStorage, 'tTf', whichProperty('transform'), localStorageAccess),\n      HAS3DTRANSFORMS = tnsStorage['t3D'] ? checkStorageValue(tnsStorage['t3D']) : setLocalStorage(tnsStorage, 't3D', has3DTransforms(TRANSFORM), localStorageAccess),\n      TRANSITIONDURATION = tnsStorage['tTDu'] ? checkStorageValue(tnsStorage['tTDu']) : setLocalStorage(tnsStorage, 'tTDu', whichProperty('transitionDuration'), localStorageAccess),\n      TRANSITIONDELAY = tnsStorage['tTDe'] ? checkStorageValue(tnsStorage['tTDe']) : setLocalStorage(tnsStorage, 'tTDe', whichProperty('transitionDelay'), localStorageAccess),\n      ANIMATIONDURATION = tnsStorage['tADu'] ? checkStorageValue(tnsStorage['tADu']) : setLocalStorage(tnsStorage, 'tADu', whichProperty('animationDuration'), localStorageAccess),\n      ANIMATIONDELAY = tnsStorage['tADe'] ? checkStorageValue(tnsStorage['tADe']) : setLocalStorage(tnsStorage, 'tADe', whichProperty('animationDelay'), localStorageAccess),\n      TRANSITIONEND = tnsStorage['tTE'] ? checkStorageValue(tnsStorage['tTE']) : setLocalStorage(tnsStorage, 'tTE', getEndProperty(TRANSITIONDURATION, 'Transition'), localStorageAccess),\n      ANIMATIONEND = tnsStorage['tAE'] ? checkStorageValue(tnsStorage['tAE']) : setLocalStorage(tnsStorage, 'tAE', getEndProperty(ANIMATIONDURATION, 'Animation'), localStorageAccess); // get element nodes from selectors\n\n  var supportConsoleWarn = win.console && typeof win.console.warn === \"function\",\n      tnsList = ['container', 'controlsContainer', 'prevButton', 'nextButton', 'navContainer', 'autoplayButton'],\n      optionsElements = {};\n  tnsList.forEach(function (item) {\n    if (typeof options[item] === 'string') {\n      var str = options[item],\n          el = doc.querySelector(str);\n      optionsElements[item] = str;\n\n      if (el && el.nodeName) {\n        options[item] = el;\n      } else {\n        if (supportConsoleWarn) {\n          console.warn('Can\\'t find', options[item]);\n        }\n\n        return;\n      }\n    }\n  }); // make sure at least 1 slide\n\n  if (options.container.children.length < 1) {\n    if (supportConsoleWarn) {\n      console.warn('No slides found in', options.container);\n    }\n\n    return;\n  } // update options\n\n\n  var responsive = options.responsive,\n      nested = options.nested,\n      carousel = options.mode === 'carousel' ? true : false;\n\n  if (responsive) {\n    // apply responsive[0] to options and remove it\n    if (0 in responsive) {\n      options = extend(options, responsive[0]);\n      delete responsive[0];\n    }\n\n    var responsiveTem = {};\n\n    for (var key in responsive) {\n      var val = responsive[key]; // update responsive\n      // from: 300: 2\n      // to:\n      //   300: {\n      //     items: 2\n      //   }\n\n      val = typeof val === 'number' ? {\n        items: val\n      } : val;\n      responsiveTem[key] = val;\n    }\n\n    responsive = responsiveTem;\n    responsiveTem = null;\n  } // update options\n\n\n  function updateOptions(obj) {\n    for (var key in obj) {\n      if (!carousel) {\n        if (key === 'slideBy') {\n          obj[key] = 'page';\n        }\n\n        if (key === 'edgePadding') {\n          obj[key] = false;\n        }\n\n        if (key === 'autoHeight') {\n          obj[key] = false;\n        }\n      } // update responsive options\n\n\n      if (key === 'responsive') {\n        updateOptions(obj[key]);\n      }\n    }\n  }\n\n  if (!carousel) {\n    updateOptions(options);\n  } // === define and set variables ===\n\n\n  if (!carousel) {\n    options.axis = 'horizontal';\n    options.slideBy = 'page';\n    options.edgePadding = false;\n    var animateIn = options.animateIn,\n        animateOut = options.animateOut,\n        animateDelay = options.animateDelay,\n        animateNormal = options.animateNormal;\n  }\n\n  var horizontal = options.axis === 'horizontal' ? true : false,\n      outerWrapper = doc.createElement('div'),\n      innerWrapper = doc.createElement('div'),\n      middleWrapper,\n      container = options.container,\n      containerParent = container.parentNode,\n      containerHTML = container.outerHTML,\n      slideItems = container.children,\n      slideCount = slideItems.length,\n      breakpointZone,\n      windowWidth = getWindowWidth(),\n      isOn = false;\n\n  if (responsive) {\n    setBreakpointZone();\n  }\n\n  if (carousel) {\n    container.className += ' tns-vpfix';\n  } // fixedWidth: viewport > rightBoundary > indexMax\n\n\n  var autoWidth = options.autoWidth,\n      fixedWidth = getOption('fixedWidth'),\n      edgePadding = getOption('edgePadding'),\n      gutter = getOption('gutter'),\n      viewport = getViewportWidth(),\n      center = getOption('center'),\n      items = !autoWidth ? Math.floor(getOption('items')) : 1,\n      slideBy = getOption('slideBy'),\n      viewportMax = options.viewportMax || options.fixedWidthViewportWidth,\n      arrowKeys = getOption('arrowKeys'),\n      speed = getOption('speed'),\n      rewind = options.rewind,\n      loop = rewind ? false : options.loop,\n      autoHeight = getOption('autoHeight'),\n      controls = getOption('controls'),\n      controlsText = getOption('controlsText'),\n      nav = getOption('nav'),\n      touch = getOption('touch'),\n      mouseDrag = getOption('mouseDrag'),\n      autoplay = getOption('autoplay'),\n      autoplayTimeout = getOption('autoplayTimeout'),\n      autoplayText = getOption('autoplayText'),\n      autoplayHoverPause = getOption('autoplayHoverPause'),\n      autoplayResetOnVisibility = getOption('autoplayResetOnVisibility'),\n      sheet = createStyleSheet(null, getOption('nonce')),\n      lazyload = options.lazyload,\n      lazyloadSelector = options.lazyloadSelector,\n      slidePositions,\n      // collection of slide positions\n  slideItemsOut = [],\n      cloneCount = loop ? getCloneCountForLoop() : 0,\n      slideCountNew = !carousel ? slideCount + cloneCount : slideCount + cloneCount * 2,\n      hasRightDeadZone = (fixedWidth || autoWidth) && !loop ? true : false,\n      rightBoundary = fixedWidth ? getRightBoundary() : null,\n      updateIndexBeforeTransform = !carousel || !loop ? true : false,\n      // transform\n  transformAttr = horizontal ? 'left' : 'top',\n      transformPrefix = '',\n      transformPostfix = '',\n      // index\n  getIndexMax = function () {\n    if (fixedWidth) {\n      return function () {\n        return center && !loop ? slideCount - 1 : Math.ceil(-rightBoundary / (fixedWidth + gutter));\n      };\n    } else if (autoWidth) {\n      return function () {\n        for (var i = 0; i < slideCountNew; i++) {\n          if (slidePositions[i] >= -rightBoundary) {\n            return i;\n          }\n        }\n      };\n    } else {\n      return function () {\n        if (center && carousel && !loop) {\n          return slideCount - 1;\n        } else {\n          return loop || carousel ? Math.max(0, slideCountNew - Math.ceil(items)) : slideCountNew - 1;\n        }\n      };\n    }\n  }(),\n      index = getStartIndex(getOption('startIndex')),\n      indexCached = index;\n      getCurrentSlide();\n      var indexMin = 0,\n      indexMax = !autoWidth ? getIndexMax() : null,\n      preventActionWhenRunning = options.preventActionWhenRunning,\n      swipeAngle = options.swipeAngle,\n      moveDirectionExpected = swipeAngle ? '?' : true,\n      running = false,\n      onInit = options.onInit,\n      events = new Events(),\n      // id, class\n  newContainerClasses = ' tns-slider tns-' + options.mode,\n      slideId = container.id || getSlideId(),\n      disable = getOption('disable'),\n      disabled = false,\n      freezable = options.freezable,\n      freeze = freezable && !autoWidth ? getFreeze() : false,\n      frozen = false,\n      controlsEvents = {\n    'click': onControlsClick,\n    'keydown': onControlsKeydown\n  },\n      navEvents = {\n    'click': onNavClick,\n    'keydown': onNavKeydown\n  },\n      hoverEvents = {\n    'mouseover': mouseoverPause,\n    'mouseout': mouseoutRestart\n  },\n      visibilityEvent = {\n    'visibilitychange': onVisibilityChange\n  },\n      docmentKeydownEvent = {\n    'keydown': onDocumentKeydown\n  },\n      touchEvents = {\n    'touchstart': onPanStart,\n    'touchmove': onPanMove,\n    'touchend': onPanEnd,\n    'touchcancel': onPanEnd\n  },\n      dragEvents = {\n    'mousedown': onPanStart,\n    'mousemove': onPanMove,\n    'mouseup': onPanEnd,\n    'mouseleave': onPanEnd\n  },\n      hasControls = hasOption('controls'),\n      hasNav = hasOption('nav'),\n      navAsThumbnails = autoWidth ? true : options.navAsThumbnails,\n      hasAutoplay = hasOption('autoplay'),\n      hasTouch = hasOption('touch'),\n      hasMouseDrag = hasOption('mouseDrag'),\n      slideActiveClass = 'tns-slide-active',\n      slideClonedClass = 'tns-slide-cloned',\n      imgCompleteClass = 'tns-complete',\n      imgEvents = {\n    'load': onImgLoaded,\n    'error': onImgFailed\n  },\n      imgsComplete,\n      liveregionCurrent,\n      preventScroll = options.preventScrollOnTouch === 'force' ? true : false; // controls\n\n\n  if (hasControls) {\n    var controlsContainer = options.controlsContainer,\n        controlsContainerHTML = options.controlsContainer ? options.controlsContainer.outerHTML : '',\n        prevButton = options.prevButton,\n        nextButton = options.nextButton,\n        prevButtonHTML = options.prevButton ? options.prevButton.outerHTML : '',\n        nextButtonHTML = options.nextButton ? options.nextButton.outerHTML : '',\n        prevIsButton,\n        nextIsButton;\n  } // nav\n\n\n  if (hasNav) {\n    var navContainer = options.navContainer,\n        navContainerHTML = options.navContainer ? options.navContainer.outerHTML : '',\n        navItems,\n        pages = autoWidth ? slideCount : getPages(),\n        pagesCached = 0,\n        navClicked = -1,\n        navCurrentIndex = getCurrentNavIndex(),\n        navCurrentIndexCached = navCurrentIndex,\n        navActiveClass = 'tns-nav-active',\n        navStr = 'Carousel Page ',\n        navStrCurrent = ' (Current Slide)';\n  } // autoplay\n\n\n  if (hasAutoplay) {\n    var autoplayDirection = options.autoplayDirection === 'forward' ? 1 : -1,\n        autoplayButton = options.autoplayButton,\n        autoplayButtonHTML = options.autoplayButton ? options.autoplayButton.outerHTML : '',\n        autoplayHtmlStrings = ['<span class=\\'tns-visually-hidden\\'>', ' animation</span>'],\n        autoplayTimer,\n        animating,\n        autoplayHoverPaused,\n        autoplayUserPaused,\n        autoplayVisibilityPaused;\n  }\n\n  if (hasTouch || hasMouseDrag) {\n    var initPosition = {},\n        lastPosition = {},\n        translateInit,\n        panStart = false,\n        rafIndex,\n        getDist = horizontal ? function (a, b) {\n      return a.x - b.x;\n    } : function (a, b) {\n      return a.y - b.y;\n    };\n  } // disable slider when slidecount <= items\n\n\n  if (!autoWidth) {\n    resetVariblesWhenDisable(disable || freeze);\n  }\n\n  if (TRANSFORM) {\n    transformAttr = TRANSFORM;\n    transformPrefix = 'translate';\n\n    if (HAS3DTRANSFORMS) {\n      transformPrefix += horizontal ? '3d(' : '3d(0px, ';\n      transformPostfix = horizontal ? ', 0px, 0px)' : ', 0px)';\n    } else {\n      transformPrefix += horizontal ? 'X(' : 'Y(';\n      transformPostfix = ')';\n    }\n  }\n\n  if (carousel) {\n    container.className = container.className.replace('tns-vpfix', '');\n  }\n\n  initStructure();\n  initSheet();\n  initSliderTransform(); // === COMMON FUNCTIONS === //\n\n  function resetVariblesWhenDisable(condition) {\n    if (condition) {\n      controls = nav = touch = mouseDrag = arrowKeys = autoplay = autoplayHoverPause = autoplayResetOnVisibility = false;\n    }\n  }\n\n  function getCurrentSlide() {\n    var tem = carousel ? index - cloneCount : index;\n\n    while (tem < 0) {\n      tem += slideCount;\n    }\n\n    return tem % slideCount + 1;\n  }\n\n  function getStartIndex(ind) {\n    ind = ind ? Math.max(0, Math.min(loop ? slideCount - 1 : slideCount - items, ind)) : 0;\n    return carousel ? ind + cloneCount : ind;\n  }\n\n  function getAbsIndex(i) {\n    if (i == null) {\n      i = index;\n    }\n\n    if (carousel) {\n      i -= cloneCount;\n    }\n\n    while (i < 0) {\n      i += slideCount;\n    }\n\n    return Math.floor(i % slideCount);\n  }\n\n  function getCurrentNavIndex() {\n    var absIndex = getAbsIndex(),\n        result;\n    result = navAsThumbnails ? absIndex : fixedWidth || autoWidth ? Math.ceil((absIndex + 1) * pages / slideCount - 1) : Math.floor(absIndex / items); // set active nav to the last one when reaches the right edge\n\n    if (!loop && carousel && index === indexMax) {\n      result = pages - 1;\n    }\n\n    return result;\n  }\n\n  function getItemsMax() {\n    // fixedWidth or autoWidth while viewportMax is not available\n    if (autoWidth || fixedWidth && !viewportMax) {\n      return slideCount - 1; // most cases\n    } else {\n      var str = fixedWidth ? 'fixedWidth' : 'items',\n          arr = [];\n\n      if (fixedWidth || options[str] < slideCount) {\n        arr.push(options[str]);\n      }\n\n      if (responsive) {\n        for (var bp in responsive) {\n          var tem = responsive[bp][str];\n\n          if (tem && (fixedWidth || tem < slideCount)) {\n            arr.push(tem);\n          }\n        }\n      }\n\n      if (!arr.length) {\n        arr.push(0);\n      }\n\n      return Math.ceil(fixedWidth ? viewportMax / Math.min.apply(null, arr) : Math.max.apply(null, arr));\n    }\n  }\n\n  function getCloneCountForLoop() {\n    var itemsMax = getItemsMax(),\n        result = carousel ? Math.ceil((itemsMax * 5 - slideCount) / 2) : itemsMax * 4 - slideCount;\n    result = Math.max(itemsMax, result);\n    return hasOption('edgePadding') ? result + 1 : result;\n  }\n\n  function getWindowWidth() {\n    return win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;\n  }\n\n  function getInsertPosition(pos) {\n    return pos === 'top' ? 'afterbegin' : 'beforeend';\n  }\n\n  function getClientWidth(el) {\n    if (el == null) {\n      return;\n    }\n\n    var div = doc.createElement('div'),\n        rect,\n        width;\n    el.appendChild(div);\n    rect = div.getBoundingClientRect();\n    width = rect.right - rect.left;\n    div.remove();\n    return width || getClientWidth(el.parentNode);\n  }\n\n  function getViewportWidth() {\n    var gap = edgePadding ? edgePadding * 2 - gutter : 0;\n    return getClientWidth(containerParent) - gap;\n  }\n\n  function hasOption(item) {\n    if (options[item]) {\n      return true;\n    } else {\n      if (responsive) {\n        for (var bp in responsive) {\n          if (responsive[bp][item]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  } // get option:\n  // fixed width: viewport, fixedWidth, gutter => items\n  // others: window width => all variables\n  // all: items => slideBy\n\n\n  function getOption(item, ww) {\n    if (ww == null) {\n      ww = windowWidth;\n    }\n\n    if (item === 'items' && fixedWidth) {\n      return Math.floor((viewport + gutter) / (fixedWidth + gutter)) || 1;\n    } else {\n      var result = options[item];\n\n      if (responsive) {\n        for (var bp in responsive) {\n          // bp: convert string to number\n          if (ww >= parseInt(bp)) {\n            if (item in responsive[bp]) {\n              result = responsive[bp][item];\n            }\n          }\n        }\n      }\n\n      if (item === 'slideBy' && result === 'page') {\n        result = getOption('items');\n      }\n\n      if (!carousel && (item === 'slideBy' || item === 'items')) {\n        result = Math.floor(result);\n      }\n\n      return result;\n    }\n  }\n\n  function getSlideMarginLeft(i) {\n    return CALC ? CALC + '(' + i * 100 + '% / ' + slideCountNew + ')' : i * 100 / slideCountNew + '%';\n  }\n\n  function getInnerWrapperStyles(edgePaddingTem, gutterTem, fixedWidthTem, speedTem, autoHeightBP) {\n    var str = '';\n\n    if (edgePaddingTem !== undefined) {\n      var gap = edgePaddingTem;\n\n      if (gutterTem) {\n        gap -= gutterTem;\n      }\n\n      str = horizontal ? 'margin: 0 ' + gap + 'px 0 ' + edgePaddingTem + 'px;' : 'margin: ' + edgePaddingTem + 'px 0 ' + gap + 'px 0;';\n    } else if (gutterTem && !fixedWidthTem) {\n      var gutterTemUnit = '-' + gutterTem + 'px',\n          dir = horizontal ? gutterTemUnit + ' 0 0' : '0 ' + gutterTemUnit + ' 0';\n      str = 'margin: 0 ' + dir + ';';\n    }\n\n    if (!carousel && autoHeightBP && TRANSITIONDURATION && speedTem) {\n      str += getTransitionDurationStyle(speedTem);\n    }\n\n    return str;\n  }\n\n  function getContainerWidth(fixedWidthTem, gutterTem, itemsTem) {\n    if (fixedWidthTem) {\n      return (fixedWidthTem + gutterTem) * slideCountNew + 'px';\n    } else {\n      return CALC ? CALC + '(' + slideCountNew * 100 + '% / ' + itemsTem + ')' : slideCountNew * 100 / itemsTem + '%';\n    }\n  }\n\n  function getSlideWidthStyle(fixedWidthTem, gutterTem, itemsTem) {\n    var width;\n\n    if (fixedWidthTem) {\n      width = fixedWidthTem + gutterTem + 'px';\n    } else {\n      if (!carousel) {\n        itemsTem = Math.floor(itemsTem);\n      }\n\n      var dividend = carousel ? slideCountNew : itemsTem;\n      width = CALC ? CALC + '(100% / ' + dividend + ')' : 100 / dividend + '%';\n    }\n\n    width = 'width:' + width; // inner slider: overwrite outer slider styles\n\n    return nested !== 'inner' ? width + ';' : width + ' !important;';\n  }\n\n  function getSlideGutterStyle(gutterTem) {\n    var str = ''; // gutter maybe interger || 0\n    // so can't use 'if (gutter)'\n\n    if (gutterTem !== false) {\n      var prop = horizontal ? 'padding-' : 'margin-',\n          dir = horizontal ? 'right' : 'bottom';\n      str = prop + dir + ': ' + gutterTem + 'px;';\n    }\n\n    return str;\n  }\n\n  function getCSSPrefix(name, num) {\n    var prefix = name.substring(0, name.length - num).toLowerCase();\n\n    if (prefix) {\n      prefix = '-' + prefix + '-';\n    }\n\n    return prefix;\n  }\n\n  function getTransitionDurationStyle(speed) {\n    return getCSSPrefix(TRANSITIONDURATION, 18) + 'transition-duration:' + speed / 1000 + 's;';\n  }\n\n  function getAnimationDurationStyle(speed) {\n    return getCSSPrefix(ANIMATIONDURATION, 17) + 'animation-duration:' + speed / 1000 + 's;';\n  }\n\n  function initStructure() {\n    var classOuter = 'tns-outer',\n        classInner = 'tns-inner';\n        hasOption('gutter');\n    outerWrapper.className = classOuter;\n    innerWrapper.className = classInner;\n    outerWrapper.id = slideId + '-ow';\n    innerWrapper.id = slideId + '-iw'; // set container properties\n\n    if (container.id === '') {\n      container.id = slideId;\n    }\n\n    newContainerClasses += PERCENTAGELAYOUT || autoWidth ? ' tns-subpixel' : ' tns-no-subpixel';\n    newContainerClasses += CALC ? ' tns-calc' : ' tns-no-calc';\n\n    if (autoWidth) {\n      newContainerClasses += ' tns-autowidth';\n    }\n\n    newContainerClasses += ' tns-' + options.axis;\n    container.className += newContainerClasses; // add constrain layer for carousel\n\n    if (carousel) {\n      middleWrapper = doc.createElement('div');\n      middleWrapper.id = slideId + '-mw';\n      middleWrapper.className = 'tns-ovh';\n      outerWrapper.appendChild(middleWrapper);\n      middleWrapper.appendChild(innerWrapper);\n    } else {\n      outerWrapper.appendChild(innerWrapper);\n    }\n\n    if (autoHeight) {\n      var wp = middleWrapper ? middleWrapper : innerWrapper;\n      wp.className += ' tns-ah';\n    }\n\n    containerParent.insertBefore(outerWrapper, container);\n    innerWrapper.appendChild(container); // add id, class, aria attributes\n    // before clone slides\n\n    forEach(slideItems, function (item, i) {\n      addClass(item, 'tns-item');\n\n      if (!item.id) {\n        item.id = slideId + '-item' + i;\n      }\n\n      if (!carousel && animateNormal) {\n        addClass(item, animateNormal);\n      }\n\n      setAttrs(item, {\n        'aria-hidden': 'true',\n        'tabindex': '-1'\n      });\n    }); // ## clone slides\n    // carousel: n + slides + n\n    // gallery:      slides + n\n\n    if (cloneCount) {\n      var fragmentBefore = doc.createDocumentFragment(),\n          fragmentAfter = doc.createDocumentFragment();\n\n      for (var j = cloneCount; j--;) {\n        var num = j % slideCount,\n            cloneFirst = slideItems[num].cloneNode(true);\n        addClass(cloneFirst, slideClonedClass);\n        removeAttrs(cloneFirst, 'id');\n        fragmentAfter.insertBefore(cloneFirst, fragmentAfter.firstChild);\n\n        if (carousel) {\n          var cloneLast = slideItems[slideCount - 1 - num].cloneNode(true);\n          addClass(cloneLast, slideClonedClass);\n          removeAttrs(cloneLast, 'id');\n          fragmentBefore.appendChild(cloneLast);\n        }\n      }\n\n      container.insertBefore(fragmentBefore, container.firstChild);\n      container.appendChild(fragmentAfter);\n      slideItems = container.children;\n    }\n  }\n\n  function initSliderTransform() {\n    // ## images loaded/failed\n    if (hasOption('autoHeight') || autoWidth || !horizontal) {\n      var imgs = container.querySelectorAll('img'); // add img load event listener\n\n      forEach(imgs, function (img) {\n        var src = img.src;\n\n        if (!lazyload) {\n          // not data img\n          if (src && src.indexOf('data:image') < 0) {\n            img.src = '';\n            addEvents(img, imgEvents);\n            addClass(img, 'loading');\n            img.src = src; // data img\n          } else {\n            imgLoaded(img);\n          }\n        }\n      }); // set imgsComplete\n\n      raf(function () {\n        imgsLoadedCheck(arrayFromNodeList(imgs), function () {\n          imgsComplete = true;\n        });\n      }); // reset imgs for auto height: check visible imgs only\n\n      if (hasOption('autoHeight')) {\n        imgs = getImageArray(index, Math.min(index + items - 1, slideCountNew - 1));\n      }\n\n      lazyload ? initSliderTransformStyleCheck() : raf(function () {\n        imgsLoadedCheck(arrayFromNodeList(imgs), initSliderTransformStyleCheck);\n      });\n    } else {\n      // set container transform property\n      if (carousel) {\n        doContainerTransformSilent();\n      } // update slider tools and events\n\n\n      initTools();\n      initEvents();\n    }\n  }\n\n  function initSliderTransformStyleCheck() {\n    if (autoWidth && slideCount > 1) {\n      // check styles application\n      var num = loop ? index : slideCount - 1;\n\n      (function stylesApplicationCheck() {\n        var left = slideItems[num].getBoundingClientRect().left;\n        var right = slideItems[num - 1].getBoundingClientRect().right;\n        Math.abs(left - right) <= 1 ? initSliderTransformCore() : setTimeout(function () {\n          stylesApplicationCheck();\n        }, 16);\n      })();\n    } else {\n      initSliderTransformCore();\n    }\n  }\n\n  function initSliderTransformCore() {\n    // run Fn()s which are rely on image loading\n    if (!horizontal || autoWidth) {\n      setSlidePositions();\n\n      if (autoWidth) {\n        rightBoundary = getRightBoundary();\n\n        if (freezable) {\n          freeze = getFreeze();\n        }\n\n        indexMax = getIndexMax(); // <= slidePositions, rightBoundary <=\n\n        resetVariblesWhenDisable(disable || freeze);\n      } else {\n        updateContentWrapperHeight();\n      }\n    } // set container transform property\n\n\n    if (carousel) {\n      doContainerTransformSilent();\n    } // update slider tools and events\n\n\n    initTools();\n    initEvents();\n  }\n\n  function initSheet() {\n    // gallery:\n    // set animation classes and left value for gallery slider\n    if (!carousel) {\n      for (var i = index, l = index + Math.min(slideCount, items); i < l; i++) {\n        var item = slideItems[i];\n        item.style.left = (i - index) * 100 / items + '%';\n        addClass(item, animateIn);\n        removeClass(item, animateNormal);\n      }\n    } // #### LAYOUT\n    // ## INLINE-BLOCK VS FLOAT\n    // ## PercentageLayout:\n    // slides: inline-block\n    // remove blank space between slides by set font-size: 0\n    // ## Non PercentageLayout:\n    // slides: float\n    //         margin-right: -100%\n    //         margin-left: ~\n    // Resource: https://docs.google.com/spreadsheets/d/147up245wwTXeQYve3BRSAD4oVcvQmuGsFteJOeA5xNQ/edit?usp=sharing\n\n\n    if (horizontal) {\n      if (PERCENTAGELAYOUT || autoWidth) {\n        addCSSRule(sheet, '#' + slideId + ' > .tns-item', 'font-size:' + win.getComputedStyle(slideItems[0]).fontSize + ';', getCssRulesLength(sheet));\n        addCSSRule(sheet, '#' + slideId, 'font-size:0;', getCssRulesLength(sheet));\n      } else if (carousel) {\n        forEach(slideItems, function (slide, i) {\n          slide.style.marginLeft = getSlideMarginLeft(i);\n        });\n      }\n    } // ## BASIC STYLES\n\n\n    if (CSSMQ) {\n      // middle wrapper style\n      if (TRANSITIONDURATION) {\n        var str = middleWrapper && options.autoHeight ? getTransitionDurationStyle(options.speed) : '';\n        addCSSRule(sheet, '#' + slideId + '-mw', str, getCssRulesLength(sheet));\n      } // inner wrapper styles\n\n\n      str = getInnerWrapperStyles(options.edgePadding, options.gutter, options.fixedWidth, options.speed, options.autoHeight);\n      addCSSRule(sheet, '#' + slideId + '-iw', str, getCssRulesLength(sheet)); // container styles\n\n      if (carousel) {\n        str = horizontal && !autoWidth ? 'width:' + getContainerWidth(options.fixedWidth, options.gutter, options.items) + ';' : '';\n\n        if (TRANSITIONDURATION) {\n          str += getTransitionDurationStyle(speed);\n        }\n\n        addCSSRule(sheet, '#' + slideId, str, getCssRulesLength(sheet));\n      } // slide styles\n\n\n      str = horizontal && !autoWidth ? getSlideWidthStyle(options.fixedWidth, options.gutter, options.items) : '';\n\n      if (options.gutter) {\n        str += getSlideGutterStyle(options.gutter);\n      } // set gallery items transition-duration\n\n\n      if (!carousel) {\n        if (TRANSITIONDURATION) {\n          str += getTransitionDurationStyle(speed);\n        }\n\n        if (ANIMATIONDURATION) {\n          str += getAnimationDurationStyle(speed);\n        }\n      }\n\n      if (str) {\n        addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n      } // non CSS mediaqueries: IE8\n      // ## update inner wrapper, container, slides if needed\n      // set inline styles for inner wrapper & container\n      // insert stylesheet (one line) for slides only (since slides are many)\n\n    } else {\n      // middle wrapper styles\n      update_carousel_transition_duration(); // inner wrapper styles\n\n      innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, autoHeight); // container styles\n\n      if (carousel && horizontal && !autoWidth) {\n        container.style.width = getContainerWidth(fixedWidth, gutter, items);\n      } // slide styles\n\n\n      var str = horizontal && !autoWidth ? getSlideWidthStyle(fixedWidth, gutter, items) : '';\n\n      if (gutter) {\n        str += getSlideGutterStyle(gutter);\n      } // append to the last line\n\n\n      if (str) {\n        addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n      }\n    } // ## MEDIAQUERIES\n\n\n    if (responsive && CSSMQ) {\n      for (var bp in responsive) {\n        // bp: convert string to number\n        bp = parseInt(bp);\n        var opts = responsive[bp],\n            str = '',\n            middleWrapperStr = '',\n            innerWrapperStr = '',\n            containerStr = '',\n            slideStr = '',\n            itemsBP = !autoWidth ? getOption('items', bp) : null,\n            fixedWidthBP = getOption('fixedWidth', bp),\n            speedBP = getOption('speed', bp),\n            edgePaddingBP = getOption('edgePadding', bp),\n            autoHeightBP = getOption('autoHeight', bp),\n            gutterBP = getOption('gutter', bp); // middle wrapper string\n\n        if (TRANSITIONDURATION && middleWrapper && getOption('autoHeight', bp) && 'speed' in opts) {\n          middleWrapperStr = '#' + slideId + '-mw{' + getTransitionDurationStyle(speedBP) + '}';\n        } // inner wrapper string\n\n\n        if ('edgePadding' in opts || 'gutter' in opts) {\n          innerWrapperStr = '#' + slideId + '-iw{' + getInnerWrapperStyles(edgePaddingBP, gutterBP, fixedWidthBP, speedBP, autoHeightBP) + '}';\n        } // container string\n\n\n        if (carousel && horizontal && !autoWidth && ('fixedWidth' in opts || 'items' in opts || fixedWidth && 'gutter' in opts)) {\n          containerStr = 'width:' + getContainerWidth(fixedWidthBP, gutterBP, itemsBP) + ';';\n        }\n\n        if (TRANSITIONDURATION && 'speed' in opts) {\n          containerStr += getTransitionDurationStyle(speedBP);\n        }\n\n        if (containerStr) {\n          containerStr = '#' + slideId + '{' + containerStr + '}';\n        } // slide string\n\n\n        if ('fixedWidth' in opts || fixedWidth && 'gutter' in opts || !carousel && 'items' in opts) {\n          slideStr += getSlideWidthStyle(fixedWidthBP, gutterBP, itemsBP);\n        }\n\n        if ('gutter' in opts) {\n          slideStr += getSlideGutterStyle(gutterBP);\n        } // set gallery items transition-duration\n\n\n        if (!carousel && 'speed' in opts) {\n          if (TRANSITIONDURATION) {\n            slideStr += getTransitionDurationStyle(speedBP);\n          }\n\n          if (ANIMATIONDURATION) {\n            slideStr += getAnimationDurationStyle(speedBP);\n          }\n        }\n\n        if (slideStr) {\n          slideStr = '#' + slideId + ' > .tns-item{' + slideStr + '}';\n        } // add up\n\n\n        str = middleWrapperStr + innerWrapperStr + containerStr + slideStr;\n\n        if (str) {\n          sheet.insertRule('@media (min-width: ' + bp / 16 + 'em) {' + str + '}', sheet.cssRules.length);\n        }\n      }\n    }\n  }\n\n  function initTools() {\n    // == slides ==\n    updateSlideStatus(); // == live region ==\n\n    outerWrapper.insertAdjacentHTML('afterbegin', '<div class=\"tns-liveregion tns-visually-hidden\" aria-live=\"polite\" aria-atomic=\"true\">slide <span class=\"current\">' + getLiveRegionStr() + '</span>  of ' + slideCount + '</div>');\n    liveregionCurrent = outerWrapper.querySelector('.tns-liveregion .current'); // == autoplayInit ==\n\n    if (hasAutoplay) {\n      var txt = autoplay ? 'stop' : 'start';\n\n      if (autoplayButton) {\n        setAttrs(autoplayButton, {\n          'data-action': txt\n        });\n      } else if (options.autoplayButtonOutput) {\n        outerWrapper.insertAdjacentHTML(getInsertPosition(options.autoplayPosition), '<button type=\"button\" data-action=\"' + txt + '\">' + autoplayHtmlStrings[0] + txt + autoplayHtmlStrings[1] + autoplayText[0] + '</button>');\n        autoplayButton = outerWrapper.querySelector('[data-action]');\n      } // add event\n\n\n      if (autoplayButton) {\n        addEvents(autoplayButton, {\n          'click': toggleAutoplay\n        });\n      }\n\n      if (autoplay) {\n        startAutoplay();\n\n        if (autoplayHoverPause) {\n          addEvents(container, hoverEvents);\n        }\n\n        if (autoplayResetOnVisibility) {\n          addEvents(container, visibilityEvent);\n        }\n      }\n    } // == navInit ==\n\n\n    if (hasNav) {\n      // will not hide the navs in case they're thumbnails\n\n      if (navContainer) {\n        setAttrs(navContainer, {\n          'aria-label': 'Carousel Pagination'\n        });\n        navItems = navContainer.children;\n        forEach(navItems, function (item, i) {\n          setAttrs(item, {\n            'data-nav': i,\n            'tabindex': '-1',\n            'aria-label': navStr + (i + 1),\n            'aria-controls': slideId\n          });\n        }); // generated nav\n      } else {\n        var navHtml = '',\n            hiddenStr = navAsThumbnails ? '' : 'style=\"display:none\"';\n\n        for (var i = 0; i < slideCount; i++) {\n          // hide nav items by default\n          navHtml += '<button type=\"button\" data-nav=\"' + i + '\" tabindex=\"-1\" aria-controls=\"' + slideId + '\" ' + hiddenStr + ' aria-label=\"' + navStr + (i + 1) + '\"></button>';\n        }\n\n        navHtml = '<div class=\"tns-nav\" aria-label=\"Carousel Pagination\">' + navHtml + '</div>';\n        outerWrapper.insertAdjacentHTML(getInsertPosition(options.navPosition), navHtml);\n        navContainer = outerWrapper.querySelector('.tns-nav');\n        navItems = navContainer.children;\n      }\n\n      updateNavVisibility(); // add transition\n\n      if (TRANSITIONDURATION) {\n        var prefix = TRANSITIONDURATION.substring(0, TRANSITIONDURATION.length - 18).toLowerCase(),\n            str = 'transition: all ' + speed / 1000 + 's';\n\n        if (prefix) {\n          str = '-' + prefix + '-' + str;\n        }\n\n        addCSSRule(sheet, '[aria-controls^=' + slideId + '-item]', str, getCssRulesLength(sheet));\n      }\n\n      setAttrs(navItems[navCurrentIndex], {\n        'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent\n      });\n      removeAttrs(navItems[navCurrentIndex], 'tabindex');\n      addClass(navItems[navCurrentIndex], navActiveClass); // add events\n\n      addEvents(navContainer, navEvents);\n    } // == controlsInit ==\n\n\n    if (hasControls) {\n      if (!controlsContainer && (!prevButton || !nextButton)) {\n        outerWrapper.insertAdjacentHTML(getInsertPosition(options.controlsPosition), '<div class=\"tns-controls\" aria-label=\"Carousel Navigation\" tabindex=\"0\"><button type=\"button\" data-controls=\"prev\" tabindex=\"-1\" aria-controls=\"' + slideId + '\">' + controlsText[0] + '</button><button type=\"button\" data-controls=\"next\" tabindex=\"-1\" aria-controls=\"' + slideId + '\">' + controlsText[1] + '</button></div>');\n        controlsContainer = outerWrapper.querySelector('.tns-controls');\n      }\n\n      if (!prevButton || !nextButton) {\n        prevButton = controlsContainer.children[0];\n        nextButton = controlsContainer.children[1];\n      }\n\n      if (options.controlsContainer) {\n        setAttrs(controlsContainer, {\n          'aria-label': 'Carousel Navigation',\n          'tabindex': '0'\n        });\n      }\n\n      if (options.controlsContainer || options.prevButton && options.nextButton) {\n        setAttrs([prevButton, nextButton], {\n          'aria-controls': slideId,\n          'tabindex': '-1'\n        });\n      }\n\n      if (options.controlsContainer || options.prevButton && options.nextButton) {\n        setAttrs(prevButton, {\n          'data-controls': 'prev'\n        });\n        setAttrs(nextButton, {\n          'data-controls': 'next'\n        });\n      }\n\n      prevIsButton = isButton(prevButton);\n      nextIsButton = isButton(nextButton);\n      updateControlsStatus(); // add events\n\n      if (controlsContainer) {\n        addEvents(controlsContainer, controlsEvents);\n      } else {\n        addEvents(prevButton, controlsEvents);\n        addEvents(nextButton, controlsEvents);\n      }\n    } // hide tools if needed\n\n\n    disableUI();\n  }\n\n  function initEvents() {\n    // add events\n    if (carousel && TRANSITIONEND) {\n      var eve = {};\n      eve[TRANSITIONEND] = onTransitionEnd;\n      addEvents(container, eve);\n    }\n\n    if (touch) {\n      addEvents(container, touchEvents, options.preventScrollOnTouch);\n    }\n\n    if (mouseDrag) {\n      addEvents(container, dragEvents);\n    }\n\n    if (arrowKeys) {\n      addEvents(doc, docmentKeydownEvent);\n    }\n\n    if (nested === 'inner') {\n      events.on('outerResized', function () {\n        resizeTasks();\n        events.emit('innerLoaded', info());\n      });\n    } else if (responsive || fixedWidth || autoWidth || autoHeight || !horizontal) {\n      addEvents(win, {\n        'resize': onResize\n      });\n    }\n\n    if (autoHeight) {\n      if (nested === 'outer') {\n        events.on('innerLoaded', doAutoHeight);\n      } else if (!disable) {\n        doAutoHeight();\n      }\n    }\n\n    doLazyLoad();\n\n    if (disable) {\n      disableSlider();\n    } else if (freeze) {\n      freezeSlider();\n    }\n\n    events.on('indexChanged', additionalUpdates);\n\n    if (nested === 'inner') {\n      events.emit('innerLoaded', info());\n    }\n\n    if (typeof onInit === 'function') {\n      onInit(info());\n    }\n\n    isOn = true;\n  }\n\n  function destroy() {\n    // sheet\n    sheet.disabled = true;\n\n    if (sheet.ownerNode) {\n      sheet.ownerNode.remove();\n    } // remove win event listeners\n\n\n    removeEvents(win, {\n      'resize': onResize\n    }); // arrowKeys, controls, nav\n\n    if (arrowKeys) {\n      removeEvents(doc, docmentKeydownEvent);\n    }\n\n    if (controlsContainer) {\n      removeEvents(controlsContainer, controlsEvents);\n    }\n\n    if (navContainer) {\n      removeEvents(navContainer, navEvents);\n    } // autoplay\n\n\n    removeEvents(container, hoverEvents);\n    removeEvents(container, visibilityEvent);\n\n    if (autoplayButton) {\n      removeEvents(autoplayButton, {\n        'click': toggleAutoplay\n      });\n    }\n\n    if (autoplay) {\n      clearInterval(autoplayTimer);\n    } // container\n\n\n    if (carousel && TRANSITIONEND) {\n      var eve = {};\n      eve[TRANSITIONEND] = onTransitionEnd;\n      removeEvents(container, eve);\n    }\n\n    if (touch) {\n      removeEvents(container, touchEvents);\n    }\n\n    if (mouseDrag) {\n      removeEvents(container, dragEvents);\n    } // cache Object values in options && reset HTML\n\n\n    var htmlList = [containerHTML, controlsContainerHTML, prevButtonHTML, nextButtonHTML, navContainerHTML, autoplayButtonHTML];\n    tnsList.forEach(function (item, i) {\n      var el = item === 'container' ? outerWrapper : options[item];\n\n      if (typeof el === 'object' && el) {\n        var prevEl = el.previousElementSibling ? el.previousElementSibling : false,\n            parentEl = el.parentNode;\n        el.outerHTML = htmlList[i];\n        options[item] = prevEl ? prevEl.nextElementSibling : parentEl.firstElementChild;\n      }\n    }); // reset variables\n\n    tnsList = animateIn = animateOut = animateDelay = animateNormal = horizontal = outerWrapper = innerWrapper = container = containerParent = containerHTML = slideItems = slideCount = breakpointZone = windowWidth = autoWidth = fixedWidth = edgePadding = gutter = viewport = items = slideBy = viewportMax = arrowKeys = speed = rewind = loop = autoHeight = sheet = lazyload = slidePositions = slideItemsOut = cloneCount = slideCountNew = hasRightDeadZone = rightBoundary = updateIndexBeforeTransform = transformAttr = transformPrefix = transformPostfix = getIndexMax = index = indexCached = indexMin = indexMax = swipeAngle = moveDirectionExpected = running = onInit = events = newContainerClasses = slideId = disable = disabled = freezable = freeze = frozen = controlsEvents = navEvents = hoverEvents = visibilityEvent = docmentKeydownEvent = touchEvents = dragEvents = hasControls = hasNav = navAsThumbnails = hasAutoplay = hasTouch = hasMouseDrag = slideActiveClass = imgCompleteClass = imgEvents = imgsComplete = controls = controlsText = controlsContainer = controlsContainerHTML = prevButton = nextButton = prevIsButton = nextIsButton = nav = navContainer = navContainerHTML = navItems = pages = pagesCached = navClicked = navCurrentIndex = navCurrentIndexCached = navActiveClass = navStr = navStrCurrent = autoplay = autoplayTimeout = autoplayDirection = autoplayText = autoplayHoverPause = autoplayButton = autoplayButtonHTML = autoplayResetOnVisibility = autoplayHtmlStrings = autoplayTimer = animating = autoplayHoverPaused = autoplayUserPaused = autoplayVisibilityPaused = initPosition = lastPosition = translateInit = panStart = rafIndex = getDist = touch = mouseDrag = null; // check variables\n    // [animateIn, animateOut, animateDelay, animateNormal, horizontal, outerWrapper, innerWrapper, container, containerParent, containerHTML, slideItems, slideCount, breakpointZone, windowWidth, autoWidth, fixedWidth, edgePadding, gutter, viewport, items, slideBy, viewportMax, arrowKeys, speed, rewind, loop, autoHeight, sheet, lazyload, slidePositions, slideItemsOut, cloneCount, slideCountNew, hasRightDeadZone, rightBoundary, updateIndexBeforeTransform, transformAttr, transformPrefix, transformPostfix, getIndexMax, index, indexCached, indexMin, indexMax, resizeTimer, swipeAngle, moveDirectionExpected, running, onInit, events, newContainerClasses, slideId, disable, disabled, freezable, freeze, frozen, controlsEvents, navEvents, hoverEvents, visibilityEvent, docmentKeydownEvent, touchEvents, dragEvents, hasControls, hasNav, navAsThumbnails, hasAutoplay, hasTouch, hasMouseDrag, slideActiveClass, imgCompleteClass, imgEvents, imgsComplete, controls, controlsText, controlsContainer, controlsContainerHTML, prevButton, nextButton, prevIsButton, nextIsButton, nav, navContainer, navContainerHTML, navItems, pages, pagesCached, navClicked, navCurrentIndex, navCurrentIndexCached, navActiveClass, navStr, navStrCurrent, autoplay, autoplayTimeout, autoplayDirection, autoplayText, autoplayHoverPause, autoplayButton, autoplayButtonHTML, autoplayResetOnVisibility, autoplayHtmlStrings, autoplayTimer, animating, autoplayHoverPaused, autoplayUserPaused, autoplayVisibilityPaused, initPosition, lastPosition, translateInit, disX, disY, panStart, rafIndex, getDist, touch, mouseDrag ].forEach(function(item) { if (item !== null) { console.log(item); } });\n\n    for (var a in this) {\n      if (a !== 'rebuild') {\n        this[a] = null;\n      }\n    }\n\n    isOn = false;\n  } // === ON RESIZE ===\n  // responsive || fixedWidth || autoWidth || !horizontal\n\n\n  function onResize(e) {\n    raf(function () {\n      resizeTasks(getEvent(e));\n    });\n  }\n\n  function resizeTasks(e) {\n    if (!isOn) {\n      return;\n    }\n\n    if (nested === 'outer') {\n      events.emit('outerResized', info(e));\n    }\n\n    windowWidth = getWindowWidth();\n    var bpChanged,\n        breakpointZoneTem = breakpointZone,\n        needContainerTransform = false;\n\n    if (responsive) {\n      setBreakpointZone();\n      bpChanged = breakpointZoneTem !== breakpointZone; // if (hasRightDeadZone) { needContainerTransform = true; } // *?\n\n      if (bpChanged) {\n        events.emit('newBreakpointStart', info(e));\n      }\n    }\n\n    var indChanged,\n        itemsChanged,\n        itemsTem = items,\n        disableTem = disable,\n        freezeTem = freeze,\n        arrowKeysTem = arrowKeys,\n        controlsTem = controls,\n        navTem = nav,\n        touchTem = touch,\n        mouseDragTem = mouseDrag,\n        autoplayTem = autoplay,\n        autoplayHoverPauseTem = autoplayHoverPause,\n        autoplayResetOnVisibilityTem = autoplayResetOnVisibility,\n        indexTem = index;\n\n    if (bpChanged) {\n      var fixedWidthTem = fixedWidth,\n          autoHeightTem = autoHeight,\n          controlsTextTem = controlsText,\n          centerTem = center,\n          autoplayTextTem = autoplayText;\n\n      if (!CSSMQ) {\n        var gutterTem = gutter,\n            edgePaddingTem = edgePadding;\n      }\n    } // get option:\n    // fixed width: viewport, fixedWidth, gutter => items\n    // others: window width => all variables\n    // all: items => slideBy\n\n\n    arrowKeys = getOption('arrowKeys');\n    controls = getOption('controls');\n    nav = getOption('nav');\n    touch = getOption('touch');\n    center = getOption('center');\n    mouseDrag = getOption('mouseDrag');\n    autoplay = getOption('autoplay');\n    autoplayHoverPause = getOption('autoplayHoverPause');\n    autoplayResetOnVisibility = getOption('autoplayResetOnVisibility');\n\n    if (bpChanged) {\n      disable = getOption('disable');\n      fixedWidth = getOption('fixedWidth');\n      speed = getOption('speed');\n      autoHeight = getOption('autoHeight');\n      controlsText = getOption('controlsText');\n      autoplayText = getOption('autoplayText');\n      autoplayTimeout = getOption('autoplayTimeout');\n\n      if (!CSSMQ) {\n        edgePadding = getOption('edgePadding');\n        gutter = getOption('gutter');\n      }\n    } // update options\n\n\n    resetVariblesWhenDisable(disable);\n    viewport = getViewportWidth(); // <= edgePadding, gutter\n\n    if ((!horizontal || autoWidth) && !disable) {\n      setSlidePositions();\n\n      if (!horizontal) {\n        updateContentWrapperHeight(); // <= setSlidePositions\n\n        needContainerTransform = true;\n      }\n    }\n\n    if (fixedWidth || autoWidth) {\n      rightBoundary = getRightBoundary(); // autoWidth: <= viewport, slidePositions, gutter\n      // fixedWidth: <= viewport, fixedWidth, gutter\n\n      indexMax = getIndexMax(); // autoWidth: <= rightBoundary, slidePositions\n      // fixedWidth: <= rightBoundary, fixedWidth, gutter\n    }\n\n    if (bpChanged || fixedWidth) {\n      items = getOption('items');\n      slideBy = getOption('slideBy');\n      itemsChanged = items !== itemsTem;\n\n      if (itemsChanged) {\n        if (!fixedWidth && !autoWidth) {\n          indexMax = getIndexMax();\n        } // <= items\n        // check index before transform in case\n        // slider reach the right edge then items become bigger\n\n\n        updateIndex();\n      }\n    }\n\n    if (bpChanged) {\n      if (disable !== disableTem) {\n        if (disable) {\n          disableSlider();\n        } else {\n          enableSlider(); // <= slidePositions, rightBoundary, indexMax\n        }\n      }\n    }\n\n    if (freezable && (bpChanged || fixedWidth || autoWidth)) {\n      freeze = getFreeze(); // <= autoWidth: slidePositions, gutter, viewport, rightBoundary\n      // <= fixedWidth: fixedWidth, gutter, rightBoundary\n      // <= others: items\n\n      if (freeze !== freezeTem) {\n        if (freeze) {\n          doContainerTransform(getContainerTransformValue(getStartIndex(0)));\n          freezeSlider();\n        } else {\n          unfreezeSlider();\n          needContainerTransform = true;\n        }\n      }\n    }\n\n    resetVariblesWhenDisable(disable || freeze); // controls, nav, touch, mouseDrag, arrowKeys, autoplay, autoplayHoverPause, autoplayResetOnVisibility\n\n    if (!autoplay) {\n      autoplayHoverPause = autoplayResetOnVisibility = false;\n    }\n\n    if (arrowKeys !== arrowKeysTem) {\n      arrowKeys ? addEvents(doc, docmentKeydownEvent) : removeEvents(doc, docmentKeydownEvent);\n    }\n\n    if (controls !== controlsTem) {\n      if (controls) {\n        if (controlsContainer) {\n          showElement(controlsContainer);\n        } else {\n          if (prevButton) {\n            showElement(prevButton);\n          }\n\n          if (nextButton) {\n            showElement(nextButton);\n          }\n        }\n      } else {\n        if (controlsContainer) {\n          hideElement(controlsContainer);\n        } else {\n          if (prevButton) {\n            hideElement(prevButton);\n          }\n\n          if (nextButton) {\n            hideElement(nextButton);\n          }\n        }\n      }\n    }\n\n    if (nav !== navTem) {\n      if (nav) {\n        showElement(navContainer);\n        updateNavVisibility();\n      } else {\n        hideElement(navContainer);\n      }\n    }\n\n    if (touch !== touchTem) {\n      touch ? addEvents(container, touchEvents, options.preventScrollOnTouch) : removeEvents(container, touchEvents);\n    }\n\n    if (mouseDrag !== mouseDragTem) {\n      mouseDrag ? addEvents(container, dragEvents) : removeEvents(container, dragEvents);\n    }\n\n    if (autoplay !== autoplayTem) {\n      if (autoplay) {\n        if (autoplayButton) {\n          showElement(autoplayButton);\n        }\n\n        if (!animating && !autoplayUserPaused) {\n          startAutoplay();\n        }\n      } else {\n        if (autoplayButton) {\n          hideElement(autoplayButton);\n        }\n\n        if (animating) {\n          stopAutoplay();\n        }\n      }\n    }\n\n    if (autoplayHoverPause !== autoplayHoverPauseTem) {\n      autoplayHoverPause ? addEvents(container, hoverEvents) : removeEvents(container, hoverEvents);\n    }\n\n    if (autoplayResetOnVisibility !== autoplayResetOnVisibilityTem) {\n      autoplayResetOnVisibility ? addEvents(doc, visibilityEvent) : removeEvents(doc, visibilityEvent);\n    }\n\n    if (bpChanged) {\n      if (fixedWidth !== fixedWidthTem || center !== centerTem) {\n        needContainerTransform = true;\n      }\n\n      if (autoHeight !== autoHeightTem) {\n        if (!autoHeight) {\n          innerWrapper.style.height = '';\n        }\n      }\n\n      if (controls && controlsText !== controlsTextTem) {\n        prevButton.innerHTML = controlsText[0];\n        nextButton.innerHTML = controlsText[1];\n      }\n\n      if (autoplayButton && autoplayText !== autoplayTextTem) {\n        var i = autoplay ? 1 : 0,\n            html = autoplayButton.innerHTML,\n            len = html.length - autoplayTextTem[i].length;\n\n        if (html.substring(len) === autoplayTextTem[i]) {\n          autoplayButton.innerHTML = html.substring(0, len) + autoplayText[i];\n        }\n      }\n    } else {\n      if (center && (fixedWidth || autoWidth)) {\n        needContainerTransform = true;\n      }\n    }\n\n    if (itemsChanged || fixedWidth && !autoWidth) {\n      pages = getPages();\n      updateNavVisibility();\n    }\n\n    indChanged = index !== indexTem;\n\n    if (indChanged) {\n      events.emit('indexChanged', info());\n      needContainerTransform = true;\n    } else if (itemsChanged) {\n      if (!indChanged) {\n        additionalUpdates();\n      }\n    } else if (fixedWidth || autoWidth) {\n      doLazyLoad();\n      updateSlideStatus();\n      updateLiveRegion();\n    }\n\n    if (itemsChanged && !carousel) {\n      updateGallerySlidePositions();\n    }\n\n    if (!disable && !freeze) {\n      // non-mediaqueries: IE8\n      if (bpChanged && !CSSMQ) {\n        // middle wrapper styles\n        // inner wrapper styles\n        if (edgePadding !== edgePaddingTem || gutter !== gutterTem) {\n          innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, speed, autoHeight);\n        }\n\n        if (horizontal) {\n          // container styles\n          if (carousel) {\n            container.style.width = getContainerWidth(fixedWidth, gutter, items);\n          } // slide styles\n\n\n          var str = getSlideWidthStyle(fixedWidth, gutter, items) + getSlideGutterStyle(gutter); // remove the last line and\n          // add new styles\n\n          removeCSSRule(sheet, getCssRulesLength(sheet) - 1);\n          addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n        }\n      } // auto height\n\n\n      if (autoHeight) {\n        doAutoHeight();\n      }\n\n      if (needContainerTransform) {\n        doContainerTransformSilent();\n        indexCached = index;\n      }\n    }\n\n    if (bpChanged) {\n      events.emit('newBreakpointEnd', info(e));\n    }\n  } // === INITIALIZATION FUNCTIONS === //\n\n\n  function getFreeze() {\n    if (!fixedWidth && !autoWidth) {\n      var a = center ? items - (items - 1) / 2 : items;\n      return slideCount <= a;\n    }\n\n    var width = fixedWidth ? (fixedWidth + gutter) * slideCount : slidePositions[slideCount],\n        vp = edgePadding ? viewport + edgePadding * 2 : viewport + gutter;\n\n    if (center) {\n      vp -= fixedWidth ? (viewport - fixedWidth) / 2 : (viewport - (slidePositions[index + 1] - slidePositions[index] - gutter)) / 2;\n    }\n\n    return width <= vp;\n  }\n\n  function setBreakpointZone() {\n    breakpointZone = 0;\n\n    for (var bp in responsive) {\n      bp = parseInt(bp); // convert string to number\n\n      if (windowWidth >= bp) {\n        breakpointZone = bp;\n      }\n    }\n  } // (slideBy, indexMin, indexMax) => index\n\n\n  var updateIndex = function () {\n    return loop ? carousel ? // loop + carousel\n    function () {\n      var leftEdge = indexMin,\n          rightEdge = indexMax;\n      leftEdge += slideBy;\n      rightEdge -= slideBy; // adjust edges when has edge paddings\n      // or fixed-width slider with extra space on the right side\n\n      if (edgePadding) {\n        leftEdge += 1;\n        rightEdge -= 1;\n      } else if (fixedWidth) {\n        if ((viewport + gutter) % (fixedWidth + gutter)) {\n          rightEdge -= 1;\n        }\n      }\n\n      if (cloneCount) {\n        if (index > rightEdge) {\n          index -= slideCount;\n        } else if (index < leftEdge) {\n          index += slideCount;\n        }\n      }\n    } : // loop + gallery\n    function () {\n      if (index > indexMax) {\n        while (index >= indexMin + slideCount) {\n          index -= slideCount;\n        }\n      } else if (index < indexMin) {\n        while (index <= indexMax - slideCount) {\n          index += slideCount;\n        }\n      }\n    } : // non-loop\n    function () {\n      index = Math.max(indexMin, Math.min(indexMax, index));\n    };\n  }();\n\n  function disableUI() {\n    if (!autoplay && autoplayButton) {\n      hideElement(autoplayButton);\n    }\n\n    if (!nav && navContainer) {\n      hideElement(navContainer);\n    }\n\n    if (!controls) {\n      if (controlsContainer) {\n        hideElement(controlsContainer);\n      } else {\n        if (prevButton) {\n          hideElement(prevButton);\n        }\n\n        if (nextButton) {\n          hideElement(nextButton);\n        }\n      }\n    }\n  }\n\n  function enableUI() {\n    if (autoplay && autoplayButton) {\n      showElement(autoplayButton);\n    }\n\n    if (nav && navContainer) {\n      showElement(navContainer);\n    }\n\n    if (controls) {\n      if (controlsContainer) {\n        showElement(controlsContainer);\n      } else {\n        if (prevButton) {\n          showElement(prevButton);\n        }\n\n        if (nextButton) {\n          showElement(nextButton);\n        }\n      }\n    }\n  }\n\n  function freezeSlider() {\n    if (frozen) {\n      return;\n    } // remove edge padding from inner wrapper\n\n\n    if (edgePadding) {\n      innerWrapper.style.margin = '0px';\n    } // add class tns-transparent to cloned slides\n\n\n    if (cloneCount) {\n      var str = 'tns-transparent';\n\n      for (var i = cloneCount; i--;) {\n        if (carousel) {\n          addClass(slideItems[i], str);\n        }\n\n        addClass(slideItems[slideCountNew - i - 1], str);\n      }\n    } // update tools\n\n\n    disableUI();\n    frozen = true;\n  }\n\n  function unfreezeSlider() {\n    if (!frozen) {\n      return;\n    } // restore edge padding for inner wrapper\n    // for mordern browsers\n\n\n    if (edgePadding && CSSMQ) {\n      innerWrapper.style.margin = '';\n    } // remove class tns-transparent to cloned slides\n\n\n    if (cloneCount) {\n      var str = 'tns-transparent';\n\n      for (var i = cloneCount; i--;) {\n        if (carousel) {\n          removeClass(slideItems[i], str);\n        }\n\n        removeClass(slideItems[slideCountNew - i - 1], str);\n      }\n    } // update tools\n\n\n    enableUI();\n    frozen = false;\n  }\n\n  function disableSlider() {\n    if (disabled) {\n      return;\n    }\n\n    sheet.disabled = true;\n    container.className = container.className.replace(newContainerClasses.substring(1), '');\n    removeAttrs(container, ['style']);\n\n    if (loop) {\n      for (var j = cloneCount; j--;) {\n        if (carousel) {\n          hideElement(slideItems[j]);\n        }\n\n        hideElement(slideItems[slideCountNew - j - 1]);\n      }\n    } // vertical slider\n\n\n    if (!horizontal || !carousel) {\n      removeAttrs(innerWrapper, ['style']);\n    } // gallery\n\n\n    if (!carousel) {\n      for (var i = index, l = index + slideCount; i < l; i++) {\n        var item = slideItems[i];\n        removeAttrs(item, ['style']);\n        removeClass(item, animateIn);\n        removeClass(item, animateNormal);\n      }\n    } // update tools\n\n\n    disableUI();\n    disabled = true;\n  }\n\n  function enableSlider() {\n    if (!disabled) {\n      return;\n    }\n\n    sheet.disabled = false;\n    container.className += newContainerClasses;\n    doContainerTransformSilent();\n\n    if (loop) {\n      for (var j = cloneCount; j--;) {\n        if (carousel) {\n          showElement(slideItems[j]);\n        }\n\n        showElement(slideItems[slideCountNew - j - 1]);\n      }\n    } // gallery\n\n\n    if (!carousel) {\n      for (var i = index, l = index + slideCount; i < l; i++) {\n        var item = slideItems[i],\n            classN = i < index + items ? animateIn : animateNormal;\n        item.style.left = (i - index) * 100 / items + '%';\n        addClass(item, classN);\n      }\n    } // update tools\n\n\n    enableUI();\n    disabled = false;\n  }\n\n  function updateLiveRegion() {\n    var str = getLiveRegionStr();\n\n    if (liveregionCurrent.innerHTML !== str) {\n      liveregionCurrent.innerHTML = str;\n    }\n  }\n\n  function getLiveRegionStr() {\n    var arr = getVisibleSlideRange(),\n        start = arr[0] + 1,\n        end = arr[1] + 1;\n    return start === end ? start + '' : start + ' to ' + end;\n  }\n\n  function getVisibleSlideRange(val) {\n    if (val == null) {\n      val = getContainerTransformValue();\n    }\n\n    var start = index,\n        end,\n        rangestart,\n        rangeend; // get range start, range end for autoWidth and fixedWidth\n\n    if (center || edgePadding) {\n      if (autoWidth || fixedWidth) {\n        rangestart = -(parseFloat(val) + edgePadding);\n        rangeend = rangestart + viewport + edgePadding * 2;\n      }\n    } else {\n      if (autoWidth) {\n        rangestart = slidePositions[index];\n        rangeend = rangestart + viewport;\n      }\n    } // get start, end\n    // - check auto width\n\n\n    if (autoWidth) {\n      slidePositions.forEach(function (point, i) {\n        if (i < slideCountNew) {\n          if ((center || edgePadding) && point <= rangestart + 0.5) {\n            start = i;\n          }\n\n          if (rangeend - point >= 0.5) {\n            end = i;\n          }\n        }\n      }); // - check percentage width, fixed width\n    } else {\n      if (fixedWidth) {\n        var cell = fixedWidth + gutter;\n\n        if (center || edgePadding) {\n          start = Math.floor(rangestart / cell);\n          end = Math.ceil(rangeend / cell - 1);\n        } else {\n          end = start + Math.ceil(viewport / cell) - 1;\n        }\n      } else {\n        if (center || edgePadding) {\n          var a = items - 1;\n\n          if (center) {\n            start -= a / 2;\n            end = index + a / 2;\n          } else {\n            end = index + a;\n          }\n\n          if (edgePadding) {\n            var b = edgePadding * items / viewport;\n            start -= b;\n            end += b;\n          }\n\n          start = Math.floor(start);\n          end = Math.ceil(end);\n        } else {\n          end = start + items - 1;\n        }\n      }\n\n      start = Math.max(start, 0);\n      end = Math.min(end, slideCountNew - 1);\n    }\n\n    return [start, end];\n  }\n\n  function doLazyLoad() {\n    if (lazyload && !disable) {\n      var arg = getVisibleSlideRange();\n      arg.push(lazyloadSelector);\n      getImageArray.apply(null, arg).forEach(function (img) {\n        if (!hasClass(img, imgCompleteClass)) {\n          // stop propagation transitionend event to container\n          var eve = {};\n\n          eve[TRANSITIONEND] = function (e) {\n            e.stopPropagation();\n          };\n\n          addEvents(img, eve);\n          addEvents(img, imgEvents); // update src\n\n          img.src = getAttr(img, 'data-src'); // update srcset\n\n          var srcset = getAttr(img, 'data-srcset');\n\n          if (srcset) {\n            img.srcset = srcset;\n          }\n\n          addClass(img, 'loading');\n        }\n      });\n    }\n  }\n\n  function onImgLoaded(e) {\n    imgLoaded(getTarget(e));\n  }\n\n  function onImgFailed(e) {\n    imgFailed(getTarget(e));\n  }\n\n  function imgLoaded(img) {\n    addClass(img, 'loaded');\n    imgCompleted(img);\n  }\n\n  function imgFailed(img) {\n    addClass(img, 'failed');\n    imgCompleted(img);\n  }\n\n  function imgCompleted(img) {\n    addClass(img, imgCompleteClass);\n    removeClass(img, 'loading');\n    removeEvents(img, imgEvents);\n  }\n\n  function getImageArray(start, end, imgSelector) {\n    var imgs = [];\n\n    if (!imgSelector) {\n      imgSelector = 'img';\n    }\n\n    while (start <= end) {\n      forEach(slideItems[start].querySelectorAll(imgSelector), function (img) {\n        imgs.push(img);\n      });\n      start++;\n    }\n\n    return imgs;\n  } // check if all visible images are loaded\n  // and update container height if it's done\n\n\n  function doAutoHeight() {\n    var imgs = getImageArray.apply(null, getVisibleSlideRange());\n    raf(function () {\n      imgsLoadedCheck(imgs, updateInnerWrapperHeight);\n    });\n  }\n\n  function imgsLoadedCheck(imgs, cb) {\n    // execute callback function if all images are complete\n    if (imgsComplete) {\n      return cb();\n    } // check image classes\n\n\n    imgs.forEach(function (img, index) {\n      if (!lazyload && img.complete) {\n        imgCompleted(img);\n      } // Check image.complete\n\n\n      if (hasClass(img, imgCompleteClass)) {\n        imgs.splice(index, 1);\n      }\n    }); // execute callback function if selected images are all complete\n\n    if (!imgs.length) {\n      return cb();\n    } // otherwise execute this functiona again\n\n\n    raf(function () {\n      imgsLoadedCheck(imgs, cb);\n    });\n  }\n\n  function additionalUpdates() {\n    doLazyLoad();\n    updateSlideStatus();\n    updateLiveRegion();\n    updateControlsStatus();\n    updateNavStatus();\n  }\n\n  function update_carousel_transition_duration() {\n    if (carousel && autoHeight) {\n      middleWrapper.style[TRANSITIONDURATION] = speed / 1000 + 's';\n    }\n  }\n\n  function getMaxSlideHeight(slideStart, slideRange) {\n    var heights = [];\n\n    for (var i = slideStart, l = Math.min(slideStart + slideRange, slideCountNew); i < l; i++) {\n      heights.push(slideItems[i].offsetHeight);\n    }\n\n    return Math.max.apply(null, heights);\n  } // update inner wrapper height\n  // 1. get the max-height of the visible slides\n  // 2. set transitionDuration to speed\n  // 3. update inner wrapper height to max-height\n  // 4. set transitionDuration to 0s after transition done\n\n\n  function updateInnerWrapperHeight() {\n    var maxHeight = autoHeight ? getMaxSlideHeight(index, items) : getMaxSlideHeight(cloneCount, slideCount),\n        wp = middleWrapper ? middleWrapper : innerWrapper;\n\n    if (wp.style.height !== maxHeight) {\n      wp.style.height = maxHeight + 'px';\n    }\n  } // get the distance from the top edge of the first slide to each slide\n  // (init) => slidePositions\n\n\n  function setSlidePositions() {\n    slidePositions = [0];\n    var attr = horizontal ? 'left' : 'top',\n        attr2 = horizontal ? 'right' : 'bottom',\n        base = slideItems[0].getBoundingClientRect()[attr];\n    forEach(slideItems, function (item, i) {\n      // skip the first slide\n      if (i) {\n        slidePositions.push(item.getBoundingClientRect()[attr] - base);\n      } // add the end edge\n\n\n      if (i === slideCountNew - 1) {\n        slidePositions.push(item.getBoundingClientRect()[attr2] - base);\n      }\n    });\n  } // update slide\n\n\n  function updateSlideStatus() {\n    var range = getVisibleSlideRange(),\n        start = range[0],\n        end = range[1];\n    forEach(slideItems, function (item, i) {\n      // show slides\n      if (i >= start && i <= end) {\n        if (hasAttr(item, 'aria-hidden')) {\n          removeAttrs(item, ['aria-hidden', 'tabindex']);\n          addClass(item, slideActiveClass);\n        } // hide slides\n\n      } else {\n        if (!hasAttr(item, 'aria-hidden')) {\n          setAttrs(item, {\n            'aria-hidden': 'true',\n            'tabindex': '-1'\n          });\n          removeClass(item, slideActiveClass);\n        }\n      }\n    });\n  } // gallery: update slide position\n\n\n  function updateGallerySlidePositions() {\n    var l = index + Math.min(slideCount, items);\n\n    for (var i = slideCountNew; i--;) {\n      var item = slideItems[i];\n\n      if (i >= index && i < l) {\n        // add transitions to visible slides when adjusting their positions\n        addClass(item, 'tns-moving');\n        item.style.left = (i - index) * 100 / items + '%';\n        addClass(item, animateIn);\n        removeClass(item, animateNormal);\n      } else if (item.style.left) {\n        item.style.left = '';\n        addClass(item, animateNormal);\n        removeClass(item, animateIn);\n      } // remove outlet animation\n\n\n      removeClass(item, animateOut);\n    } // removing '.tns-moving'\n\n\n    setTimeout(function () {\n      forEach(slideItems, function (el) {\n        removeClass(el, 'tns-moving');\n      });\n    }, 300);\n  } // set tabindex on Nav\n\n\n  function updateNavStatus() {\n    // get current nav\n    if (nav) {\n      navCurrentIndex = navClicked >= 0 ? navClicked : getCurrentNavIndex();\n      navClicked = -1;\n\n      if (navCurrentIndex !== navCurrentIndexCached) {\n        var navPrev = navItems[navCurrentIndexCached],\n            navCurrent = navItems[navCurrentIndex];\n        setAttrs(navPrev, {\n          'tabindex': '-1',\n          'aria-label': navStr + (navCurrentIndexCached + 1)\n        });\n        removeClass(navPrev, navActiveClass);\n        setAttrs(navCurrent, {\n          'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent\n        });\n        removeAttrs(navCurrent, 'tabindex');\n        addClass(navCurrent, navActiveClass);\n        navCurrentIndexCached = navCurrentIndex;\n      }\n    }\n  }\n\n  function getLowerCaseNodeName(el) {\n    return el.nodeName.toLowerCase();\n  }\n\n  function isButton(el) {\n    return getLowerCaseNodeName(el) === 'button';\n  }\n\n  function isAriaDisabled(el) {\n    return el.getAttribute('aria-disabled') === 'true';\n  }\n\n  function disEnableElement(isButton, el, val) {\n    if (isButton) {\n      el.disabled = val;\n    } else {\n      el.setAttribute('aria-disabled', val.toString());\n    }\n  } // set 'disabled' to true on controls when reach the edges\n\n\n  function updateControlsStatus() {\n    if (!controls || rewind || loop) {\n      return;\n    }\n\n    var prevDisabled = prevIsButton ? prevButton.disabled : isAriaDisabled(prevButton),\n        nextDisabled = nextIsButton ? nextButton.disabled : isAriaDisabled(nextButton),\n        disablePrev = index <= indexMin ? true : false,\n        disableNext = !rewind && index >= indexMax ? true : false;\n\n    if (disablePrev && !prevDisabled) {\n      disEnableElement(prevIsButton, prevButton, true);\n    }\n\n    if (!disablePrev && prevDisabled) {\n      disEnableElement(prevIsButton, prevButton, false);\n    }\n\n    if (disableNext && !nextDisabled) {\n      disEnableElement(nextIsButton, nextButton, true);\n    }\n\n    if (!disableNext && nextDisabled) {\n      disEnableElement(nextIsButton, nextButton, false);\n    }\n  } // set duration\n\n\n  function resetDuration(el, str) {\n    if (TRANSITIONDURATION) {\n      el.style[TRANSITIONDURATION] = str;\n    }\n  }\n\n  function getSliderWidth() {\n    return fixedWidth ? (fixedWidth + gutter) * slideCountNew : slidePositions[slideCountNew];\n  }\n\n  function getCenterGap(num) {\n    if (num == null) {\n      num = index;\n    }\n\n    var gap = edgePadding ? gutter : 0;\n    return autoWidth ? (viewport - gap - (slidePositions[num + 1] - slidePositions[num] - gutter)) / 2 : fixedWidth ? (viewport - fixedWidth) / 2 : (items - 1) / 2;\n  }\n\n  function getRightBoundary() {\n    var gap = edgePadding ? gutter : 0,\n        result = viewport + gap - getSliderWidth();\n\n    if (center && !loop) {\n      result = fixedWidth ? -(fixedWidth + gutter) * (slideCountNew - 1) - getCenterGap() : getCenterGap(slideCountNew - 1) - slidePositions[slideCountNew - 1];\n    }\n\n    if (result > 0) {\n      result = 0;\n    }\n\n    return result;\n  }\n\n  function getContainerTransformValue(num) {\n    if (num == null) {\n      num = index;\n    }\n\n    var val;\n\n    if (horizontal && !autoWidth) {\n      if (fixedWidth) {\n        val = -(fixedWidth + gutter) * num;\n\n        if (center) {\n          val += getCenterGap();\n        }\n      } else {\n        var denominator = TRANSFORM ? slideCountNew : items;\n\n        if (center) {\n          num -= getCenterGap();\n        }\n\n        val = -num * 100 / denominator;\n      }\n    } else {\n      val = -slidePositions[num];\n\n      if (center && autoWidth) {\n        val += getCenterGap();\n      }\n    }\n\n    if (hasRightDeadZone) {\n      val = Math.max(val, rightBoundary);\n    }\n\n    val += horizontal && !autoWidth && !fixedWidth ? '%' : 'px';\n    return val;\n  }\n\n  function doContainerTransformSilent(val) {\n    resetDuration(container, '0s');\n    doContainerTransform(val);\n  }\n\n  function doContainerTransform(val) {\n    if (val == null) {\n      val = getContainerTransformValue();\n    }\n\n    container.style[transformAttr] = transformPrefix + val + transformPostfix;\n  }\n\n  function animateSlide(number, classOut, classIn, isOut) {\n    var l = number + items;\n\n    if (!loop) {\n      l = Math.min(l, slideCountNew);\n    }\n\n    for (var i = number; i < l; i++) {\n      var item = slideItems[i]; // set item positions\n\n      if (!isOut) {\n        item.style.left = (i - index) * 100 / items + '%';\n      }\n\n      if (animateDelay && TRANSITIONDELAY) {\n        item.style[TRANSITIONDELAY] = item.style[ANIMATIONDELAY] = animateDelay * (i - number) / 1000 + 's';\n      }\n\n      removeClass(item, classOut);\n      addClass(item, classIn);\n\n      if (isOut) {\n        slideItemsOut.push(item);\n      }\n    }\n  } // make transfer after click/drag:\n  // 1. change 'transform' property for mordern browsers\n  // 2. change 'left' property for legacy browsers\n\n\n  var transformCore = function () {\n    return carousel ? function () {\n      resetDuration(container, '');\n\n      if (TRANSITIONDURATION || !speed) {\n        // for morden browsers with non-zero duration or\n        // zero duration for all browsers\n        doContainerTransform(); // run fallback function manually\n        // when duration is 0 / container is hidden\n\n        if (!speed || !isVisible(container)) {\n          onTransitionEnd();\n        }\n      } else {\n        // for old browser with non-zero duration\n        jsTransform(container, transformAttr, transformPrefix, transformPostfix, getContainerTransformValue(), speed, onTransitionEnd);\n      }\n\n      if (!horizontal) {\n        updateContentWrapperHeight();\n      }\n    } : function () {\n      slideItemsOut = [];\n      var eve = {};\n      eve[TRANSITIONEND] = eve[ANIMATIONEND] = onTransitionEnd;\n      removeEvents(slideItems[indexCached], eve);\n      addEvents(slideItems[index], eve);\n      animateSlide(indexCached, animateIn, animateOut, true);\n      animateSlide(index, animateNormal, animateIn); // run fallback function manually\n      // when transition or animation not supported / duration is 0\n\n      if (!TRANSITIONEND || !ANIMATIONEND || !speed || !isVisible(container)) {\n        onTransitionEnd();\n      }\n    };\n  }();\n\n  function render(e, sliderMoved) {\n    if (updateIndexBeforeTransform) {\n      updateIndex();\n    } // render when slider was moved (touch or drag) even though index may not change\n\n\n    if (index !== indexCached || sliderMoved) {\n      // events\n      events.emit('indexChanged', info());\n      events.emit('transitionStart', info());\n\n      if (autoHeight) {\n        doAutoHeight();\n      } // pause autoplay when click or keydown from user\n\n\n      if (animating && e && ['click', 'keydown'].indexOf(e.type) >= 0) {\n        stopAutoplay();\n      }\n\n      running = true;\n      transformCore();\n    }\n  }\n  /*\n   * Transfer prefixed properties to the same format\n   * CSS: -Webkit-Transform => webkittransform\n   * JS: WebkitTransform => webkittransform\n   * @param {string} str - property\n   *\n   */\n\n\n  function strTrans(str) {\n    return str.toLowerCase().replace(/-/g, '');\n  } // AFTER TRANSFORM\n  // Things need to be done after a transfer:\n  // 1. check index\n  // 2. add classes to visible slide\n  // 3. disable controls buttons when reach the first/last slide in non-loop slider\n  // 4. update nav status\n  // 5. lazyload images\n  // 6. update container height\n\n\n  function onTransitionEnd(event) {\n    // check running on gallery mode\n    // make sure trantionend/animationend events run only once\n    if (carousel || running) {\n      events.emit('transitionEnd', info(event));\n\n      if (!carousel && slideItemsOut.length > 0) {\n        for (var i = 0; i < slideItemsOut.length; i++) {\n          var item = slideItemsOut[i]; // set item positions\n\n          item.style.left = '';\n\n          if (ANIMATIONDELAY && TRANSITIONDELAY) {\n            item.style[ANIMATIONDELAY] = '';\n            item.style[TRANSITIONDELAY] = '';\n          }\n\n          removeClass(item, animateOut);\n          addClass(item, animateNormal);\n        }\n      }\n      /* update slides, nav, controls after checking ...\n       * => legacy browsers who don't support 'event'\n       *    have to check event first, otherwise event.target will cause an error\n       * => or 'gallery' mode:\n       *   + event target is slide item\n       * => or 'carousel' mode:\n       *   + event target is container,\n       *   + event.property is the same with transform attribute\n       */\n\n\n      if (!event || !carousel && event.target.parentNode === container || event.target === container && strTrans(event.propertyName) === strTrans(transformAttr)) {\n        if (!updateIndexBeforeTransform) {\n          var indexTem = index;\n          updateIndex();\n\n          if (index !== indexTem) {\n            events.emit('indexChanged', info());\n            doContainerTransformSilent();\n          }\n        }\n\n        if (nested === 'inner') {\n          events.emit('innerLoaded', info());\n        }\n\n        running = false;\n        indexCached = index;\n      }\n    }\n  } // # ACTIONS\n\n\n  function goTo(targetIndex, e) {\n    if (freeze) {\n      return;\n    } // prev slideBy\n\n\n    if (targetIndex === 'prev') {\n      onControlsClick(e, -1); // next slideBy\n    } else if (targetIndex === 'next') {\n      onControlsClick(e, 1); // go to exact slide\n    } else {\n      if (running) {\n        if (preventActionWhenRunning) {\n          return;\n        } else {\n          onTransitionEnd();\n        }\n      }\n\n      var absIndex = getAbsIndex(),\n          indexGap = 0;\n\n      if (targetIndex === 'first') {\n        indexGap = -absIndex;\n      } else if (targetIndex === 'last') {\n        indexGap = carousel ? slideCount - items - absIndex : slideCount - 1 - absIndex;\n      } else {\n        if (typeof targetIndex !== 'number') {\n          targetIndex = parseInt(targetIndex);\n        }\n\n        if (!isNaN(targetIndex)) {\n          // from directly called goTo function\n          if (!e) {\n            targetIndex = Math.max(0, Math.min(slideCount - 1, targetIndex));\n          }\n\n          indexGap = targetIndex - absIndex;\n        }\n      } // gallery: make sure new page won't overlap with current page\n\n\n      if (!carousel && indexGap && Math.abs(indexGap) < items) {\n        var factor = indexGap > 0 ? 1 : -1;\n        indexGap += index + indexGap - slideCount >= indexMin ? slideCount * factor : slideCount * 2 * factor * -1;\n      }\n\n      index += indexGap; // make sure index is in range\n\n      if (carousel && loop) {\n        if (index < indexMin) {\n          index += slideCount;\n        }\n\n        if (index > indexMax) {\n          index -= slideCount;\n        }\n      } // if index is changed, start rendering\n\n\n      if (getAbsIndex(index) !== getAbsIndex(indexCached)) {\n        render(e);\n      }\n    }\n  } // on controls click\n\n\n  function onControlsClick(e, dir) {\n    if (running) {\n      if (preventActionWhenRunning) {\n        return;\n      } else {\n        onTransitionEnd();\n      }\n    }\n\n    var passEventObject;\n\n    if (!dir) {\n      e = getEvent(e);\n      var target = getTarget(e);\n\n      while (target !== controlsContainer && [prevButton, nextButton].indexOf(target) < 0) {\n        target = target.parentNode;\n      }\n\n      var targetIn = [prevButton, nextButton].indexOf(target);\n\n      if (targetIn >= 0) {\n        passEventObject = true;\n        dir = targetIn === 0 ? -1 : 1;\n      }\n    }\n\n    if (rewind) {\n      if (index === indexMin && dir === -1) {\n        goTo('last', e);\n        return;\n      } else if (index === indexMax && dir === 1) {\n        goTo('first', e);\n        return;\n      }\n    }\n\n    if (dir) {\n      index += slideBy * dir;\n\n      if (autoWidth) {\n        index = Math.floor(index);\n      } // pass e when click control buttons or keydown\n\n\n      render(passEventObject || e && e.type === 'keydown' ? e : null);\n    }\n  } // on nav click\n\n\n  function onNavClick(e) {\n    if (running) {\n      if (preventActionWhenRunning) {\n        return;\n      } else {\n        onTransitionEnd();\n      }\n    }\n\n    e = getEvent(e);\n    var target = getTarget(e),\n        navIndex; // find the clicked nav item\n\n    while (target !== navContainer && !hasAttr(target, 'data-nav')) {\n      target = target.parentNode;\n    }\n\n    if (hasAttr(target, 'data-nav')) {\n      var navIndex = navClicked = Number(getAttr(target, 'data-nav')),\n          targetIndexBase = fixedWidth || autoWidth ? navIndex * slideCount / pages : navIndex * items,\n          targetIndex = navAsThumbnails ? navIndex : Math.min(Math.ceil(targetIndexBase), slideCount - 1);\n      goTo(targetIndex, e);\n\n      if (navCurrentIndex === navIndex) {\n        if (animating) {\n          stopAutoplay();\n        }\n\n        navClicked = -1; // reset navClicked\n      }\n    }\n  } // autoplay functions\n\n\n  function setAutoplayTimer() {\n    autoplayTimer = setInterval(function () {\n      onControlsClick(null, autoplayDirection);\n    }, autoplayTimeout);\n    animating = true;\n  }\n\n  function stopAutoplayTimer() {\n    clearInterval(autoplayTimer);\n    animating = false;\n  }\n\n  function updateAutoplayButton(action, txt) {\n    setAttrs(autoplayButton, {\n      'data-action': action\n    });\n    autoplayButton.innerHTML = autoplayHtmlStrings[0] + action + autoplayHtmlStrings[1] + txt;\n  }\n\n  function startAutoplay() {\n    setAutoplayTimer();\n\n    if (autoplayButton) {\n      updateAutoplayButton('stop', autoplayText[1]);\n    }\n  }\n\n  function stopAutoplay() {\n    stopAutoplayTimer();\n\n    if (autoplayButton) {\n      updateAutoplayButton('start', autoplayText[0]);\n    }\n  } // programaitcally play/pause the slider\n\n\n  function play() {\n    if (autoplay && !animating) {\n      startAutoplay();\n      autoplayUserPaused = false;\n    }\n  }\n\n  function pause() {\n    if (animating) {\n      stopAutoplay();\n      autoplayUserPaused = true;\n    }\n  }\n\n  function toggleAutoplay() {\n    if (animating) {\n      stopAutoplay();\n      autoplayUserPaused = true;\n    } else {\n      startAutoplay();\n      autoplayUserPaused = false;\n    }\n  }\n\n  function onVisibilityChange() {\n    if (doc.hidden) {\n      if (animating) {\n        stopAutoplayTimer();\n        autoplayVisibilityPaused = true;\n      }\n    } else if (autoplayVisibilityPaused) {\n      setAutoplayTimer();\n      autoplayVisibilityPaused = false;\n    }\n  }\n\n  function mouseoverPause() {\n    if (animating) {\n      stopAutoplayTimer();\n      autoplayHoverPaused = true;\n    }\n  }\n\n  function mouseoutRestart() {\n    if (autoplayHoverPaused) {\n      setAutoplayTimer();\n      autoplayHoverPaused = false;\n    }\n  } // keydown events on document\n\n\n  function onDocumentKeydown(e) {\n    e = getEvent(e);\n    var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);\n\n    if (keyIndex >= 0) {\n      onControlsClick(e, keyIndex === 0 ? -1 : 1);\n    }\n  } // on key control\n\n\n  function onControlsKeydown(e) {\n    e = getEvent(e);\n    var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);\n\n    if (keyIndex >= 0) {\n      if (keyIndex === 0) {\n        if (!prevButton.disabled) {\n          onControlsClick(e, -1);\n        }\n      } else if (!nextButton.disabled) {\n        onControlsClick(e, 1);\n      }\n    }\n  } // set focus\n\n\n  function setFocus(el) {\n    el.focus();\n  } // on key nav\n\n\n  function onNavKeydown(e) {\n    e = getEvent(e);\n    var curElement = doc.activeElement;\n\n    if (!hasAttr(curElement, 'data-nav')) {\n      return;\n    } // var code = e.keyCode,\n\n\n    var keyIndex = [KEYS.LEFT, KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE].indexOf(e.keyCode),\n        navIndex = Number(getAttr(curElement, 'data-nav'));\n\n    if (keyIndex >= 0) {\n      if (keyIndex === 0) {\n        if (navIndex > 0) {\n          setFocus(navItems[navIndex - 1]);\n        }\n      } else if (keyIndex === 1) {\n        if (navIndex < pages - 1) {\n          setFocus(navItems[navIndex + 1]);\n        }\n      } else {\n        navClicked = navIndex;\n        goTo(navIndex, e);\n      }\n    }\n  }\n\n  function getEvent(e) {\n    e = e || win.event;\n    return isTouchEvent(e) ? e.changedTouches[0] : e;\n  }\n\n  function getTarget(e) {\n    return e.target || win.event.srcElement;\n  }\n\n  function isTouchEvent(e) {\n    return e.type.indexOf('touch') >= 0;\n  }\n\n  function preventDefaultBehavior(e) {\n    e.preventDefault ? e.preventDefault() : e.returnValue = false;\n  }\n\n  function getMoveDirectionExpected() {\n    return getTouchDirection(toDegree(lastPosition.y - initPosition.y, lastPosition.x - initPosition.x), swipeAngle) === options.axis;\n  }\n\n  function onPanStart(e) {\n    if (running) {\n      if (preventActionWhenRunning) {\n        return;\n      } else {\n        onTransitionEnd();\n      }\n    }\n\n    if (autoplay && animating) {\n      stopAutoplayTimer();\n    }\n\n    panStart = true;\n\n    if (rafIndex) {\n      caf(rafIndex);\n      rafIndex = null;\n    }\n\n    var $ = getEvent(e);\n    events.emit(isTouchEvent(e) ? 'touchStart' : 'dragStart', info(e));\n\n    if (!isTouchEvent(e) && ['img', 'a'].indexOf(getLowerCaseNodeName(getTarget(e))) >= 0) {\n      preventDefaultBehavior(e);\n    }\n\n    lastPosition.x = initPosition.x = $.clientX;\n    lastPosition.y = initPosition.y = $.clientY;\n\n    if (carousel) {\n      translateInit = parseFloat(container.style[transformAttr].replace(transformPrefix, ''));\n      resetDuration(container, '0s');\n    }\n  }\n\n  function onPanMove(e) {\n    if (panStart) {\n      var $ = getEvent(e);\n      lastPosition.x = $.clientX;\n      lastPosition.y = $.clientY;\n\n      if (carousel) {\n        if (!rafIndex) {\n          rafIndex = raf(function () {\n            panUpdate(e);\n          });\n        }\n      } else {\n        if (moveDirectionExpected === '?') {\n          moveDirectionExpected = getMoveDirectionExpected();\n        }\n\n        if (moveDirectionExpected) {\n          preventScroll = true;\n        }\n      }\n\n      if ((typeof e.cancelable !== 'boolean' || e.cancelable) && preventScroll) {\n        e.preventDefault();\n      }\n    }\n  }\n\n  function panUpdate(e) {\n    if (!moveDirectionExpected) {\n      panStart = false;\n      return;\n    }\n\n    caf(rafIndex);\n\n    if (panStart) {\n      rafIndex = raf(function () {\n        panUpdate(e);\n      });\n    }\n\n    if (moveDirectionExpected === '?') {\n      moveDirectionExpected = getMoveDirectionExpected();\n    }\n\n    if (moveDirectionExpected) {\n      if (!preventScroll && isTouchEvent(e)) {\n        preventScroll = true;\n      }\n\n      try {\n        if (e.type) {\n          events.emit(isTouchEvent(e) ? 'touchMove' : 'dragMove', info(e));\n        }\n      } catch (err) {}\n\n      var x = translateInit,\n          dist = getDist(lastPosition, initPosition);\n\n      if (!horizontal || fixedWidth || autoWidth) {\n        x += dist;\n        x += 'px';\n      } else {\n        var percentageX = TRANSFORM ? dist * items * 100 / ((viewport + gutter) * slideCountNew) : dist * 100 / (viewport + gutter);\n        x += percentageX;\n        x += '%';\n      }\n\n      container.style[transformAttr] = transformPrefix + x + transformPostfix;\n    }\n  }\n\n  function onPanEnd(e) {\n    if (panStart) {\n      if (rafIndex) {\n        caf(rafIndex);\n        rafIndex = null;\n      }\n\n      if (carousel) {\n        resetDuration(container, '');\n      }\n\n      panStart = false;\n      var $ = getEvent(e);\n      lastPosition.x = $.clientX;\n      lastPosition.y = $.clientY;\n      var dist = getDist(lastPosition, initPosition);\n\n      if (Math.abs(dist)) {\n        // drag vs click\n        if (!isTouchEvent(e)) {\n          // prevent \"click\"\n          var target = getTarget(e);\n          addEvents(target, {\n            'click': function preventClick(e) {\n              preventDefaultBehavior(e);\n              removeEvents(target, {\n                'click': preventClick\n              });\n            }\n          });\n        }\n\n        if (carousel) {\n          rafIndex = raf(function () {\n            if (horizontal && !autoWidth) {\n              var indexMoved = -dist * items / (viewport + gutter);\n              indexMoved = dist > 0 ? Math.floor(indexMoved) : Math.ceil(indexMoved);\n              index += indexMoved;\n            } else {\n              var moved = -(translateInit + dist);\n\n              if (moved <= 0) {\n                index = indexMin;\n              } else if (moved >= slidePositions[slideCountNew - 1]) {\n                index = indexMax;\n              } else {\n                var i = 0;\n\n                while (i < slideCountNew && moved >= slidePositions[i]) {\n                  index = i;\n\n                  if (moved > slidePositions[i] && dist < 0) {\n                    index += 1;\n                  }\n\n                  i++;\n                }\n              }\n            }\n\n            render(e, dist);\n            events.emit(isTouchEvent(e) ? 'touchEnd' : 'dragEnd', info(e));\n          });\n        } else {\n          if (moveDirectionExpected) {\n            onControlsClick(e, dist > 0 ? -1 : 1);\n          }\n        }\n      }\n    } // reset\n\n\n    if (options.preventScrollOnTouch === 'auto') {\n      preventScroll = false;\n    }\n\n    if (swipeAngle) {\n      moveDirectionExpected = '?';\n    }\n\n    if (autoplay && !animating) {\n      setAutoplayTimer();\n    }\n  } // === RESIZE FUNCTIONS === //\n  // (slidePositions, index, items) => vertical_conentWrapper.height\n\n\n  function updateContentWrapperHeight() {\n    var wp = middleWrapper ? middleWrapper : innerWrapper;\n    wp.style.height = slidePositions[index + items] - slidePositions[index] + 'px';\n  }\n\n  function getPages() {\n    var rough = fixedWidth ? (fixedWidth + gutter) * slideCount / viewport : slideCount / items;\n    return Math.min(Math.ceil(rough), slideCount);\n  }\n  /*\n   * 1. update visible nav items list\n   * 2. add \"hidden\" attributes to previous visible nav items\n   * 3. remove \"hidden\" attrubutes to new visible nav items\n   */\n\n\n  function updateNavVisibility() {\n    if (!nav || navAsThumbnails) {\n      return;\n    }\n\n    if (pages !== pagesCached) {\n      var min = pagesCached,\n          max = pages,\n          fn = showElement;\n\n      if (pagesCached > pages) {\n        min = pages;\n        max = pagesCached;\n        fn = hideElement;\n      }\n\n      while (min < max) {\n        fn(navItems[min]);\n        min++;\n      } // cache pages\n\n\n      pagesCached = pages;\n    }\n  }\n\n  function info(e) {\n    return {\n      container: container,\n      slideItems: slideItems,\n      navContainer: navContainer,\n      navItems: navItems,\n      controlsContainer: controlsContainer,\n      hasControls: hasControls,\n      prevButton: prevButton,\n      nextButton: nextButton,\n      items: items,\n      slideBy: slideBy,\n      cloneCount: cloneCount,\n      slideCount: slideCount,\n      slideCountNew: slideCountNew,\n      index: index,\n      indexCached: indexCached,\n      displayIndex: getCurrentSlide(),\n      navCurrentIndex: navCurrentIndex,\n      navCurrentIndexCached: navCurrentIndexCached,\n      pages: pages,\n      pagesCached: pagesCached,\n      sheet: sheet,\n      isOn: isOn,\n      event: e || {}\n    };\n  }\n\n  return {\n    version: '2.9.4',\n    getInfo: info,\n    events: events,\n    goTo: goTo,\n    play: play,\n    pause: pause,\n    isOn: isOn,\n    updateSliderHeight: updateInnerWrapperHeight,\n    refresh: initSliderTransform,\n    destroy: destroy,\n    rebuild: function () {\n      return tns(extend(options, optionsElements));\n    }\n  };\n};\n\nexports.tns = tns;\n\n\n//# sourceURL=webpack:///./node_modules/tiny-slider/dist/tiny-slider.js?")},"./node_modules/tslib/tslib.es6.js":function node_modulesTslibTslibEs6Js(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to get private field on non-instance");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to set private field on non-instance");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/tslib/tslib.es6.js?')},"./node_modules/webpack/buildin/global.js":function node_modulesWebpackBuildinGlobalJs(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./src/scripts/general.js":function srcScriptsGeneralJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneralClass\", function() { return GeneralClass; });\n\r\n\r\nclass GeneralClass {\r\n\r\n    SetIsMobile() {\r\n        if (typeof window.orientation !== 'undefined') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    async RequestData({ form, service }) {\r\n        const formData = new FormData(form);\r\n        const { GetLanguage } = new GeneralClass();\r\n        const language = GetLanguage();\r\n        const dataToSend = {language};\r\n        const url = window.location.href.includes('devsite') || window.location.href.includes('local') ? 'https://services.stg.mubaro.mx/services/mubaro/' : 'https://services.mubaro.mx/services/mubaro/';\r\n\r\n        for (const [name, value] of formData) {\r\n            dataToSend[name] = value;\r\n        }\r\n\r\n        const formBody = Object.keys(dataToSend)\r\n            .map(\r\n                (key) =>\r\n                    encodeURIComponent(key) + '=' + encodeURIComponent(dataToSend[key])\r\n            )\r\n            .join('&'),\r\n            response = await fetch(`${url}${service}.php`, {\r\n                headers: {\r\n                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\r\n                },\r\n                method: 'POST',\r\n                body: formBody,\r\n            })\r\n                .then((response) => {\r\n                    if (response.ok) {\r\n                        return response.json();\r\n                    }\r\n                    throw new Error('Algo sali mal. Verifica los datos y vuelve a intentarlo.');\r\n                })\r\n                .catch((error) => {\r\n                    console.error('Error:', error);\r\n                    return error;\r\n                });\r\n        if (!response) return;\r\n        return response;\r\n    }\r\n\r\n    SetCookie() {\r\n        const disclaimer = localStorage.getItem('disclaimer');\r\n        const { GetLanguage } = new GeneralClass();\r\n        const language = GetLanguage();\r\n        const message = language === 'en' ? `You are browsing a website with its own and third-party cookies to offer you an optimal experience. To continue browsing, click Accept. If you want more information enter our Privacy Policy`: `Ests navegando en un sitio con cookies propias y de terceros, para ofrecerte una experiencia ptima. <br/>Para continuar navegando, dale Aceptar. <br/>Si deseas ms informacin entra a nuestra poltica de privacidad. `;\r\n        const denyText = language === 'en' ? 'Deny' : 'No acepto';\r\n        const acceptText = language === 'en' ? 'Accept' : 'Acepto';\r\n\r\n        if (!disclaimer) {\r\n            const cookie_wrp = document.createElement('div'),\r\n                cookie_markup = `\r\n                <div class=\"cookies-container\">\r\n                    <div class=\"cookies-wrp text-center\">\r\n                        <p>${message}</p>\r\n                        <div class=\"row justify-content-between cookies-btn-wrp mx-auto\">\r\n                            <button type=\"button\" data-type=\"yes\" class=\"btn btn-blue btn-cookie\">${acceptText}</button>\r\n                            <button type=\"button\" data-type=\"no\" class=\"btn btn-blue btn-cookie btn\">${denyText}</button>\r\n                        </div>\r\n                    </div>\r\n                </div>`;\r\n            cookie_wrp.classList.add('cookies-disclaim');\r\n            cookie_wrp.innerHTML = cookie_markup;\r\n\r\n            document.body.appendChild(cookie_wrp);\r\n\r\n            const cookie_btn = document.querySelectorAll('.btn-cookie');\r\n\r\n            [].forEach.call(cookie_btn, (c) => {\r\n                c.addEventListener('click', (e) => {\r\n                    e.preventDefault();\r\n                    let tgt = e.currentTarget,\r\n                        type = tgt.getAttribute('data-type');\r\n\r\n                    if (type === 'yes') {\r\n                        localStorage.setItem('disclaimer', true);\r\n                    }\r\n\r\n                    document.querySelector('.cookies-disclaim').remove();\r\n                });\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    GetQueryString(name, url) {\r\n        if (!url) url = window.location.href;\r\n        name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\r\n            results = regex.exec(url);\r\n        if (!results) return null;\r\n        if (!results[2]) return '';\r\n        return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n    }\r\n\r\n    Decode(str) {\r\n\r\n        str = str.replace('', 'a');\r\n        str = str.replace('', 'A');\r\n        str = str.replace('', 'e');\r\n        str = str.replace('', 'E');\r\n        str = str.replace('', 'i');\r\n        str = str.replace('', 'I');\r\n        str = str.replace('', 'o');\r\n        str = str.replace('', 'O');\r\n        str = str.replace('', 'u');\r\n        str = str.replace('', 'U');\r\n        str = str.replace('', 'n');\r\n        str = str.replace('', 'N');\r\n        str = str.replace('', '');\r\n\r\n        return str;\r\n    }\r\n\r\n    async GetData(path) {\r\n        const SERVICES_URL = window.location.href.includes('devsite') || window.location.href.includes('local') ? '' : '';\r\n        const url = SERVICES_URL + '/' + path,\r\n            response = await fetch(url),\r\n            data = await response.json();\r\n\r\n        if (!data) return;\r\n        return data;\r\n    }\r\n\r\n    CharsAllowed(value) {\r\n        const allowedChars = new RegExp(/^[a-zA-Z\\s]+$/)\r\n        return allowedChars.test(value);\r\n    }\r\n\r\n    CleanFormInfo() {\r\n\r\n        const fields = document.querySelectorAll('.required-field');\r\n        const self = new GeneralClass();\r\n\r\n        const { GetLanguage, RemoveAllErrors } = new GeneralClass();\r\n\r\n        const lang = GetLanguage();\r\n\r\n        [].forEach.call(fields, (e, index) => {\r\n\r\n            let tgt = e;\r\n\r\n            tgt.addEventListener('change', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n            tgt.addEventListener('keyup', ($e) => {\r\n                const val = tgt.value;\r\n                const name = tgt.getAttribute('name');\r\n                const maxlength = 10;\r\n                if (name === 'phone') {\r\n                    if (val.length > maxlength) {\r\n                        tgt.value = val.substr(0, maxlength);\r\n                    }\r\n                }\r\n            });\r\n\r\n            tgt.addEventListener('input', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n            tgt.addEventListener('focusout', (e) => {\r\n                RemoveAllErrors();\r\n                const name = tgt.getAttribute('name');\r\n\r\n                let p = document.createElement('p');\r\n                let error_message = name === 'phone' ? lang === 'es' ? 'Solo se admiten nmeros' : 'Only numbers' : name === 'email' ? lang === 'es' ? 'Ingresa un correo electrnico vlido' : 'Email' : lang === 'es' ? 'Solo se admiten letras' : 'Only letters';\r\n                let regex = name === 'phone' ? /^[0-9]+$/ : name === 'email' ? /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}/gi : /^[A-Za-z---\\s]*$/\r\n\r\n                //Validate TextBox value against the Regex.\r\n                const isValid = tgt.value ? regex.test(tgt.value) : true;\r\n\r\n                if (!isValid && !name.toLowerCase().includes('date')) {\r\n                    p.innerHTML = error_message;\r\n                    p.classList.add('error');\r\n                    tgt.parentNode.appendChild(p);\r\n                } else {\r\n                    RemoveAllErrors();\r\n                }\r\n\r\n\r\n                return isValid;\r\n            });\r\n\r\n            tgt.addEventListener('paste', ($e) => {\r\n                RemoveAllErrors();\r\n            });\r\n\r\n\r\n        });\r\n\r\n    }\r\n\r\n    RemoveAllErrors() {\r\n        // const removeErrors = () => {\r\n        const errors = document.querySelectorAll('.error');\r\n\r\n        [].forEach.call(errors, (e, index) => {\r\n            e.remove();\r\n        });\r\n        //}\r\n    }\r\n\r\n    ValidateForm() {\r\n        const labels = document.querySelectorAll('.label'),\r\n            errors = document.querySelectorAll('.error'),\r\n            email = document.querySelector('.js-email'),\r\n            phone = document.querySelector('.js-phone'),\r\n            emailVal = email ? email.value.search(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}/gi) > -1 : null,\r\n            phoneVal = phone ? phone.value.search(/\\[0-9]/) : null,\r\n            fields = document.querySelectorAll('.required-field');\r\n\r\n        const { GetLanguage } = new GeneralClass();\r\n\r\n        const lang = GetLanguage();\r\n\r\n        let required = fields.length,\r\n            fieldError = [],\r\n            filled = [],\r\n            eml = 0,\r\n            phn = 0;\r\n\r\n        [].forEach.call(fields, (f, index) => {\r\n\r\n            let tgt = f,\r\n                val,\r\n                title;\r\n\r\n            val = f.value;\r\n\r\n            if (val === '' || val === '-1') {\r\n                const msj = labels[index].innerHTML.replace(':', '').toLowerCase();\r\n                const parsed = msj.normalize('NFD').replace(/([\\u0300-\\u036f]|[^0-9a-zA-Z])/g, '').replace(/([^\\w]+|\\s+)/g, '-');\r\n                let p = document.createElement('p');\r\n                p.classList.add('error');\r\n                p.classList.add(`error-${parsed}`);\r\n                title = lang === 'es' ? `Por favor, ingresa correctamente ${msj}.` : `Fill correctly ${msj}.`;\r\n                p.innerHTML = title;\r\n\r\n                [].forEach.call(errors, (e, index) => {\r\n                    e.remove();\r\n                });\r\n\r\n                tgt.parentNode.appendChild(p);\r\n                fieldError.push(title);\r\n\r\n            } else {\r\n                filled.push(tgt);\r\n            }\r\n\r\n        });\r\n\r\n        if (email && !emailVal) {\r\n            let p = document.createElement('p');\r\n            p.classList.add('error');\r\n            p.innerHTML = lang === 'es' ? 'Por favor, ingresa correctamente tu correo electrnico.' : 'Please, fill your email';\r\n            if (!document.body.contains(document.querySelector('.error-correoelectronico') || document.querySelector('.error-email'))) {\r\n                document.querySelector('.js-email-wrp').appendChild(p);\r\n            }\r\n            eml = 0;\r\n        } else {\r\n            eml = 1;\r\n        }\r\n\r\n        if (phone && !phoneVal) {\r\n            let p = document.createElement('p');\r\n            p.classList.add('error');\r\n            p.innerHTML = lang === 'es' ? 'Por favor, ingresa correctamente tu telfono.' : 'Please fill your phone correctly';\r\n            if (!document.body.contains(document.querySelector('.error-telefono') || document.querySelector('.error-phonenumber'))) {\r\n                document.querySelector('.js-phone-wrp').appendChild(p);\r\n            }\r\n            phn = 0;\r\n        } else {\r\n            phn = 1;\r\n        }\r\n\r\n        return required === filled.length && eml === 1 && phn === 1;\r\n\r\n    }\r\n\r\n    GetLanguage() {\r\n        let lang;\r\n        if (window.location.href.includes('/en/')) {\r\n            lang = 'en';\r\n        } else {\r\n            lang = 'es';\r\n        }\r\n        if (!localStorage.getItem('lang')) localStorage.setItem('lang', lang);\r\n        return lang;\r\n    }\r\n\r\n    SetAnimation() {\r\n        const boxes = document.querySelectorAll('.box');\r\n        if (boxes) {\r\n          const triggerBottom = (window.innerHeight / 5) * 4;\r\n    \r\n          if (document.querySelector('.box.init')) document.querySelector('.box.init').classList.add('show');\r\n    \r\n          boxes.forEach((box) => {\r\n            const boxTop = box.getBoundingClientRect().top;\r\n            // For checking when to show and hide the box\r\n            if (boxTop < triggerBottom) {\r\n              box.classList.add('show');\r\n            } \r\n          });\r\n        }\r\n      }\r\n\r\n      ShowModal({ children, onOpen, onAccept, onCancel }) {\r\n\r\n        const ol = document.querySelector('#ol-main');\r\n        const self = new GeneralClass();\r\n\r\n        if (ol) {\r\n            ol.remove();\r\n        }\r\n\r\n        let ol_div = document.createElement('div');\r\n\r\n        ol_div.id = 'ol-main';\r\n\r\n        ol_div.innerHTML = `<div class=\"ol-modal-wrapper ol-modal-cont\" >\r\n            <div class=\"ol-modal-container ol-modal-cont\">\r\n                <div class=\"ol-modal-panel-box\">\r\n                    <div class=\"modal-container\">\r\n                        ${children}\r\n                    </div>\r\n                </div>\r\n            </div>`;\r\n\r\n        document.body.appendChild(ol_div);\r\n\r\n        const cancel_btn = document.querySelector('.ol-cancel-box') || document.querySelector('.ol-close-box');\r\n        const accept_btn = document.querySelector('.ol-accept-box');\r\n\r\n        if (onOpen) {\r\n            onOpen();\r\n        }\r\n\r\n        cancel_btn && cancel_btn.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n            if (onCancel) {\r\n                onCancel();\r\n            }\r\n            self.CloseModal();\r\n        });\r\n\r\n        accept_btn && accept_btn.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n\r\n            if (onAccept) {\r\n                onAccept();\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n    CloseModal() {\r\n        const ol_wrp = document.querySelector('.ol-modal-wrapper');\r\n        ol_wrp.remove();\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack:///./src/scripts/general.js?")},"./src/scripts/main.js":function srcScriptsMainJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./general */ \"./src/scripts/general.js\");\n/* harmony import */ var smooth_scrollbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! smooth-scrollbar */ \"./node_modules/smooth-scrollbar/index.js\");\n/* harmony import */ var tiny_slider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-slider */ \"./node_modules/tiny-slider/dist/tiny-slider.js\");\n/* harmony import */ var tiny_slider__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tiny_slider__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\n\r\nclass SectionClass extends _general__WEBPACK_IMPORTED_MODULE_0__[\"GeneralClass\"] {\r\n  constructor() {\r\n    super();\r\n    this.LaunchSection();\r\n  }\r\n\r\n  LaunchSection() {\r\n    const generalClass = new _general__WEBPACK_IMPORTED_MODULE_0__[\"GeneralClass\"]();\r\n    const { SetIsMobile, SetCookie, SetAnimation, GetLanguage } = generalClass;\r\n    const isMobile = SetIsMobile();\r\n    // const send_form = document.querySelector('.js-send-gral-form');\r\n    const main = document.querySelector('#main-scrollbar');\r\n    const hamburger_btn = document.getElementsByClassName('js-hamburger')[0];\r\n    const header_nav = document.querySelector('.navigation-nav');\r\n    const main_wrapper = document.body;\r\n    const header = document.querySelector('.header')\r\n    const main_container = document.querySelector('.main-container');\r\n    const tnsCarousel = document.querySelectorAll('.gallery');\r\n    const elemToAnim = document.querySelectorAll('.animate');\r\n    const mob_slider = document.querySelectorAll('.mob-slider');\r\n    const home_video = document.querySelector('.home-video');\r\n    const hash = window.location.hash;\r\n    const video = document.querySelector('.video');\r\n    const top_main = 140;\r\n    let scrollbar = null;\r\n\r\n    window.scrollTo(0, 0);\r\n\r\n    if(video) {\r\n      /* source.src = videoSrc;\r\n        source.type = 'video/mp4'; */\r\n        video.volume = 0;\r\n        video.setAttribute('muted', 'true');\r\n        video.setAttribute('loop', 'true');\r\n        video.setAttribute('playsinline', 'true');\r\n        video.setAttribute('autoplay', 'false');\r\n        // video.appendChild(source);\r\n        // when the first frame of the video is available to play, trigger the video\r\n        // for playback.\r\n        video.play();\r\n    }\r\n    if(mob_slider.length) {\r\n      mob_slider.forEach((item) => {\r\n        const slider = Object(tiny_slider__WEBPACK_IMPORTED_MODULE_2__[\"tns\"])({\r\n          container: item,\r\n          items: 1,\r\n          slideBy: 1,\r\n          controls: true,\r\n          edgePadding: 0,\r\n          loop: false,\r\n          mouseDrag: false,\r\n          center: false,\r\n          gutter: 0,\r\n          responsive: {\r\n              680: {\r\n                controls: false,\r\n                items: 3,\r\n              }\r\n          },\r\n      });\r\n      });\r\n    }\r\n\r\n    main_container.style.paddingTop = `${header.getBoundingClientRect().height}px`;\r\n    if(home_video) {\r\n      home_video.style.height = `${window.outerHeight*.8 - header.getBoundingClientRect().height}px`;\r\n    }\r\n\r\n    if (isMobile) {\r\n      main_wrapper.classList.remove('is-dektop');\r\n      main_wrapper.classList.add('is-mobile');\r\n    } else {\r\n      main_wrapper.classList.remove('is-mobile');\r\n      main_wrapper.classList.add('is-dektop');\r\n    }\r\n\r\n    setTimeout(() => {\r\n      scrollbar = smooth_scrollbar__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init(main, {\r\n        damping: 0.2,\r\n      });\r\n\r\n      // scrollbar.track.xAxis.hide();\r\n\r\n      setTimeout(() => {\r\n        if (hash) {\r\n          scrollbar.scrollIntoView(document.querySelector(hash), {\r\n            offsetTop: top_main,\r\n          });\r\n        }\r\n      }, 1200);\r\n\r\n\r\n\r\n      if (window.location.href.includes('logros')) {\r\n        if (elemToAnim[0]) {\r\n          elemToAnim[0].classList.add('init');\r\n        }\r\n        document.querySelectorAll('.filter__target--achievement').forEach((link) => {\r\n          link.addEventListener('click', (e) => {\r\n            const current_hash = e.target.hash;\r\n            e.preventDefault();\r\n            history.pushState({}, '', current_hash);\r\n            scrollbar.scrollIntoView(document.querySelector(current_hash), {\r\n              offsetTop: top_main,\r\n            });\r\n          });\r\n        });\r\n      }\r\n\r\n      scrollbar.addListener(() => {\r\n        const offset = scrollbar.offset.y;\r\n        const sticky = header.offsetTop;\r\n\r\n        if (offset > sticky) {\r\n          header.classList.add('sticky');\r\n          main_container.style.paddingTop = `${header.offsetHeight}px`;\r\n        } else {\r\n          header.classList.remove('sticky');\r\n          main_container.style.paddingTop = `${header.offsetHeight}px`;\r\n        }\r\n\r\n          main_container.style.paddingTop = `${header.offsetHeight}px`;\r\n          if(home_video) {\r\n            home_video.style.height = `${window.outerHeight*.8 - header.getBoundingClientRect().height}px`;\r\n          }\r\n        setTimeout(() => {\r\n          elemToAnim.forEach((elem) => {\r\n            // console.log({ elem })\r\n            if (this.IsInView(elem, offset, header.getBoundingClientRect().height)) {\r\n              elem.classList.add('init');\r\n            } /* else {\r\n              elem.classList.remove('init');\r\n            } */\r\n          });\r\n            main_container.style.paddingTop = `${header.getBoundingClientRect().height}px`;\r\n            /*if(home_video) {\r\n              home_video.style.height = `${window.outerHeight*.8 - header.getBoundingClientRect().height}px`;\r\n            }*/\r\n        }, 150);\r\n\r\n        // SetAnimation();\r\n      });\r\n\r\n    }, 500);\r\n\r\n    // }\r\n\r\n    if (tnsCarousel.length > 0) {\r\n      tnsCarousel.forEach(slider => {\r\n        Object(tiny_slider__WEBPACK_IMPORTED_MODULE_2__[\"tns\"])({\r\n          container: slider,\r\n          items: 1,\r\n          slideBy: 1,\r\n          controls: true,\r\n          edgePadding: 0,\r\n          loop: false,\r\n          mouseDrag: false,\r\n          center: true,\r\n          gutter: 0,\r\n          autoWidth: false,\r\n          // autoplay: true\r\n        });\r\n      })\r\n    }\r\n\r\n\r\n    setTimeout(() => {\r\n      if (!isMobile) SetAnimation();\r\n    }, 800);\r\n\r\n    hamburger_btn.addEventListener('click', (e) => {\r\n      e.preventDefault();\r\n\r\n      hamburger_btn.classList.toggle('is-active');\r\n      header_nav.classList.toggle('shown');\r\n      //document.body.classList.toggle('ov-hidden');\r\n    });\r\n\r\n    /*if (send_form) {\r\n      send_form.addEventListener('click', (e) => {\r\n        e.preventDefault();\r\n        const email = document.querySelector('.user-email').value;\r\n        const name = document.querySelector('.user-name').value;\r\n        const lastName = document.querySelector('.user-lastName').value;\r\n        const phone = document.querySelector('.user-phone').value;\r\n        const data = [];\r\n        if (email !== '') {\r\n          data.push({ email });\r\n        }\r\n        if (name !== '') {\r\n          data.push({ name });\r\n        }\r\n        if (lastName !== '') {\r\n          data.push({ lastName });\r\n        }\r\n        if (phone !== '') {\r\n          data.push({ phone });\r\n        }\r\n\r\n        localStorage.setItem('formval', JSON.stringify(data));\r\n\r\n        setTimeout(() => {\r\n          window.location.href = language === 'en' ? '/en/quote.html' : '/cotizacion.html';\r\n        }, 300);\r\n\r\n      });\r\n    } */\r\n\r\n    this.SetIsActiveSec();\r\n  }\r\n\r\n  IsInView(elem, offsetY, header) {\r\n    // console.log(elem, (elem.offsetTop - offsetY), elem.offsetHeight);\r\n    return elem.offsetTop - offsetY < elem.offsetHeight - header;\r\n  }\r\n\r\n  SetIsActiveSec() {\r\n    const location = window.location.href;\r\n    const hash = window.location.hash;\r\n    const loc = location.split('/');\r\n    const lastItem = hash ? loc[loc.length - 2] : location.replace(/.*\\/(\\w+)\\/?$/, '$1');\r\n    const anchor_inv = document.querySelectorAll('.navigation__link');\r\n\r\n    for (const link of anchor_inv) {\r\n      if (window.location.pathname === '/' ||\r\n        window.location.pathname.indexOf('index') > -1) {\r\n        anchor_inv[0].parentElement.classList.add('current');\r\n      } else if (link.href.includes(lastItem)) {\r\n        link.parentElement.classList.add('current');\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n\r\n}\r\n\r\ndocument.addEventListener(\r\n  'DOMContentLoaded',\r\n  () => {\r\n    let main = new SectionClass();\r\n  },\r\n  false\r\n);\r\n\n\n//# sourceURL=webpack:///./src/scripts/main.js?")}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uc2NyaXB0cy5taW4uanMiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0VzQXJyYXlGcm9tSnMiLCJldmFsIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc01hcEluZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc09iamVjdEFzc2lnbkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9zZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXNDb3JlSnNFc1NldEluZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3dlYWstbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzRXNXZWFrTWFwSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBQ2FsbGFibGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQVBvc3NpYmxlUHJvdG90eXBlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBZGRUb1Vuc2NvcGFibGVzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FuSW5zdGFuY2VKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FuT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUJ1ZmZlck5vbkV4dGVuc2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUZyb21KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJbmNsdWRlc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJdGVyYXRpb25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U2xpY2VTaW1wbGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheVNwZWNpZXNDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheVNwZWNpZXNDcmVhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZ0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NsYXNzb2ZSYXdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25TdHJvbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25XZWFrSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29sbGVjdGlvbkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29weUNvbnN0cnVjdG9yUHJvcGVydGllc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29ycmVjdFByb3RvdHlwZUdldHRlckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZUl0ZXJSZXN1bHRPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZVByb3BlcnR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVCdWlsdEluSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRGVmaW5lQnVpbHRJbnNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVHbG9iYWxQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZXNjcmlwdG9yc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRG9jdW1lbnRBbGxKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRG9jdW1lbnRDcmVhdGVFbGVtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVVzZXJBZ2VudEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbmdpbmVWOFZlcnNpb25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbnVtQnVnS2V5c0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRXhwb3J0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZhaWxzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZyZWV6aW5nSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmRDb250ZXh0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uQmluZE5hdGl2ZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uQ2FsbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uTmFtZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLXJhdy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNSYXdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dldEJ1aWx0SW5KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRJdGVyYXRvck1ldGhvZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2V0SXRlcmF0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRNZXRob2RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dsb2JhbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hhc093blByb3BlcnR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hpZGRlbktleXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIdG1sSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0llOERvbURlZmluZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbmRleGVkT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5oZXJpdElmUmVxdWlyZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5zcGVjdFNvdXJjZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbE1ldGFkYXRhSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ludGVybmFsU3RhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQXJyYXlJdGVyYXRvck1ldGhvZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0FycmF5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQ2FsbGFibGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNGb3JjZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNOdWxsT3JVbmRlZmluZWRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXNQdXJlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1N5bWJvbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDbG9zZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDcmVhdGVDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JEZWZpbmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JzQ29yZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0xlbmd0aE9mQXJyYXlMaWtlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzTWFrZUJ1aWx0SW5KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNNYXRoVHJ1bmNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RBc3NpZ25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RDcmVhdGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdERlZmluZVByb3BlcnRpZXNKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3REZWZpbmVQcm9wZXJ0eUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5U3ltYm9sc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRQcm90b3R5cGVPZkpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc0V4dGVuc2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc1Byb3RvdHlwZU9mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEtleXNJbnRlcm5hbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RLZXlzSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFNldFByb3RvdHlwZU9mSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09yZGluYXJ5VG9QcmltaXRpdmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3duS2V5c0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1BhdGhKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1JlcXVpcmVPYmplY3RDb2VyY2libGVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2V0U3BlY2llc0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNTZXRUb1N0cmluZ1RhZ0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZEtleUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkU3RvcmVKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N0cmluZ011bHRpYnl0ZUpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvQWJzb2x1dGVJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0luZGV4ZWRPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0ludGVnZXJPckluZmluaXR5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0xlbmd0aEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9PYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvUHJpbWl0aXZlSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb1Byb3BlcnR5S2V5SnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb1N0cmluZ1RhZ1N1cHBvcnRKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvU3RyaW5nSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVHJ5VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1VpZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNVc2VTeW1ib2xBc1VpZEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMiLCJub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNWOFByb3RvdHlwZURlZmluZUJ1Z0pzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzV2Vha01hcEJhc2ljRGV0ZWN0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlbGxLbm93blN5bWJvbEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNBcnJheUZyb21KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc0FycmF5SXRlcmF0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNNYXBDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc01hcEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNPYmplY3RBc3NpZ25KcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzT2JqZWN0VG9TdHJpbmdKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTZXRDb25zdHJ1Y3RvckpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1NldEpzIiwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1N0cmluZ0l0ZXJhdG9ySnMiLCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNXZWFrTWFwQ29uc3RydWN0b3JKcyIsIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc1dlYWtNYXBKcyIsIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0xvZGFzaENsYW1wSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc0xvZGFzaERlYm91bmNlSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9ib29sZWFuLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0Jvb2xlYW5KcyIsIl9fd2VicGFja19leHBvcnRzX18iLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvZGVib3VuY2UuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJEZWNvcmF0b3JzRGVib3VuY2VKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckRlY29yYXRvcnNJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc1JhbmdlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c0luZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9rZXlib2FyZC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c0tleWJvYXJkSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9tb3VzZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c01vdXNlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9yZXNpemUuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNSZXNpemVKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c1NlbGVjdEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvdG91Y2guanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNUb3VjaEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNXaGVlbEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9nZXQtc2l6ZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5R2V0U2l6ZUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvaXMtdmlzaWJsZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SXNWaXNpYmxlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5VXBkYXRlSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFySW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhck9wdGlvbnNKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvcGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUGx1Z2luSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclBvbHlmaWxsc0pzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxiYXJKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxpbmdTY3JvbGxJbnRvVmlld0pzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nU2Nyb2xsVG9KcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1NldFBvc2l0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU3R5bGVKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svZGlyZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tEaXJlY3Rpb25KcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svaW5kZXguanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja0luZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RodW1iLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tUaHVtYkpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90cmFjay5qcyIsIm5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclRyYWNrVHJhY2tKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZXZlbnQtaHViLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNFdmVudEh1YkpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNHZXRQb2ludGVyRGF0YUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9zaXRpb24uanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0dldFBvc2l0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pcy1vbmUtb2YuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0lzT25lT2ZKcyIsIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvc2V0LXN0eWxlLmpzIiwibm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNTZXRTdHlsZUpzIiwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanMiLCJub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc1RvdWNoUmVjb3JkSnMiLCIuL25vZGVfbW9kdWxlcy90aW55LXNsaWRlci9kaXN0L3Rpbnktc2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzVGlueVNsaWRlckRpc3RUaW55U2xpZGVySnMiLCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJub2RlX21vZHVsZXNUc2xpYlRzbGliRXM2SnMiLCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzV2VicGFja0J1aWxkaW5HbG9iYWxKcyIsIi4vc3JjL3NjcmlwdHMvZ2VuZXJhbC5qcyIsInNyY1NjcmlwdHNHZW5lcmFsSnMiLCIuL3NyYy9zY3JpcHRzL21haW4uanMiLCJzcmNTY3JpcHRzTWFpbkpzIl0sIm1hcHBpbmdzIjoiQUFBQSxhQUVBLFNBQVNBLFFBQVFDLEdBQWtDLE9BQU9ELFFBQVUsbUJBQXFCRSxRQUFVLGlCQUFtQkEsT0FBT0MsU0FBVyxTQUFVRixHQUFPLGNBQWNBLEdBQVMsU0FBVUEsR0FBTyxPQUFPQSxHQUFPLG1CQUFxQkMsUUFBVUQsRUFBSUcsY0FBZ0JGLFFBQVVELElBQVFDLE9BQU9HLFVBQVksZ0JBQWtCSixJQUFnQkEsSUFDalUsU0FBV0ssR0FJakIsSUFBSUMsRUFBbUIsR0FJdkIsU0FBU0MsRUFBb0JDLEdBR25CLEdBQUlGLEVBQWlCRSxHQUNuQixPQUFPRixFQUFpQkUsR0FBVUMsUUFLNUMsSUFBSUMsRUFBU0osRUFBaUJFLEdBQVksQ0FDaENHLEVBQUdILEVBQ0hJLEdBQUcsRUFDSEgsUUFBUyxJQWNuQixPQVJBSixFQUFRRyxHQUFVSyxLQUFLSCxFQUFPRCxRQUFTQyxFQUFRQSxFQUFPRCxRQUFTRixHQUkvREcsRUFBT0UsR0FBSSxFQUlKRixFQUFPRCxRQU9oQkYsRUFBb0JPLEVBQUlULEVBSXhCRSxFQUFvQlEsRUFBSVQsRUFJeEJDLEVBQW9CUyxFQUFJLFNBQVVQLEVBQVNRLEVBQU1DLEdBQ2xDWCxFQUFvQlksRUFBRVYsRUFBU1EsSUFDbENHLE9BQU9DLGVBQWVaLEVBQVNRLEVBQU0sQ0FDM0NLLFlBQVksRUFDWkMsSUFBS0wsS0FTWFgsRUFBb0JpQixFQUFJLFNBQVVmLEdBQ0Ysb0JBQVhSLFFBQTBCQSxPQUFPd0IsYUFDMUNMLE9BQU9DLGVBQWVaLEVBQVNSLE9BQU93QixZQUFhLENBQ3pEQyxNQUFPLFdBS1hOLE9BQU9DLGVBQWVaLEVBQVMsYUFBYyxDQUMzQ2lCLE9BQU8sS0FXWG5CLEVBQW9Cb0IsRUFBSSxTQUFVRCxFQUFPRSxHQUd2QyxHQUZtQixFQUFQQSxJQUFVRixFQUFRbkIsRUFBb0JtQixJQUV2QyxFQUFQRSxFQUFVLE9BQU9GLEVBRXJCLEdBQVcsRUFBUEUsR0FBK0IsV0FBbkI3QixRQUFRMkIsSUFBdUJBLEdBQVNBLEVBQU1HLFdBQVksT0FBT0gsRUFFakYsSUFBSUksRUFBS1YsT0FBT1csT0FBTyxNQVN2QixHQVBBeEIsRUFBb0JpQixFQUFFTSxHQUV0QlYsT0FBT0MsZUFBZVMsRUFBSSxVQUFXLENBQ25DUixZQUFZLEVBQ1pJLE1BQU9BLElBR0UsRUFBUEUsR0FBNEIsaUJBQVRGLEVBQW1CLElBQUssSUFBSU0sS0FBT04sRUFDeERuQixFQUFvQlMsRUFBRWMsRUFBSUUsRUFBSyxTQUFVQSxHQUN2QyxPQUFPTixFQUFNTSxJQUNiQyxLQUFLLEtBQU1ELElBR2YsT0FBT0YsR0FNVHZCLEVBQW9CMkIsRUFBSSxTQUFVeEIsR0FDeEIsSUFBSVEsRUFBU1IsR0FBVUEsRUFBT21CLFdBQXFCLFdBQ3pELE9BQU9uQixFQUFnQixTQUNiLFdBQ1YsT0FBT0EsR0FLVCxPQUZBSCxFQUFvQlMsRUFBRUUsRUFBUSxJQUFLQSxHQUU1QkEsR0FNVFgsRUFBb0JZLEVBQUksU0FBVWdCLEVBQVFDLEdBQ3hDLE9BQU9oQixPQUFPaEIsVUFBVWlDLGVBQWV4QixLQUFLc0IsRUFBUUMsSUFLdEQ3QixFQUFvQitCLEVBQUksR0FLakIvQixFQUFvQkEsRUFBb0JnQyxFQUFJLHlCQXhJN0MsQ0E0SUUsQ0FDSEMsMENBTUwsU0FBU0MsZ0NBQWdDL0IsT0FBUUQsUUFBU0YscUJBQ3hEbUMsS0FBSywwYkFLRkMseUNBTUwsU0FBU0MsK0JBQStCbEMsT0FBUUQsUUFBU0YscUJBQ3ZEbUMsS0FBSyxncEJBS0ZHLDZDQU1MLFNBQVNDLG1DQUFtQ3BDLE9BQVFELFFBQVNGLHFCQUMzRG1DLEtBQUssZ1ZBS0ZLLHlDQU1MLFNBQVNDLCtCQUErQnRDLE9BQVFELFFBQVNGLHFCQUN2RG1DLEtBQUssZ3BCQUtGTyw4Q0FNTCxTQUFTQyxtQ0FBbUN4QyxPQUFRRCxRQUFTRixxQkFDM0RtQyxLQUFLLDZpQkFLRlMsaURBTUwsU0FBU0MsdUNBQXVDMUMsT0FBUUQsUUFBU0YscUJBQy9EbUMsS0FBSyxxakJBS0ZXLDJEQU1MLFNBQVNDLGdEQUFnRDVDLE9BQVFELFFBQVNGLHFCQUN4RW1DLEtBQUsscWRBS0ZhLHlEQU1MLFNBQVNDLDhDQUE4QzlDLE9BQVFELFFBQVNGLHFCQUN0RW1DLEtBQUsseTlCQUtGZSxrREFNTCxTQUFTQyx3Q0FBd0NoRCxPQUFRRCxRQUFTRixxQkFDaEVtQyxLQUFLLHNaQUtGaUIsZ0RBTUwsU0FBU0Msc0NBQXNDbEQsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSywyYkFLRm1CLGtFQU1MLFNBQVNDLHNEQUFzRHBELE9BQVFELFFBQVNGLHFCQUM5RW1DLEtBQUssbW1CQUtGcUIsaURBTUwsU0FBU0MsdUNBQXVDdEQsT0FBUUQsUUFBU0YscUJBRy9EbUMsS0FBSyx1NEZBS0Z1QixxREFNTCxTQUFTQywyQ0FBMkN4RCxPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLHduREFLRnlCLHNEQU1MLFNBQVNDLDRDQUE0QzFELE9BQVFELFFBQVNGLHFCQUNwRW1DLEtBQUsscTdHQUtGMkIseURBTUwsU0FBU0MsOENBQThDNUQsT0FBUUQsUUFBU0YscUJBQ3RFbUMsS0FBSyw2NEJBS0Y2QixnRUFNTCxTQUFTQyxxREFBcUQ5RCxPQUFRRCxRQUFTRixxQkFDN0VtQyxLQUFLLCtuQ0FLRitCLDJEQU1MLFNBQVNDLGdEQUFnRGhFLE9BQVFELFFBQVNGLHFCQUN4RW1DLEtBQUssNGVBS0ZpQyx1RUFNTCxTQUFTQywwREFBMERsRSxPQUFRRCxRQUFTRixxQkFDbEZtQyxLQUFLLHNuQkFLRm1DLHFFQU1MLFNBQVNDLHlEQUF5RHBFLE9BQVFELFFBQVNGLHFCQUNqRm1DLEtBQUssd3FDQUtGcUMsa0RBTUwsU0FBU0Msd0NBQXdDdEUsT0FBUUQsUUFBU0YscUJBQ2hFbUMsS0FBSyw4WkFLRnVDLDhDQU1MLFNBQVNDLHFDQUFxQ3hFLE9BQVFELFFBQVNGLHFCQUM3RG1DLEtBQUsscThDQUtGeUMsd0RBTUwsU0FBU0MsOENBQThDMUUsT0FBUUQsUUFBU0YscUJBR3RFbUMsS0FBSyxraFNBS0YyQyxzREFNTCxTQUFTQyw0Q0FBNEM1RSxPQUFRRCxRQUFTRixxQkFHcEVtQyxLQUFLLDIzS0FLRjZDLGlEQU1MLFNBQVNDLHdDQUF3QzlFLE9BQVFELFFBQVNGLHFCQUdoRW1DLEtBQUssNHJMQUtGK0Msa0VBTUwsU0FBU0MsdURBQXVEaEYsT0FBUUQsUUFBU0YscUJBQy9FbUMsS0FBSyxtbUNBS0ZpRCwrREFNTCxTQUFTQyxvREFBb0RsRixPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLHNjQUtGbUQsZ0VBTUwsU0FBU0Msb0RBQW9EcEYsT0FBUUQsU0FDbkVpQyxLQUFLLCtSQUtGcUQscUVBTUwsU0FBU0MseURBQXlEdEYsT0FBUUQsUUFBU0YscUJBQ2pGbUMsS0FBSyx3d0JBS0Z1RCxpRUFNTCxTQUFTQyxzREFBc0R4RixPQUFRRCxTQUNyRWlDLEtBQUssc1JBS0Z5RCxzREFNTCxTQUFTQyw0Q0FBNEMxRixPQUFRRCxRQUFTRixxQkFHcEVtQyxLQUFLLGt4QkFLRjJELHNEQU1MLFNBQVNDLDJDQUEyQzVGLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssMDFDQUtGNkQsdURBTUwsU0FBU0MsNENBQTRDOUYsT0FBUUQsUUFBU0YscUJBQ3BFbUMsS0FBSywrV0FLRitELDZEQU1MLFNBQVNDLGtEQUFrRGhHLE9BQVFELFFBQVNGLHFCQUMxRW1DLEtBQUssNGdCQUtGaUUsa0RBTUwsU0FBU0MseUNBQXlDbEcsT0FBUUQsUUFBU0YscUJBQ2pFbUMsS0FBSywyY0FLRm1FLG1EQU1MLFNBQVNDLHlDQUF5Q3BHLE9BQVFELFNBQ3hEaUMsS0FBSyx5V0FLRnFFLDhEQU1MLFNBQVNDLG1EQUFtRHRHLE9BQVFELFFBQVNGLHFCQUMzRW1DLEtBQUssNmpCQUtGdUUsd0RBTUwsU0FBU0MsNkNBQTZDeEcsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyxzUkFLRnlFLHdEQU1MLFNBQVNDLDZDQUE2QzFHLE9BQVFELFFBQVNGLHFCQUNyRW1DLEtBQUssbWxDQUtGMkUsb0RBTUwsU0FBU0MseUNBQXlDNUcsT0FBUUQsU0FDeERpQyxLQUFLLGdSQUtGNkUsNkNBTUwsU0FBU0Msb0NBQW9DOUcsT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2d0dBS0YrRSw0Q0FNTCxTQUFTQyxtQ0FBbUNoSCxPQUFRRCxTQUNsRGlDLEtBQUssK0xBS0ZpRiwrQ0FNTCxTQUFTQyxzQ0FBc0NsSCxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLG9aQUtGbUYsNERBTUwsU0FBU0MsaURBQWlEcEgsT0FBUUQsUUFBU0YscUJBQ3pFbUMsS0FBSyw2d0JBS0ZxRiwyREFNTCxTQUFTQyxnREFBZ0R0SCxPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLG1mQUtGdUYsb0RBTUwsU0FBU0MsMENBQTBDeEgsT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyxxWEFLRnlGLG9EQU1MLFNBQVNDLDBDQUEwQzFILE9BQVFELFFBQVNGLHFCQUNsRW1DLEtBQUssMjdCQUtGMkYsZ0VBTUwsU0FBU0Msb0RBQW9ENUgsT0FBUUQsUUFBU0YscUJBQzVFbUMsS0FBSyxvaUJBS0Y2Riw0REFNTCxTQUFTQyxpREFBaUQ5SCxPQUFRRCxRQUFTRixxQkFDekVtQyxLQUFLLDhsQkFLRitGLG1EQU1MLFNBQVNDLHdDQUF3Q2hJLE9BQVFELFFBQVNGLHFCQUNoRW1DLEtBQUssb2tCQUtGaUcsMERBTUwsU0FBU0MsK0NBQStDbEksT0FBUUQsUUFBU0YscUJBQ3ZFbUMsS0FBSyxnN0JBS0ZtRyxtREFNTCxTQUFTQyx5Q0FBeUNwSSxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLG9oQ0FLRnFHLGlEQU1MLFNBQVNDLHVDQUF1Q3RJLE9BQVFELFFBQVNGLHFCQUMvRG1DLEtBQUssd2lCQUtGdUcsNkNBTUwsU0FBU0Msb0NBQW9DeEksT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2MkJBS0Z5Ryx1REFNTCxTQUFTQyw0Q0FBNEMxSSxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLG9wQkFLRjJHLGtEQU1MLFNBQVNDLHdDQUF3QzVJLE9BQVFELFNBQ3ZEaUMsS0FBSyx3R0FLRjZHLDJDQU1MLFNBQVNDLGtDQUFrQzlJLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssd1FBS0YrRyxxREFNTCxTQUFTQywwQ0FBMENoSixPQUFRRCxRQUFTRixxQkFDbEVtQyxLQUFLLGl3QkFLRmlILHFEQU1MLFNBQVNDLDJDQUEyQ2xKLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssdzVCQUtGbUgsMERBTUwsU0FBU0MsK0NBQStDcEosT0FBUUQsUUFBU0YscUJBQ3ZFbUMsS0FBSyxnaUNBS0ZxSCxxREFNTCxTQUFTQywyQ0FBMkN0SixPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLHl3QkFLRnVILHdEQU1MLFNBQVNDLDhDQUE4Q3hKLE9BQVFELFFBQVNGLHFCQUN0RW1DLEtBQUssMHVIQUtGeUgscURBTUwsU0FBU0MsMkNBQTJDMUosT0FBUUQsUUFBU0YscUJBQ25FbUMsS0FBSyx3dUZBS0YySCwrREFNTCxTQUFTQyxtREFBbUQ1SixPQUFRRCxRQUFTRixxQkFDM0VtQyxLQUFLLDhsQkFLRjZILCtDQU1MLFNBQVNDLHFDQUFxQzlKLE9BQVFELFFBQVNGLHFCQUM3RG1DLEtBQUsseWJBS0YrSCxrREFNTCxTQUFTQyx3Q0FBd0NoSyxPQUFRRCxRQUFTRixxQkFDaEVtQyxLQUFLLDBoQkFLRmlJLHFEQU1MLFNBQVNDLDJDQUEyQ2xLLE9BQVFELFFBQVNGLHFCQUNuRW1DLEtBQUssc3pFQUtGbUksZ0RBTUwsU0FBU0Msc0NBQXNDcEssT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSyxzMUJBS0ZxSSwyREFNTCxTQUFTQywrQ0FBK0N0SyxPQUFRRCxTQUM5RGlDLEtBQUssaVRBS0Z1SSxnREFNTCxTQUFTQyxzQ0FBc0N4SyxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLGdtQkFLRnlJLDhDQU1MLFNBQVNDLG9DQUFvQzFLLE9BQVFELFNBQ25EaUMsS0FBSyx1R0FLRjJJLGdEQU1MLFNBQVNDLHNDQUFzQzVLLE9BQVFELFFBQVNGLHFCQUM5RG1DLEtBQUssNDJCQUtGNkksOENBTUwsU0FBU0MscUNBQXFDOUssT0FBUUQsUUFBU0YscUJBQzdEbUMsS0FBSyxpMkdBS0YrSSxxREFNTCxTQUFTQywyQ0FBMkNoTCxPQUFRRCxRQUFTRixxQkFDbkVtQyxLQUFLLDY3QkFLRmlKLGtFQU1MLFNBQVNDLHVEQUF1RGxMLE9BQVFELFFBQVNGLHFCQUcvRW1DLEtBQUsseXRDQUtGbUosc0RBTUwsU0FBU0MsNENBQTRDcEwsT0FBUUQsUUFBU0YscUJBR3BFbUMsS0FBSyxna0xBS0ZxSixxREFNTCxTQUFTQywyQ0FBMkN0TCxPQUFRRCxRQUFTRixxQkFHbkVtQyxLQUFLLHk2RUFLRnVKLGdEQU1MLFNBQVNDLHVDQUF1Q3hMLE9BQVFELFNBQ3REaUMsS0FBSyxzR0FLRnlKLDJEQU1MLFNBQVNDLCtDQUErQzFMLE9BQVFELFFBQVNGLHFCQUN2RW1DLEtBQUssc1hBS0YySixvREFNTCxTQUFTQyx5Q0FBeUM1TCxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLCs3RkFLRjZKLGlEQU1MLFNBQVNDLHVDQUF1QzlMLE9BQVFELFNBQ3REaUMsS0FBSyx5V0FLRitKLG9EQU1MLFNBQVNDLDBDQUEwQ2hNLE9BQVFELFFBQVNGLHFCQUdsRW1DLEtBQUssMGtHQUtGaUssb0RBTUwsU0FBU0MsMENBQTBDbE0sT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyw0cEhBS0ZtSywrREFNTCxTQUFTQyxvREFBb0RwTSxPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLCs2Q0FLRnFLLDZEQU1MLFNBQVNDLGtEQUFrRHRNLE9BQVFELFFBQVNGLHFCQUMxRW1DLEtBQUssdTBFQUtGdUsseUVBTUwsU0FBU0MsNERBQTREeE0sT0FBUUQsUUFBU0YscUJBQ3BGbUMsS0FBSyxnekRBS0Z5Syw2RUFNTCxTQUFTQywrREFBK0QxTSxPQUFRRCxRQUFTRixxQkFDdkZtQyxLQUFLLDJ3Q0FLRjJLLG9FQU1MLFNBQVNDLHVEQUF1RDVNLE9BQVFELFFBQVNGLHFCQUMvRW1DLEtBQUssb3VCQUtGNkssc0VBTUwsU0FBU0MseURBQXlEOU0sT0FBUUQsU0FDeEVpQyxLQUFLLHlOQUtGK0ssOERBTUwsU0FBU0Msa0RBQWtEaE4sT0FBUUQsUUFBU0YscUJBQzFFbUMsS0FBSyw2MkNBS0ZpTCwyREFNTCxTQUFTQyxnREFBZ0RsTixPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLHVvQ0FLRm1MLDZEQU1MLFNBQVNDLGlEQUFpRHBOLE9BQVFELFFBQVNGLHFCQUN6RW1DLEtBQUssK1JBS0ZxTCwyREFNTCxTQUFTQyxnREFBZ0R0TixPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLDJwQ0FLRnVMLGtEQU1MLFNBQVNDLHdDQUF3Q3hOLE9BQVFELFFBQVNGLHFCQUNoRW1DLEtBQUssMGtCQUtGeUwsb0VBTUwsU0FBU0Msd0RBQXdEMU4sT0FBUUQsUUFBU0YscUJBR2hGbUMsS0FBSyx1dUJBS0YyTCw4REFNTCxTQUFTQyxrREFBa0Q1TixPQUFRRCxRQUFTRixxQkFDMUVtQyxLQUFLLHM0Q0FLRjZMLHVEQU1MLFNBQVNDLDRDQUE0QzlOLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssc2xCQUtGK0wsNERBTUwsU0FBU0MsaURBQWlEaE8sT0FBUUQsUUFBU0YscUJBQ3pFbUMsS0FBSywwL0JBS0ZpTSwrQ0FNTCxTQUFTQyxxQ0FBcUNsTyxPQUFRRCxRQUFTRixxQkFDN0RtQyxLQUFLLCtxQ0FLRm1NLDJDQU1MLFNBQVNDLGtDQUFrQ3BPLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssbU5BS0ZxTSwrREFNTCxTQUFTQyxvREFBb0R0TyxPQUFRRCxRQUFTRixxQkFDNUVtQyxLQUFLLDhmQUtGdU0sa0RBTUwsU0FBU0Msd0NBQXdDeE8sT0FBUUQsUUFBU0YscUJBR2hFbUMsS0FBSyxzL0JBS0Z5TSx3REFNTCxTQUFTQyw0Q0FBNEMxTyxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLHd5QkFLRjJNLGlEQU1MLFNBQVNDLHVDQUF1QzVPLE9BQVFELFFBQVNGLHFCQUMvRG1DLEtBQUssd1pBS0Y2TSxtREFNTCxTQUFTQyx5Q0FBeUM5TyxPQUFRRCxRQUFTRixxQkFDakVtQyxLQUFLLDZkQUtGK00sNkNBTUwsU0FBU0Msb0NBQW9DaFAsT0FBUUQsUUFBU0YscUJBQzVEbUMsS0FBSyw2ckJBS0ZpTix1REFNTCxTQUFTQyw2Q0FBNkNsUCxPQUFRRCxRQUFTRixxQkFDckVtQyxLQUFLLHd5REFLRm1OLG1FQU1MLFNBQVNDLHdEQUF3RHBQLE9BQVFELFFBQVNGLHFCQUNoRm1DLEtBQUssMjdCQUtGcU4sd0RBTUwsU0FBU0MsNkNBQTZDdFAsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyx5b0JBS0Z1Tix3REFNTCxTQUFTQyw2Q0FBNkN4UCxPQUFRRCxRQUFTRixxQkFDckVtQyxLQUFLLGtoQkFLRnlOLDZEQU1MLFNBQVNDLGlEQUFpRDFQLE9BQVFELFFBQVNGLHFCQUN6RW1DLEtBQUssd2ZBS0YyTixnREFNTCxTQUFTQyxzQ0FBc0M1UCxPQUFRRCxRQUFTRixxQkFDOURtQyxLQUFLLGdmQUtGNk4sZ0RBTUwsU0FBU0Msc0NBQXNDOVAsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSyx3YkFLRitOLG1EQU1MLFNBQVNDLHlDQUF5Q2hRLE9BQVFELFFBQVNGLHFCQUNqRW1DLEtBQUssMi9DQUtGaU8sc0RBTUwsU0FBU0MsMkNBQTJDbFEsT0FBUUQsUUFBU0YscUJBQ25FbUMsS0FBSyx1aUJBS0ZtTyw0REFNTCxTQUFTQyxnREFBZ0RwUSxPQUFRRCxRQUFTRixxQkFDeEVtQyxLQUFLLGlZQUtGcU8sZ0RBTUwsU0FBU0Msc0NBQXNDdFEsT0FBUUQsUUFBU0YscUJBQzlEbUMsS0FBSywwWUFLRnVPLG9EQU1MLFNBQVNDLHlDQUF5Q3hRLE9BQVFELFNBQ3hEaUMsS0FBSyxpUEFLRnlPLDBDQU1MLFNBQVNDLGlDQUFpQzFRLE9BQVFELFFBQVNGLHFCQUN6RG1DLEtBQUssd2JBS0YyTyx3REFNTCxTQUFTQyw0Q0FBNEM1USxPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLG1aQUtGNk8sOERBTUwsU0FBU0Msa0RBQWtEOVEsT0FBUUQsUUFBU0YscUJBQzFFbUMsS0FBSyx3cUJBS0YrTywrREFNTCxTQUFTQyxtREFBbURoUixPQUFRRCxRQUFTRixxQkFDM0VtQyxLQUFLLHNiQUtGaVAsd0RBTUwsU0FBU0MsNkNBQTZDbFIsT0FBUUQsUUFBU0YscUJBQ3JFbUMsS0FBSyxna0RBS0ZtUCxrREFNTCxTQUFTQyx1Q0FBdUNwUixPQUFRRCxRQUFTRixxQkFDL0RtQyxLQUFLLGd6QkFLRnFQLHNEQU1MLFNBQVNDLDJDQUEyQ3RSLE9BQVFELFFBQVNGLHFCQUduRW1DLEtBQUssdzFHQUtGdVAsdURBTUwsU0FBU0MsNENBQTRDeFIsT0FBUUQsUUFBU0YscUJBR3BFbUMsS0FBSyw4akJBS0Z5UCwyQ0FNTCxTQUFTQyxpQ0FBaUMxUixPQUFRRCxRQUFTRixxQkFDekRtQyxLQUFLLGlSQUtGMlAscURBTUwsU0FBU0MsMENBQTBDNVIsT0FBUUQsUUFBU0YscUJBQ2xFbUMsS0FBSyx1akJBS0Y2UCx3REFNTCxTQUFTQyw0Q0FBNEM5UixPQUFRRCxRQUFTRixxQkFDcEVtQyxLQUFLLDRzQkFLRitQLHVEQU1MLFNBQVNDLDRDQUE0Q2hTLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssOGpCQUtGaVEsMkNBTUwsU0FBU0MsaUNBQWlDbFMsT0FBUUQsUUFBU0YscUJBQ3pEbUMsS0FBSyxpUkFLRm1RLHVEQU1MLFNBQVNDLDRDQUE0Q3BTLE9BQVFELFFBQVNGLHFCQUdwRW1DLEtBQUssb25EQUtGcVEsNERBTUwsU0FBU0MsZ0RBQWdEdFMsT0FBUUQsUUFBU0YscUJBR3hFbUMsS0FBSyx5ckhBS0Z1USxnREFNTCxTQUFTQyxxQ0FBcUN4UyxPQUFRRCxRQUFTRixxQkFDN0RtQyxLQUFLLGdTQUtGeVEsdUNBTUwsU0FBU0MsK0JBQStCMVMsT0FBUUQsU0FDOUNpQyxLQUFLLHUvS0FLRjJRLDBDQU1MLFNBQVNDLGtDQUFrQzVTLE9BQVFELFFBQVNGLHFCQUMxRG1DLEtBQUssNHFXQUtGNlEsd0RBTUwsU0FBU0MsK0NBQStDOVMsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssd3dCQUtGZ1IseURBTUwsU0FBU0MsZ0RBQWdEalQsT0FBUStTLG9CQUFxQmxULHFCQUdwRm1DLEtBQUssMDVDQUtGa1Isc0RBTUwsU0FBU0MsNkNBQTZDblQsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssMG1DQUtGb1Isc0RBTUwsU0FBU0MsNkNBQTZDclQsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssc3pDQUtGc1Isa0RBTUwsU0FBU0MseUNBQXlDdlQsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssMGtFQUtGd1IscURBTUwsU0FBU0MsNENBQTRDelQsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssODdHQUtGMFIsa0RBTUwsU0FBU0MseUNBQXlDM1QsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssNHlLQUtGNFIsbURBTUwsU0FBU0MsMENBQTBDN1QsT0FBUStTLG9CQUFxQmxULHFCQUc5RW1DLEtBQUssMGdDQUtGOFIsbURBTUwsU0FBU0MsMENBQTBDL1QsT0FBUStTLG9CQUFxQmxULHFCQUc5RW1DLEtBQUssbytIQUtGZ1Msa0RBTUwsU0FBU0MseUNBQXlDalUsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssK2tFQUtGa1Msa0RBTUwsU0FBU0MseUNBQXlDblUsT0FBUStTLG9CQUFxQmxULHFCQUc3RW1DLEtBQUssaXpEQUtGb1MsdURBTUwsU0FBU0MsNkNBQTZDclUsT0FBUStTLG9CQUFxQmxULHFCQUdqRm1DLEtBQUssb3lDQUtGc1Msb0RBTUwsU0FBU0MsMkNBQTJDdlUsT0FBUStTLG9CQUFxQmxULHFCQUcvRW1DLEtBQUssc25DQUtGd1MseURBTUwsU0FBU0MsK0NBQStDelUsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssbXZCQUtGMFMscURBTUwsU0FBU0MsNENBQTRDM1UsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssa21DQUtGNFMsMkNBTUwsU0FBU0MsbUNBQW1DN1UsT0FBUStTLG9CQUFxQmxULHFCQUd2RW1DLEtBQUssbzBLQUtGOFMsNkNBTUwsU0FBU0MscUNBQXFDL1UsT0FBUStTLG9CQUFxQmxULHFCQUd6RW1DLEtBQUssdTZHQUtGZ1QsNENBTUwsU0FBU0Msb0NBQW9DalYsT0FBUStTLG9CQUFxQmxULHFCQUd4RW1DLEtBQUssbXNGQUtGa1QsK0NBTUwsU0FBU0MsdUNBQXVDblYsT0FBUStTLG9CQUFxQmxULHFCQUczRW1DLEtBQUssbTBEQUtGb1QsK0NBTUwsU0FBU0MsdUNBQXVDclYsT0FBUStTLG9CQUFxQmxULHFCQUczRW1DLEtBQUssOC9lQUtGc1QscURBTUwsU0FBU0MsNENBQTRDdlYsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssb3NDQUtGd1QsZ0VBTUwsU0FBU0MscURBQXFEelYsT0FBUStTLG9CQUFxQmxULHFCQUd6Rm1DLEtBQUssdW5EQUtGMFQseURBTUwsU0FBU0MsK0NBQStDM1YsT0FBUStTLG9CQUFxQmxULHFCQUduRm1DLEtBQUssd2lFQUtGNFQsNERBTUwsU0FBU0Msa0RBQWtEN1YsT0FBUStTLG9CQUFxQmxULHFCQUd0Rm1DLEtBQUssOGdFQUtGOFQsMkNBTUwsU0FBU0MsbUNBQW1DL1YsT0FBUStTLG9CQUFxQmxULHFCQUd2RW1DLEtBQUssdTBFQUtGZ1UscURBTUwsU0FBU0MsNENBQTRDalcsT0FBUStTLG9CQUFxQmxULHFCQUdoRm1DLEtBQUssNmNBS0ZrVSxpREFNTCxTQUFTQyx3Q0FBd0NuVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyxxL0VBS0ZvVSxpREFNTCxTQUFTQyx3Q0FBd0NyVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyxrMEZBS0ZzVSxpREFNTCxTQUFTQyx3Q0FBd0N2VyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyw4dUVBS0Z3VSxxREFNTCxTQUFTQywyQ0FBMkN6VyxPQUFRK1Msb0JBQXFCbFQscUJBRy9FbUMsS0FBSywraUVBS0YwVSw0REFNTCxTQUFTQyxpREFBaUQzVyxPQUFRK1Msb0JBQXFCbFQscUJBR3JGbUMsS0FBSyxtaUJBS0Y0VSx3REFNTCxTQUFTQyw4Q0FBOEM3VyxPQUFRK1Msb0JBQXFCbFQscUJBR2xGbUMsS0FBSyx3dEJBS0Y4VSxpREFNTCxTQUFTQyx3Q0FBd0MvVyxPQUFRK1Msb0JBQXFCbFQscUJBRzVFbUMsS0FBSyx3L0VBS0ZnVixxREFNTCxTQUFTQywwQ0FBMENqWCxPQUFRK1Msb0JBQXFCbFQscUJBRzlFbUMsS0FBSyxrY0FLRmtWLHFEQU1MLFNBQVNDLDJDQUEyQ25YLE9BQVErUyxvQkFBcUJsVCxxQkFHL0VtQyxLQUFLLDJwQ0FLRm9WLHdEQU1MLFNBQVNDLDhDQUE4Q3JYLE9BQVErUyxvQkFBcUJsVCxxQkFHbEZtQyxLQUFLLDgwS0FLRnNWLGlEQU1MLFNBQVNDLHVDQUF1Q3ZYLE9BQVFELFFBQVNGLHFCQUcvRG1DLEtBQUssd2t2R0FLRndWLG9DQU1MLFNBQVNDLDRCQUE0QnpYLE9BQVErUyxvQkFBcUJsVCxxQkFHaEVtQyxLQUFLLDZ6YUFLRjBWLDJDQU1MLFNBQVNDLG1DQUFtQzNYLE9BQVFELFNBQ2xEaUMsS0FBSyxnakJBS0Y0ViwyQkFNTCxTQUFTQyxvQkFBb0I3WCxPQUFRK1Msb0JBQXFCbFQscUJBR3hEbUMsS0FBSyxnemJBS0Y4Vix3QkFNTCxTQUFTQyxpQkFBaUIvWCxPQUFRK1Msb0JBQXFCbFQscUJBR3JEbUMsS0FBSyIsImZpbGUiOiJtYWluLnNjcmlwdHMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbi8qKioqKiovKGZ1bmN0aW9uIChtb2R1bGVzKSB7XG4gIC8vIHdlYnBhY2tCb290c3RyYXBcbiAgLyoqKioqKi8gLy8gVGhlIG1vZHVsZSBjYWNoZVxuICAvKioqKioqL1xuICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAvKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAvKioqKioqL1xuICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiAgICAvKioqKioqL2lmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuICAgICAgLyoqKioqKi9yZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gICAgLyoqKioqKi9cbiAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAvKioqKioqL2k6IG1vZHVsZUlkLFxuICAgICAgLyoqKioqKi9sOiBmYWxzZSxcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gICAgLyoqKioqKi9cbiAgICBtb2R1bGUubCA9IHRydWU7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH1cbiAgLyoqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uIChleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAvKioqKioqL2lmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gICAgICAvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAvKioqKioqL2lmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICB2YWx1ZTogJ01vZHVsZSdcbiAgICAgIH0pO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuICAvKioqKioqLyAvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiAgLyoqKioqKi8gLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gIC8qKioqKiovIC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuICAvKioqKioqLyAvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgIC8qKioqKiovaWYgKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuICAgIC8qKioqKiovXG4gICAgaWYgKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gICAgLyoqKioqKi9cbiAgICBpZiAobW9kZSAmIDQgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAvKioqKioqL1xuICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqKioqKi9cbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuICAgIC8qKioqKiovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICAvKioqKioqL1xuICAgIGlmIChtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICB9LmJpbmQobnVsbCwga2V5KSk7XG4gICAgfVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG5zO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKioqKioqL3ZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyAvKioqKioqL2Z1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107XG4gICAgfSA6IC8qKioqKiovZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiAgICAvKioqKioqL1xuICAgIHJldHVybiBnZXR0ZXI7XG4gICAgLyoqKioqKi9cbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gIC8qKioqKiovXG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvc2NyaXB0cy9tYWluLmpzXCIpO1xuICAvKioqKioqL1xufVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovKSh7XG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNFc0FycmF5RnJvbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvZXMuYXJyYXkuZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcXFwiKTtcXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2ludGVybmFscy9wYXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLkFycmF5LmZyb207XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL21hcC9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0VzTWFwSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcXFwiKTtcXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2ludGVybmFscy9wYXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk1hcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9tYXAvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNPYmplY3RBc3NpZ25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmFzc2lnbjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3QvYXNzaWduLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvc2V0L2luZGV4LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3NldC9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNTZXRJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5zZXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguU2V0O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3NldC9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL3dlYWstbWFwL2luZGV4LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvd2Vhay1tYXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzRXNXZWFrTWFwSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvZXMud2Vhay1tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguV2Vha01hcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy93ZWFrLW1hcC9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQUNhbGxhYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciB0cnlUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90cnktdG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQVBvc3NpYmxlUHJvdG90eXBlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcblxcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKFxcXCJDYW4ndCBzZXQgXFxcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FkZFRvVW5zY29wYWJsZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpLmY7XFxuXFxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXFxuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcXG4gIGRlZmluZVByb3BlcnR5KEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xcbiAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcXG4gIH0pO1xcbn1cXG5cXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQW5JbnN0YW5jZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xcbiAgaWYgKGlzUHJvdG90eXBlT2YoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcXG4gIHRocm93ICRUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQW5PYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyICRTdHJpbmcgPSBTdHJpbmc7XFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XFxuICB0aHJvdyAkVHlwZUVycm9yKCRTdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCIvLyBGRjI2LSBidWc6IEFycmF5QnVmZmVycyBhcmUgbm9uLWV4dGVuc2libGUsIGJ1dCBPYmplY3QuaXNFeHRlbnNpYmxlIGRvZXMgbm90IHJlcG9ydCBpdFxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoYnVmZmVyKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1ZmZlciwgJ2EnLCB7IHZhbHVlOiA4IH0pO1xcbiAgfVxcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5RnJvbUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzXFxcIik7XFxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qc1xcXCIpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG52YXIgaXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGdldEl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzXFxcIik7XFxudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG5cXG52YXIgJEFycmF5ID0gQXJyYXk7XFxuXFxuLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xcbiAgdmFyIElTX0NPTlNUUlVDVE9SID0gaXNDb25zdHJ1Y3Rvcih0aGlzKTtcXG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcXG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcXG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XFxuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PT0gJEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XFxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcXG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XFxuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XFxuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcXG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkobGVuZ3RoKTtcXG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XFxuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNBcnJheUluY2x1ZGVzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXFxcIik7XFxudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XFxuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xcbiAgICB2YXIgdmFsdWU7XFxuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXFxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlJdGVyYXRpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanNcXFwiKTtcXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcXFwiKTtcXG5cXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcXG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XFxuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XFxuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XFxuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcXG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCk7XFxuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShzZWxmKTtcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcXG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcXG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XFxuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XFxuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xcbiAgICAgIGlmIChUWVBFKSB7XFxuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XFxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXFxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcXG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcXG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcXG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QoNylcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQXJyYXlTbGljZVNpbXBsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1xcXCIpO1xcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcXFwiKTtcXG5cXG52YXIgJEFycmF5ID0gQXJyYXk7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcXG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcXG4gIHZhciByZXN1bHQgPSAkQXJyYXkobWF4KGZpbiAtIGssIDApKTtcXG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcXG4gIHJlc3VsdC5sZW5ndGggPSBuO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U3BlY2llc0NvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1xcXCIpO1xcbnZhciBpc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcXG52YXIgJEFycmF5ID0gQXJyYXk7XFxuXFxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xcbiAgdmFyIEM7XFxuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcXG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcXG4gICAgaWYgKGlzQ29uc3RydWN0b3IoQykgJiYgKEMgPT09ICRBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XFxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XFxuICAgICAgQyA9IENbU1BFQ0lFU107XFxuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0FycmF5U3BlY2llc0NyZWF0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcblxcbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XFxuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpdGVyYXRvckNsb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qc1xcXCIpO1xcblxcbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XFxuXFxudHJ5IHtcXG4gIHZhciBjYWxsZWQgPSAwO1xcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcXG4gICAgfSxcXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xcbiAgICB9XFxuICB9O1xcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcXG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcXG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xcbiAgdHJ5IHtcXG4gICAgdmFyIG9iamVjdCA9IHt9O1xcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH07XFxuICAgIGV4ZWMob2JqZWN0KTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mUmF3SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpc1JhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzXFxcIik7XFxuXFxudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXNSYXcoe30udG9TdHJpbmcpO1xcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzUmF3KCcnLnNsaWNlKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNDbGFzc29mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcXFwiKTtcXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xcblxcbi8vIEVTMyB3cm9uZyBoZXJlXFxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBpdFtrZXldO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbn07XFxuXFxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXFxuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXFxuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25TdHJvbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpLmY7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcXFwiKTtcXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1xcXCIpO1xcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzXFxcIik7XFxudmFyIGRlZmluZUl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWRlZmluZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzXFxcIik7XFxudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qc1xcXCIpO1xcbnZhciBzZXRTcGVjaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZmFzdEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanNcXFwiKS5mYXN0S2V5O1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpO1xcblxcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcXG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcXG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcXG4gICAgICAgIHNpemU6IDBcXG4gICAgICB9KTtcXG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaXRlcmFibGUpKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgeyB0aGF0OiB0aGF0LCBBU19FTlRSSUVTOiBJU19NQVAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xcblxcbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XFxuXFxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XFxuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcXG4gICAgICB2YXIgcHJldmlvdXMsIGluZGV4O1xcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxcbiAgICAgIGlmIChlbnRyeSkge1xcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcXG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcXG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxcbiAgICAgICAgICBrZXk6IGtleSxcXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXFxuICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcXG4gICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XFxuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xcbiAgICAgICAgLy8gYWRkIHRvIGluZGV4XFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XFxuICAgICAgfSByZXR1cm4gdGhhdDtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XFxuICAgICAgLy8gZmFzdCBjYXNlXFxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xcbiAgICAgIHZhciBlbnRyeTtcXG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcXG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcXG4gICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcXG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIHtcXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmNsZWFyXFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcXG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XFxuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcXG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcXG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcXG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtcXG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5kZWxldGVcXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcXG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XFxuICAgICAgICBpZiAoZW50cnkpIHtcXG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXZpb3VzO1xcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcXG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubmV4dCA9IG5leHQ7XFxuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcXG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XFxuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcXG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XFxuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XFxuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xcbiAgICAgIH0sXFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKWAgbWV0aG9kc1xcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG4gICAgICAgIHZhciBlbnRyeTtcXG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XFxuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XFxuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IE1hcCwgU2V0fS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmhhc1xcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIElTX01BUCA/IHtcXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcXG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcXG4gICAgICB9LFxcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSA6IHtcXG4gICAgICAvLyBgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkoUHJvdG90eXBlLCAnc2l6ZScsIHtcXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbiAgfSxcXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcXG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XFxuICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XFxuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKElURVJBVE9SX05BTUUpO1xcbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmVudHJpZXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUtQEBpdGVyYXRvclxcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUudmFsdWVzXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXFxuICAgIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcXG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXFxuICAgICAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcXG4gICAgICAgIGtpbmQ6IGtpbmQsXFxuICAgICAgICBsYXN0OiB1bmRlZmluZWRcXG4gICAgICB9KTtcXG4gICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcXG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XFxuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcXG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcXG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcXG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxcbiAgICAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XFxuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxcbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcXG4gICAgICB9XFxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZW50cnkua2V5LCBmYWxzZSk7XFxuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LnZhbHVlLCBmYWxzZSk7XFxuICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBmYWxzZSk7XFxuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcXG5cXG4gICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGVbQEBzcGVjaWVzXWAgYWNjZXNzb3JzXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LW1hcC1AQHNwZWNpZXNcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xcbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvbGxlY3Rpb25XZWFrSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcXFwiKTtcXG52YXIgZ2V0V2Vha0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIikuZ2V0V2Vha0RhdGE7XFxudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUuanNcXFwiKTtcXG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcXFwiKTtcXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG5cXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XFxudmFyIGZpbmQgPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kO1xcbnZhciBmaW5kSW5kZXggPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kSW5kZXg7XFxudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzKFtdLnNwbGljZSk7XFxudmFyIGlkID0gMDtcXG5cXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSkge1xcbiAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XFxufTtcXG5cXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZW50cmllcyA9IFtdO1xcbn07XFxuXFxudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XFxuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XFxuICB9KTtcXG59O1xcblxcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcXG4gIH0sXFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcXG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xcbiAgICBlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XFxuICB9LFxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XFxuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XFxuICAgIH0pO1xcbiAgICBpZiAofmluZGV4KSBzcGxpY2UodGhpcy5lbnRyaWVzLCBpbmRleCwgMSk7XFxuICAgIHJldHVybiAhIX5pbmRleDtcXG4gIH1cXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XFxuICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XFxuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBQcm90b3R5cGUpO1xcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcXG4gICAgICAgIGlkOiBpZCsrLFxcbiAgICAgICAgZnJvemVuOiB1bmRlZmluZWRcXG4gICAgICB9KTtcXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG5cXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xcblxcbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xcbiAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XFxuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtcXG4gICAgICBlbHNlIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XFxuICAgICAgcmV0dXJuIHRoYXQ7XFxuICAgIH07XFxuXFxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwge1xcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmRlbGV0ZVxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuZGVsZXRlXFxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XFxuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcXG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcXG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSlbJ2RlbGV0ZSddKGtleSk7XFxuICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXNPd24oZGF0YSwgc3RhdGUuaWQpICYmIGRlbGV0ZSBkYXRhW3N0YXRlLmlkXTtcXG4gICAgICB9LFxcbiAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmhhc1xcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuaGFzXFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XFxuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XFxuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBkZWZpbmVCdWlsdElucyhQcm90b3R5cGUsIElTX01BUCA/IHtcXG4gICAgICAvLyBgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZ2V0XFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcXG4gICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpO1xcbiAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5zZXRcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSA6IHtcXG4gICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5hZGRcXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29sbGVjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIik7XFxudmFyIGl0ZXJhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qc1xcXCIpO1xcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1xcXCIpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiKTtcXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xcbiAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XFxuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIHZhciBDb25zdHJ1Y3RvciA9IE5hdGl2ZUNvbnN0cnVjdG9yO1xcbiAgdmFyIGV4cG9ydGVkID0ge307XFxuXFxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMoTmF0aXZlUHJvdG90eXBlW0tFWV0pO1xcbiAgICBkZWZpbmVCdWlsdEluKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxcbiAgICAgIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xcbiAgICAgICAgdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XFxuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcXG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcXG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICAgIHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuICAgICk7XFxuICB9O1xcblxcbiAgdmFyIFJFUExBQ0UgPSBpc0ZvcmNlZChcXG4gICAgQ09OU1RSVUNUT1JfTkFNRSxcXG4gICAgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XFxuICAgIH0pKVxcbiAgKTtcXG5cXG4gIGlmIChSRVBMQUNFKSB7XFxuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXFxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcXG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xcbiAgICAvLyBWOCB+IENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XFxuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XFxuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XFxuICAgICAgdmFyIGluZGV4ID0gNTtcXG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XFxuICAgIH0pO1xcblxcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcXG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgTmF0aXZlUHJvdG90eXBlKTtcXG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XFxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoYXQ7XFxuICAgICAgfSk7XFxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gTmF0aXZlUHJvdG90eXBlO1xcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xcbiAgICB9XFxuXFxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XFxuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcXG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xcbiAgICB9XFxuXFxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xcblxcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XFxuICB9XFxuXFxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xcbiAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogQ29uc3RydWN0b3IgIT0gTmF0aXZlQ29uc3RydWN0b3IgfSwgZXhwb3J0ZWQpO1xcblxcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xcblxcbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xcblxcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ29weUNvbnN0cnVjdG9yUHJvcGVydGllc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vd24ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XFxuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGtleSA9IGtleXNbaV07XFxuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XFxuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NvcnJlY3RQcm90b3R5cGVHZXR0ZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cXG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZUl0ZXJSZXN1bHRPYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwiLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaXRlcnJlc3VsdG9iamVjdFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBkb25lKSB7XFxuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XFxufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XFxuICByZXR1cm4gb2JqZWN0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0NyZWF0ZVByb3BlcnR5RGVzY3JpcHRvckpzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XFxuICByZXR1cm4ge1xcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxcbiAgICB2YWx1ZTogdmFsdWVcXG4gIH07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzQ3JlYXRlUHJvcGVydHlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcXG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XFxuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRGVmaW5lQnVpbHRJbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBtYWtlQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XFxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcXG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XFxuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XFxuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcXG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XFxuICB9IGVsc2Uge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XFxuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XFxuICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxcbiAgICB9KTtcXG4gIH0gcmV0dXJuIE87XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZWZpbmVCdWlsdEluc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XFxuICByZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0RlZmluZUdsb2JhbFByb3BlcnR5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgdHJ5IHtcXG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcXG4gIH0gcmV0dXJuIHZhbHVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEZXNjcmlwdG9yc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxuXFxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEb2N1bWVudEFsbEpzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJ2YXIgZG9jdW1lbnRBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xcblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3RcXG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkO1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgYWxsOiBkb2N1bWVudEFsbCxcXG4gIElTX0hUTUxEREE6IElTX0hUTUxEREFcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNEb2N1bWVudENyZWF0ZUVsZW1lbnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcXG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVVzZXJBZ2VudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0VuZ2luZVY4VmVyc2lvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanNcXFwiKTtcXG5cXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XFxudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xcbnZhciBtYXRjaCwgdmVyc2lvbjtcXG5cXG5pZiAodjgpIHtcXG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcXG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXFxuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xcbn1cXG5cXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XFxuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcXFwvKFxcXFxkKykvKTtcXG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcXG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcXFwvKFxcXFxkKykvKTtcXG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFbnVtQnVnS2V5c0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcXG5tb2R1bGUuZXhwb3J0cyA9IFtcXG4gICdjb25zdHJ1Y3RvcicsXFxuICAnaGFzT3duUHJvcGVydHknLFxcbiAgJ2lzUHJvdG90eXBlT2YnLFxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcXG4gICd0b0xvY2FsZVN0cmluZycsXFxuICAndG9TdHJpbmcnLFxcbiAgJ3ZhbHVlT2YnXFxuXTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNFeHBvcnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCIpLmY7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzXFxcIik7XFxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qc1xcXCIpO1xcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1xcXCIpO1xcblxcbi8qXFxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcXG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXFxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcXG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXFxuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcXG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XFxuKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcXG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcXG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcXG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XFxuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xcbiAgaWYgKEdMT0JBTCkge1xcbiAgICB0YXJnZXQgPSBnbG9iYWw7XFxuICB9IGVsc2UgaWYgKFNUQVRJQykge1xcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcXG4gIH0gZWxzZSB7XFxuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xcbiAgfVxcbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XFxuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XFxuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XFxuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XFxuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XFxuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xcbiAgICB9XFxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XFxuICAgIH1cXG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0ZhaWxzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAhIWV4ZWMoKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRnJlZXppbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmRDb250ZXh0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBOQVRJVkVfQklORCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanNcXFwiKTtcXG5cXG52YXIgYmluZCA9IHVuY3VycnlUaGlzKHVuY3VycnlUaGlzLmJpbmQpO1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XFxuICBhQ2FsbGFibGUoZm4pO1xcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xcbiAgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkJpbmROYXRpdmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXFxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNGdW5jdGlvbkNhbGxKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qc1xcXCIpO1xcblxcbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzRnVuY3Rpb25OYW1lSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanNcXFwiKTtcXG5cXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG5cXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIEVYSVNUUzogRVhJU1RTLFxcbiAgUFJPUEVSOiBQUk9QRVIsXFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLXJhdy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNSYXdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qc1xcXCIpO1xcblxcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcXG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XFxudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCAmJiBGdW5jdGlvblByb3RvdHlwZS5iaW5kLmJpbmQoY2FsbCwgY2FsbCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xcbiAgfTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtcmF3LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0Z1bmN0aW9uVW5jdXJyeVRoaXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxudmFyIHVuY3VycnlUaGlzUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1yYXcuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xcbiAgLy8gTmFzaG9ybiBidWc6XFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTI4XFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpc1Jhdyhmbik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0dldEJ1aWx0SW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcblxcbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2V0SXRlcmF0b3JNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1xcXCIpO1xcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qc1xcXCIpO1xcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaXQpKSByZXR1cm4gZ2V0TWV0aG9kKGl0LCBJVEVSQVRPUilcXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXFxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRJdGVyYXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanNcXFwiKTtcXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xcXCIpO1xcblxcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XFxuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XFxuICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGNhbGwoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XFxuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNHZXRNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1xcXCIpO1xcblxcbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xcbiAgdmFyIGZ1bmMgPSBWW1BdO1xcbiAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzR2xvYmFsSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XFxufTtcXG5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxcbm1vZHVsZS5leHBvcnRzID1cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIikpKVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0hhc093blByb3BlcnR5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcXG5cXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XFxuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIaWRkZW5LZXlzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNIdG1sSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0llOERvbURlZmluZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1xcXCIpO1xcblxcbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XFxuICB9KS5hICE9IDc7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5kZXhlZE9iamVjdEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xcblxcbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXFxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcXG4gIHJldHVybiAhJE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xcbn0pID8gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XFxufSA6ICRPYmplY3Q7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbmhlcml0SWZSZXF1aXJlZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxuXFxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xcbiAgaWYgKFxcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xcbiAgICBpc0NhbGxhYmxlKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcXG4gIHJldHVybiAkdGhpcztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSW5zcGVjdFNvdXJjZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG5cXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcXG5cXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXFxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XFxuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcXG4gIH07XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbE1ldGFkYXRhSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKS5mO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzXFxcIik7XFxudmFyIGlzRXh0ZW5zaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxudmFyIEZSRUVaSU5HID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZyZWV6aW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qc1xcXCIpO1xcblxcbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xcbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xcbnZhciBpZCA9IDA7XFxuXFxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XFxuICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHtcXG4gICAgb2JqZWN0SUQ6ICdPJyArIGlkKyssIC8vIG9iamVjdCBJRFxcbiAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcXG4gIH0gfSk7XFxufTtcXG5cXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XFxuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XFxuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXFxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxcbiAgICBzZXRNZXRhZGF0YShpdCk7XFxuICAvLyByZXR1cm4gb2JqZWN0IElEXFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XFxufTtcXG5cXG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxcbiAgICBzZXRNZXRhZGF0YShpdCk7XFxuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XFxufTtcXG5cXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXNPd24oaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxudmFyIGVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcbiAgUkVRVUlSRUQgPSB0cnVlO1xcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7XFxuICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMoW10uc3BsaWNlKTtcXG4gIHZhciB0ZXN0ID0ge307XFxuICB0ZXN0W01FVEFEQVRBXSA9IDE7XFxuXFxuICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxcbiAgaWYgKGdldE93blByb3BlcnR5TmFtZXModGVzdCkubGVuZ3RoKSB7XFxuICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAocmVzdWx0W2ldID09PSBNRVRBREFUQSkge1xcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSByZXR1cm4gcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcXG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUuZlxcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XFxuICBlbmFibGU6IGVuYWJsZSxcXG4gIGZhc3RLZXk6IGZhc3RLZXksXFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXFxuICBvbkZyZWV6ZTogb25GcmVlemVcXG59O1xcblxcbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJbnRlcm5hbFN0YXRlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24uanNcXFwiKTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcXFwiKTtcXG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcXFwiKTtcXG5cXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XFxudmFyIHNldCwgZ2V0LCBoYXM7XFxuXFxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xcbn07XFxuXFxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHZhciBzdGF0ZTtcXG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcXG4gICAgfSByZXR1cm4gc3RhdGU7XFxuICB9O1xcbn07XFxuXFxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcXG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXFxuICBzdG9yZS5nZXQgPSBzdG9yZS5nZXQ7XFxuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XFxuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcXG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XFxuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xcbiAgICBzdG9yZS5zZXQoaXQsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XFxuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XFxuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XFxuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcXG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XFxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBzZXQ6IHNldCxcXG4gIGdldDogZ2V0LFxcbiAgaGFzOiBoYXMsXFxuICBlbmZvcmNlOiBlbmZvcmNlLFxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3JcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0FycmF5SXRlcmF0b3JNZXRob2RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXFxcIik7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQXJyYXlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxuXFxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xcbiAgcmV0dXJuIGNsYXNzb2YoYXJndW1lbnQpID09ICdBcnJheSc7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0NhbGxhYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkZG9jdW1lbnRBbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1hbGwuanNcXFwiKTtcXG5cXG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xcblxcbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcXG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQgPT09IGRvY3VtZW50QWxsO1xcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzQ29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiKTtcXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qc1xcXCIpO1xcblxcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcbnZhciBlbXB0eSA9IFtdO1xcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxcXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxcXGIvO1xcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XFxudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcXG5cXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcXG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcXG4gIHRyeSB7XFxuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59O1xcblxcbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcXG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXFxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxufTtcXG5cXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xcblxcbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcXG5tb2R1bGUuZXhwb3J0cyA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgdmFyIGNhbGxlZDtcXG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXFxuICAgIHx8IGNhbGxlZDtcXG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc0ZvcmNlZEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxuXFxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFxcXC5wcm90b3R5cGVcXFxcLi87XFxuXFxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXFxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxcbiAgICA6ICEhZGV0ZWN0aW9uO1xcbn07XFxuXFxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcXG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcXG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0lzTnVsbE9yVW5kZWZpbmVkSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2VcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90LWFlY1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc09iamVjdEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1jYWxsYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanNcXFwiKTtcXG52YXIgJGRvY3VtZW50QWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzXFxcIik7XFxuXFxudmFyIGRvY3VtZW50QWxsID0gJGRvY3VtZW50QWxsLmFsbDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KSB8fCBpdCA9PT0gZG9jdW1lbnRBbGw7XFxufSA6IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1B1cmVKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJc1N5bWJvbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcXG59IDogZnVuY3Rpb24gKGl0KSB7XFxuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qc1xcXCIpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzXFxcIik7XFxudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qc1xcXCIpO1xcbnZhciBnZXRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXFxcIik7XFxudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcXG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XFxuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcXG59O1xcblxcbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcXG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XFxuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcXG4gIHZhciBJU19SRUNPUkQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfUkVDT1JEKTtcXG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XFxuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xcbiAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcXG5cXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xcbiAgfTtcXG5cXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcXG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XFxuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XFxuICAgIH0gcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xcbiAgfTtcXG5cXG4gIGlmIChJU19SRUNPUkQpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZS5pdGVyYXRvcjtcXG4gIH0gZWxzZSBpZiAoSVNfSVRFUkFUT1IpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcXG4gIH0gZWxzZSB7XFxuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcXG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcXG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XFxuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcXG4gICAgfVxcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xcbiAgfVxcblxcbiAgbmV4dCA9IElTX1JFQ09SRCA/IGl0ZXJhYmxlLm5leHQgOiBpdGVyYXRvci5uZXh0O1xcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xcbiAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XFxuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JDbG9zZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtbWV0aG9kLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XFxuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XFxuICBhbk9iamVjdChpdGVyYXRvcik7XFxuICB0cnkge1xcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XFxuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcbiAgICBpbm5lclJlc3VsdCA9IGNhbGwoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xcbiAgfVxcbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xcbiAgcmV0dXJuIHZhbHVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdG9yQ3JlYXRlQ29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzXFxcIikuSXRlcmF0b3JQcm90b3R5cGU7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcXG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcXG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XFxuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3RvcjtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzSXRlcmF0b3JEZWZpbmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXFxcIik7XFxudmFyIEZ1bmN0aW9uTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1uYW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3IuanNcXFwiKTtcXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1xcXCIpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiKTtcXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcXFwiKTtcXG5cXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxudmFyIEtFWVMgPSAna2V5cyc7XFxudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcXG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XFxuXFxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcXG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xcbiAgICBzd2l0Y2ggKEtJTkQpIHtcXG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcXG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xcbiAgfTtcXG5cXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXFxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcXG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XFxuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XFxuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XFxuXFxuICAvLyBmaXggbmF0aXZlXFxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcXG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XFxuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XFxuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XFxuICAgICAgICAgIGRlZmluZUJ1aWx0SW4oQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXFxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XFxuICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XFxuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbChuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcXG4gIGlmIChERUZBVUxUKSB7XFxuICAgIG1ldGhvZHMgPSB7XFxuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXFxuICAgIH07XFxuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcXG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XFxuICAgICAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XFxuICB9XFxuXFxuICAvLyBkZWZpbmUgaXRlcmF0b3JcXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xcbiAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XFxuICB9XFxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XFxuXFxuICByZXR1cm4gbWV0aG9kcztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNJdGVyYXRvcnNDb3JlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1xcXCIpO1xcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xcblxcbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XFxuXFxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xcbmlmIChbXS5rZXlzKSB7XFxuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xcbiAgZWxzZSB7XFxuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcXG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxufVxcblxcbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gIWlzT2JqZWN0KEl0ZXJhdG9yUHJvdG90eXBlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICB2YXIgdGVzdCA9IHt9O1xcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXFxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwodGVzdCkgIT09IHRlc3Q7XFxufSk7XFxuXFxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XFxuZWxzZSBpZiAoSVNfUFVSRSkgSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xcblxcbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXFxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcXG4gIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc0l0ZXJhdG9yc0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNMZW5ndGhPZkFycmF5TGlrZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcXFwiKTtcXG5cXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzTWFrZUJ1aWx0SW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qc1xcXCIpLkNPTkZJR1VSQUJMRTtcXG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG5cXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuXFxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xcbn0pO1xcblxcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcXG5cXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XFxuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcXFwoKFteKV0qKVxcXFwpLywgJyQxJykgKyAnXSc7XFxuICB9XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XFxuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcXG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XFxuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XFxuICB9XFxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcXG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XFxuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcXG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcXG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XFxuICB9IHJldHVybiB2YWx1ZTtcXG59O1xcblxcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xcbn0sICd0b1N0cmluZycpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNNYXRoVHJ1bmNKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxcbm1vZHVsZS5leHBvcnRzID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XFxuICB2YXIgbiA9ICt4O1xcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0QXNzaWduSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXFxcIik7XFxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcXG5cXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXFxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxcbiAgaWYgKERFU0NSSVBUT1JTICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcXG4gICAgICAgIHZhbHVlOiAzLFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XFxuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcXG4gIHZhciBBID0ge307XFxuICB2YXIgQiA9IHt9O1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN5bWJvbCAtLSBzYWZlXFxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XFxuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xcbiAgQVtzeW1ib2xdID0gNztcXG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcXG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XFxufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XFxuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBpbmRleCA9IDE7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XFxuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XFxuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcXG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xcbiAgICB2YXIgaiA9IDA7XFxuICAgIHZhciBrZXk7XFxuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XFxuICAgICAga2V5ID0ga2V5c1tqKytdO1xcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZSwgUywga2V5KSkgVFtrZXldID0gU1trZXldO1xcbiAgICB9XFxuICB9IHJldHVybiBUO1xcbn0gOiAkYXNzaWduO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RDcmVhdGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaHRtbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qc1xcXCIpO1xcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxuXFxudmFyIEdUID0gJz4nO1xcbnZhciBMVCA9ICc8JztcXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG5cXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcXG5cXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XFxufTtcXG5cXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XFxuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcXG4gIHJldHVybiB0ZW1wO1xcbn07XFxuXFxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XFxuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XFxuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XFxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcXG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XFxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XFxufTtcXG5cXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XFxuLy8gYXZvaWQgSUUgR0MgYnVnXFxudmFyIGFjdGl2ZVhEb2N1bWVudDtcXG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgdHJ5IHtcXG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxcbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXFxuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcXG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xcbn07XFxuXFxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xcblxcbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKE8gIT09IG51bGwpIHtcXG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XFxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XFxuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XFxuICAgIC8vIGFkZCBcXFwiX19wcm90b19fXFxcIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0RGVmaW5lUHJvcGVydGllc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcXFwiKTtcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcXG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIga2V5O1xcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xcbiAgcmV0dXJuIE87XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3REZWZpbmVQcm9wZXJ0eUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1xcXCIpO1xcblxcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcXG52YXIgQ09ORklHVVJBQkxFID0gJ2NvbmZpZ3VyYWJsZSc7XFxudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XFxuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XFxuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcXG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gICAgICBBdHRyaWJ1dGVzID0ge1xcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XFxuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XFxuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanNcXFwiKTtcXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XFxuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XFxuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XFxuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCIvKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXFxcIikuZjtcXG52YXIgYXJyYXlTbGljZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qc1xcXCIpO1xcblxcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXFxuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcXG5cXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XFxuICB9IGNhdGNoIChlcnJvcikge1xcbiAgICByZXR1cm4gYXJyYXlTbGljZSh3aW5kb3dOYW1lcyk7XFxuICB9XFxufTtcXG5cXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XFxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcXG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mKGl0KSA9PSAnV2luZG93J1xcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxcbiAgICA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcXG5cXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzSnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0R2V0UHJvdG90eXBlT2ZKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1xcXCIpO1xcblxcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG52YXIgJE9iamVjdCA9IE9iamVjdDtcXG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xcbiAgaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XFxuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XFxuICBpZiAoaXNDYWxsYWJsZShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0SXNFeHRlbnNpYmxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiKTtcXG52YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlLmpzXFxcIik7XFxuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pc2V4dGVuc2libGUgLS0gc2FmZVxcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGlzRXh0ZW5zaWJsZSgxKTsgfSk7XFxuXFxuLy8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxcbm1vZHVsZS5leHBvcnRzID0gKEZBSUxTX09OX1BSSU1JVElWRVMgfHwgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFKSA/IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcXG4gIGlmIChBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgJiYgY2xhc3NvZihpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWU7XFxufSA6ICRpc0V4dGVuc2libGU7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RJc1Byb3RvdHlwZU9mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoe30uaXNQcm90b3R5cGVPZik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RLZXlzSW50ZXJuYWxKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzXFxcIik7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcXFwiKS5pbmRleE9mO1xcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1xcXCIpO1xcblxcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcXG4gIHZhciBpID0gMDtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIHZhciBrZXk7XFxuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XFxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXFxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093bihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT2JqZWN0S2V5c0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNPYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gTmFzaG9ybiB+IEpESzggYnVnXFxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XFxuXFxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XFxuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcXG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFNldFByb3RvdHlwZU9mSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXFxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XFxuICB2YXIgdGVzdCA9IHt9O1xcbiAgdmFyIHNldHRlcjtcXG4gIHRyeSB7XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcXG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcXG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcXG4gICAgYW5PYmplY3QoTyk7XFxuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XFxuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcXG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xcbiAgICByZXR1cm4gTztcXG4gIH07XFxufSgpIDogdW5kZWZpbmVkKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc09iamVjdFRvU3RyaW5nSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1xcXCIpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiKTtcXG5cXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3JkaW5hcnlUb1ByaW1pdGl2ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XFxuICB2YXIgZm4sIHZhbDtcXG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcXG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgdGhyb3cgJFR5cGVFcnJvcihcXFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXFxcIik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzT3duS2V5c0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xcXCIpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1xcXCIpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcblxcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xcblxcbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcXG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XFxuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzUGF0aEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzUmVxdWlyZU9iamVjdENvZXJjaWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XFxuXFxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyAkVHlwZUVycm9yKFxcXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcXFwiICsgaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NldFNwZWNpZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxuXFxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XFxuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcXG5cXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcXG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2V0VG9TdHJpbmdUYWdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKS5mO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcXG4gIH1cXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkS2V5SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxuXFxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1NoYXJlZFN0b3JlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qc1xcXCIpO1xcblxcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcXG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU2hhcmVkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXB1cmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcXFwiKTtcXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcXFwiKTtcXG5cXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XFxufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xcbiAgdmVyc2lvbjogJzMuMjYuMCcsXFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuMjYuMC9MSUNFTlNFJyxcXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1N0cmluZ011bHRpYnl0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanNcXFwiKTtcXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzXFxcIik7XFxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXFxcIik7XFxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcXFwiKTtcXG5cXG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcXG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcXG5cXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcXG4gICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XFxuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcXG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcXG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XFxuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XFxuICAgIGZpcnN0ID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbik7XFxuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcXG4gICAgICAgICAgPyBjaGFyQXQoUywgcG9zaXRpb24pXFxuICAgICAgICAgIDogZmlyc3RcXG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcXG4gICAgICAgICAgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XFxuICB9O1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcXG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcXG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzU3ltYm9sQ29uc3RydWN0b3JEZXRlY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcXG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXFxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXFxuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXFxuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvQWJzb2x1dGVJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzXFxcIik7XFxuXFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcXG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXFxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XFxuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUb0luZGV4ZWRPYmplY3RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvSW50ZWdlck9ySW5maW5pdHlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRydW5jID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL21hdGgtdHJ1bmMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanNcXFwiKTtcXG5cXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9MZW5ndGhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qc1xcXCIpO1xcblxcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvT2JqZWN0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXFxcIik7XFxuXFxudmFyICRPYmplY3QgPSBPYmplY3Q7XFxuXFxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiAkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9QcmltaXRpdmVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qc1xcXCIpO1xcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xcblxcbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XFxuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcXG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcXG4gICAgdGhyb3cgJFR5cGVFcnJvcihcXFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXFxcIik7XFxuICB9XFxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XFxuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvUHJvcGVydHlLZXlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXFxcIik7XFxuXFxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcXG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1RvU3RyaW5nVGFnU3VwcG9ydEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbnZhciB0ZXN0ID0ge307XFxuXFxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVG9TdHJpbmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwidmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1xcXCIpO1xcblxcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XFxuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNJbnRlcm5hbHNUcnlUb1N0cmluZ0pzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIGV2YWwoXCJ2YXIgJFN0cmluZyA9IFN0cmluZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuICdPYmplY3QnO1xcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVWlkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcblxcbnZhciBpZCA9IDA7XFxudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzSW50ZXJuYWxzVXNlU3ltYm9sQXNVaWRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxcbiAgJiYgIVN5bWJvbC5zaGFtXFxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1Y4UHJvdG90eXBlRGVmaW5lQnVnSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxuXFxuLy8gVjggfiBDaHJvbWUgMzYtXFxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XFxuICAgIHZhbHVlOiA0MixcXG4gICAgd3JpdGFibGU6IGZhbHNlXFxuICB9KS5wcm90b3R5cGUgIT0gNDI7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlYWtNYXBCYXNpY0RldGVjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzXFxcIik7XFxuXFxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc0ludGVybmFsc1dlbGxLbm93blN5bWJvbEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1xcXCIpO1xcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcXFwiKTtcXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzXFxcIik7XFxudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1xcXCIpO1xcblxcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wgJiYgU3ltYm9sWydmb3InXTtcXG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XFxuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XFxuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpKSB7XFxuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcXG4gICAgfVxcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzQXJyYXlGcm9tSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcInZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGZyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qc1xcXCIpO1xcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanNcXFwiKTtcXG5cXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XFxufSk7XFxuXFxuLy8gYEFycmF5LmZyb21gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XFxuICBmcm9tOiBmcm9tXFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc0FycmF5SXRlcmF0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIikuZjtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanNcXFwiKTtcXG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG5cXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXFxuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXFxuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3JcXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXFxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XFxuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcXG4gIH0pO1xcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxcbn0sIGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XFxuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcXG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcXG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xcbiAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xcbiAgfVxcbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChpbmRleCwgZmFsc2UpO1xcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHRhcmdldFtpbmRleF0sIGZhbHNlKTtcXG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGZhbHNlKTtcXG59LCAndmFsdWVzJyk7XFxuXFxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XFxuXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XFxuXFxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xcbmlmICghSVNfUFVSRSAmJiBERVNDUklQVE9SUyAmJiB2YWx1ZXMubmFtZSAhPT0gJ3ZhbHVlcycpIHRyeSB7XFxuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XFxufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5jb25zdHJ1Y3Rvci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc01hcENvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGNvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qc1xcXCIpO1xcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qc1xcXCIpO1xcblxcbi8vIGBNYXBgIGNvbnN0cnVjdG9yXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xcbmNvbGxlY3Rpb24oJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcXG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzTWFwSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3IuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0NvcmVKc01vZHVsZXNFc09iamVjdEFzc2lnbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1xcXCIpO1xcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xcbiAgYXNzaWduOiBhc3NpZ25cXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNPYmplY3RUb1N0cmluZ0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXFxcIik7XFxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanNcXFwiKTtcXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qc1xcXCIpO1xcblxcbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xcbiAgZGVmaW5lQnVpbHRJbihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmNvbnN0cnVjdG9yLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3IuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzU2V0Q29uc3RydWN0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG52YXIgY29sbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb2xsZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzXFxcIik7XFxudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nLmpzXFxcIik7XFxuXFxuLy8gYFNldGAgY29uc3RydWN0b3JcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXFxuY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcXG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmNvbnN0cnVjdG9yLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTZXRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLy8gVE9ETzogUmVtb3ZlIHRoaXMgbW9kdWxlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyByZXBsYWNlZCB0byBtb2R1bGUgYmVsb3dcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNTdHJpbmdJdGVyYXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIlxcbnZhciBjaGFyQXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xcXCIpLmNoYXJBdDtcXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanNcXFwiKTtcXG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xcblxcbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcXG4gICAgc3RyaW5nOiB0b1N0cmluZyhpdGVyYXRlZCksXFxuICAgIGluZGV4OiAwXFxuICB9KTtcXG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XFxuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcXG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xcbiAgdmFyIHBvaW50O1xcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XFxuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcXG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcXG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHBvaW50LCBmYWxzZSk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ29yZUpzTW9kdWxlc0VzV2Vha01hcENvbnN0cnVjdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qc1xcXCIpO1xcbnZhciBkZWZpbmVCdWlsdElucyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzXFxcIik7XFxudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzXFxcIik7XFxudmFyIGNvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29sbGVjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qc1xcXCIpO1xcbnZhciBjb2xsZWN0aW9uV2VhayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBpc0V4dGVuc2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzXFxcIik7XFxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpLmVuZm9yY2U7XFxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qc1xcXCIpO1xcblxcbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XFxudmFyIEludGVybmFsV2Vha01hcDtcXG5cXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChpbml0KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcXG4gICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XFxuICB9O1xcbn07XFxuXFxuLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXFxudmFyICRXZWFrTWFwID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrKTtcXG5cXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XFxuLy8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxcbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xcbiAgSW50ZXJuYWxXZWFrTWFwID0gY29sbGVjdGlvbldlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgJ1dlYWtNYXAnLCB0cnVlKTtcXG4gIEludGVybmFsTWV0YWRhdGFNb2R1bGUuZW5hYmxlKCk7XFxuICB2YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcXG4gIHZhciBuYXRpdmVEZWxldGUgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXSk7XFxuICB2YXIgbmF0aXZlSGFzID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5oYXMpO1xcbiAgdmFyIG5hdGl2ZUdldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcXG4gIHZhciBuYXRpdmVTZXQgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLnNldCk7XFxuICBkZWZpbmVCdWlsdElucyhXZWFrTWFwUHJvdG90eXBlLCB7XFxuICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XFxuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcXG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XFxuICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpO1xcbiAgICB9LFxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcXG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcXG4gICAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XFxuICAgICAgfSByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSk7XFxuICAgIH0sXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XFxuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlR2V0KHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XFxuICAgICAgfSByZXR1cm4gbmF0aXZlR2V0KHRoaXMsIGtleSk7XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcXG4gICAgICAgIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcXG4gICAgICB9IGVsc2UgbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5jb25zdHJ1Y3Rvci5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNDb3JlSnNNb2R1bGVzRXNXZWFrTWFwSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgZXZhbChcIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgcmVwbGFjZWQgdG8gbW9kdWxlIGJlbG93XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9lcy53ZWFrLW1hcC5jb25zdHJ1Y3RvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwLmNvbnN0cnVjdG9yLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNMb2Rhc2hDbGFtcEluZGV4SnMobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXZhbChcIi8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXFxudmFyIE5BTiA9IDAgLyAwO1xcblxcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XFxuXFxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cXG52YXIgcmVUcmltID0gL15cXFxccyt8XFxcXHMrJC9nO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXFxudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XFxuXFxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XFxuXFxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLyoqXFxuICogVXNlZCB0byByZXNvbHZlIHRoZVxcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxcbiAqIG9mIHZhbHVlcy5cXG4gKi9cXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcXG5cXG4vKipcXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXFxuICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXFxuICovXFxuZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XFxuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcXG4gICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcXG4gICAgfVxcbiAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbnVtYmVyO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXFxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdExpa2Uoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UobnVsbCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XFxufVxcblxcbi8qKlxcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLnRvTnVtYmVyKDMuMik7XFxuICogLy8gPT4gMy4yXFxuICpcXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xcbiAqIC8vID0+IDVlLTMyNFxcbiAqXFxuICogXy50b051bWJlcihJbmZpbml0eSk7XFxuICogLy8gPT4gSW5maW5pdHlcXG4gKlxcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xcbiAqIC8vID0+IDMuMlxcbiAqL1xcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcXG4gIH1cXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XFxuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXFxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xcbn1cXG5cXG4vKipcXG4gKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xcbiAqIC8vID0+IC01XFxuICpcXG4gKiBfLmNsYW1wKDEwLCAtNSwgNSk7XFxuICogLy8gPT4gNVxcbiAqL1xcbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XFxuICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xcbiAgICB1cHBlciA9IGxvd2VyO1xcbiAgICBsb3dlciA9IHVuZGVmaW5lZDtcXG4gIH1cXG4gIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xcbiAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcXG4gIH1cXG4gIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xcbiAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcXG4gIH1cXG4gIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsYW1wL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0xvZGFzaERlYm91bmNlSW5kZXhKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFxcXCJGdW5jdGlvbnNcXFwiIG1ldGhvZHMuICovXFxudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcXG5cXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cXG52YXIgTkFOID0gMCAvIDA7XFxuXFxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcXG5cXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xcbnZhciByZVRyaW0gPSAvXlxcXFxzK3xcXFxccyskL2c7XFxuXFxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcXG5cXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcXG5cXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xcbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcXG5cXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcXG5cXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xcblxcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xcbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xcblxcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcXG4gKiBvZiB2YWx1ZXMuXFxuICovXFxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XFxuXFxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xcbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXFxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgMi40LjBcXG4gKiBAY2F0ZWdvcnkgRGF0ZVxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcXG4gKiB9LCBfLm5vdygpKTtcXG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxcbiAqL1xcbnZhciBub3cgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiByb290LkRhdGUubm93KCk7XFxufTtcXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXFxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXFxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcXG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxcbiAqIGludm9jYXRpb24uXFxuICpcXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXFxuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXFxuICpcXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXFxuICpcXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXFxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxcbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXFxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XFxuICpcXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XFxuICogICAnbGVhZGluZyc6IHRydWUsXFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxcbiAqIH0pKTtcXG4gKlxcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXFxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XFxuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcXG4gKlxcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXFxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XFxuICovXFxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xcbiAgdmFyIGxhc3RBcmdzLFxcbiAgICAgIGxhc3RUaGlzLFxcbiAgICAgIG1heFdhaXQsXFxuICAgICAgcmVzdWx0LFxcbiAgICAgIHRpbWVySWQsXFxuICAgICAgbGFzdENhbGxUaW1lLFxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXFxuICAgICAgbWF4aW5nID0gZmFsc2UsXFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xcblxcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xcbiAgfVxcbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XFxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcXG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcXG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcXG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xcblxcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XFxuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XFxuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXFxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcXG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcXG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXFxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcXG5cXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XFxuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xcblxcbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXFxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcXG4gICAgdmFyIHRpbWUgPSBub3coKTtcXG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XFxuICAgIH1cXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXFxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xcblxcbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXFxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxcbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcXG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcXG4gICAgfVxcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xcbiAgICB9XFxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcXG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBmbHVzaCgpIHtcXG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XFxuICAgIHZhciB0aW1lID0gbm93KCksXFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xcblxcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcXG4gICAgbGFzdFRoaXMgPSB0aGlzO1xcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xcblxcbiAgICBpZiAoaXNJbnZva2luZykge1xcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xcbiAgICAgIH1cXG4gICAgICBpZiAobWF4aW5nKSB7XFxuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcXG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XFxuICByZXR1cm4gZGVib3VuY2VkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXFxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdExpa2Uoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UobnVsbCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XFxufVxcblxcbi8qKlxcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXFxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLnRvTnVtYmVyKDMuMik7XFxuICogLy8gPT4gMy4yXFxuICpcXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xcbiAqIC8vID0+IDVlLTMyNFxcbiAqXFxuICogXy50b051bWJlcihJbmZpbml0eSk7XFxuICogLy8gPT4gSW5maW5pdHlcXG4gKlxcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xcbiAqIC8vID0+IDMuMlxcbiAqL1xcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcXG4gIH1cXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcXG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XFxuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXFxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcXFwiKSkpXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvYm9vbGVhbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGJvb2xlYW4gKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0Jvb2xlYW5Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYm9vbGVhblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYm9vbGVhbjsgfSk7XFxuZnVuY3Rpb24gYm9vbGVhbihwcm90bywga2V5KSB7XFxuICAgIHZhciBhbGlhcyA9IFxcXCJfXFxcIiArIGtleTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2FsaWFzXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgYWxpYXMsIHtcXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEhdmFsLFxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVib3VuY2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0RlYm91bmNlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlYm91bmNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWJvdW5jZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmRlYm91bmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcblxcblxcbmZ1bmN0aW9uIGRlYm91bmNlKCkge1xcbiAgICB2YXIgb3B0aW9ucyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgb3B0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAoX3Byb3RvLCBrZXksIGRlc2NyaXB0b3IpIHtcXG4gICAgICAgIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb2Rhc2hfZGVib3VuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0LmEuYXBwbHkodm9pZCAwLCBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19zcHJlYWRBcnJheXNcXFwiXSkoW2ZuXSwgb3B0aW9ucykpLFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfTtcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9kZWJvdW5jZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiByYW5nZSwgYm9vbGVhbiwgZGVib3VuY2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmFuZ2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9yYW5nZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmFuZ2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyYW5nZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jvb2xlYW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYm9vbGVhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2Jvb2xlYW4uanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJvb2xlYW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ib29sZWFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImJvb2xlYW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWJvdW5jZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL2RlYm91bmNlLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWJvdW5jZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlYm91bmNlXFxcIl07IH0pO1xcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9kZWNvcmF0b3JzL3JhbmdlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogcmFuZ2UgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRGVjb3JhdG9yc1JhbmdlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJhbmdlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByYW5nZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcbmZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4KSB7XFxuICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAtSW5maW5pdHk7IH1cXG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG8sIGtleSkge1xcbiAgICAgICAgdmFyIGFsaWFzID0gXFxcIl9cXFwiICsga2V5O1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIHtcXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbYWxpYXNdO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBhbGlhcywge1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh2YWwsIG1pbiwgbWF4KSxcXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB9KTtcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9yYW5nZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGtleWJvYXJkSGFuZGxlciwgbW91c2VIYW5kbGVyLCByZXNpemVIYW5kbGVyLCBzZWxlY3RIYW5kbGVyLCB0b3VjaEhhbmRsZXIsIHdoZWVsSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNJbmRleEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleWJvYXJkICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9rZXlib2FyZC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW91c2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW91c2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL21vdXNlLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb3VzZUhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb3VzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJtb3VzZUhhbmRsZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVzaXplICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9yZXNpemUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlc2l6ZUhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwicmVzaXplSGFuZGxlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZWxlY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2VsZWN0SGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZWxlY3RIYW5kbGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG91Y2ggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3RvdWNoLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0b3VjaEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJ0b3VjaEhhbmRsZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93aGVlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93aGVlbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIndoZWVsSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3doZWVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIndoZWVsSGFuZGxlclxcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMva2V5Ym9hcmQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL2tleWJvYXJkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBrZXlib2FyZEhhbmRsZXIgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRXZlbnRzS2V5Ym9hcmRKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwia2V5Ym9hcmRIYW5kbGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBrZXlib2FyZEhhbmRsZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgS0VZX0NPREU7XFxuKGZ1bmN0aW9uIChLRVlfQ09ERSkge1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiVEFCXFxcIl0gPSA5XSA9IFxcXCJUQUJcXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiU1BBQ0VcXFwiXSA9IDMyXSA9IFxcXCJTUEFDRVxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJQQUdFX1VQXFxcIl0gPSAzM10gPSBcXFwiUEFHRV9VUFxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJQQUdFX0RPV05cXFwiXSA9IDM0XSA9IFxcXCJQQUdFX0RPV05cXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiRU5EXFxcIl0gPSAzNV0gPSBcXFwiRU5EXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIkhPTUVcXFwiXSA9IDM2XSA9IFxcXCJIT01FXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIkxFRlRcXFwiXSA9IDM3XSA9IFxcXCJMRUZUXFxcIjtcXG4gICAgS0VZX0NPREVbS0VZX0NPREVbXFxcIlVQXFxcIl0gPSAzOF0gPSBcXFwiVVBcXFwiO1xcbiAgICBLRVlfQ09ERVtLRVlfQ09ERVtcXFwiUklHSFRcXFwiXSA9IDM5XSA9IFxcXCJSSUdIVFxcXCI7XFxuICAgIEtFWV9DT0RFW0tFWV9DT0RFW1xcXCJET1dOXFxcIl0gPSA0MF0gPSBcXFwiRE9XTlxcXCI7XFxufSkoS0VZX0NPREUgfHwgKEtFWV9DT0RFID0ge30pKTtcXG5mdW5jdGlvbiBrZXlib2FyZEhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBhZGRFdmVudCA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImV2ZW50U2NvcGVcXFwiXSkoc2Nyb2xsYmFyKTtcXG4gICAgdmFyIGNvbnRhaW5lciA9IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG4gICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICE9PSBjb250YWluZXIgJiYgIWNvbnRhaW5lci5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0VkaXRhYmxlKGFjdGl2ZUVsZW1lbnQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbHRhID0gZ2V0S2V5RGVsdGEoc2Nyb2xsYmFyLCBldnQua2V5Q29kZSB8fCBldnQud2hpY2gpO1xcbiAgICAgICAgaWYgKCFkZWx0YSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB4ID0gZGVsdGFbMF0sIHkgPSBkZWx0YVsxXTtcXG4gICAgICAgIHNjcm9sbGJhci5hZGRUcmFuc2Zvcm1hYmxlTW9tZW50dW0oeCwgeSwgZXZ0LCBmdW5jdGlvbiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIGlmICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyLmNvbnRhaW5lckVsLmJsdXIoKTtcXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhci5wYXJlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhci5wYXJlbnQuY29udGFpbmVyRWwuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gZ2V0S2V5RGVsdGEoc2Nyb2xsYmFyLCBrZXlDb2RlKSB7XFxuICAgIHZhciBzaXplID0gc2Nyb2xsYmFyLnNpemUsIGxpbWl0ID0gc2Nyb2xsYmFyLmxpbWl0LCBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0O1xcbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuVEFCOlxcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVUYWJLZXkoc2Nyb2xsYmFyKTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuU1BBQ0U6XFxuICAgICAgICAgICAgcmV0dXJuIFswLCAyMDBdO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5QQUdFX1VQOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLXNpemUuY29udGFpbmVyLmhlaWdodCArIDQwXTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuUEFHRV9ET1dOOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgc2l6ZS5jb250YWluZXIuaGVpZ2h0IC0gNDBdO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5FTkQ6XFxuICAgICAgICAgICAgcmV0dXJuIFswLCBsaW1pdC55IC0gb2Zmc2V0LnldO1xcbiAgICAgICAgY2FzZSBLRVlfQ09ERS5IT01FOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLW9mZnNldC55XTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuTEVGVDpcXG4gICAgICAgICAgICByZXR1cm4gWy00MCwgMF07XFxuICAgICAgICBjYXNlIEtFWV9DT0RFLlVQOlxcbiAgICAgICAgICAgIHJldHVybiBbMCwgLTQwXTtcXG4gICAgICAgIGNhc2UgS0VZX0NPREUuUklHSFQ6XFxuICAgICAgICAgICAgcmV0dXJuIFs0MCwgMF07XFxuICAgICAgICBjYXNlIEtFWV9DT0RFLkRPV046XFxuICAgICAgICAgICAgcmV0dXJuIFswLCA0MF07XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxufVxcbmZ1bmN0aW9uIGhhbmRsZVRhYktleShzY3JvbGxiYXIpIHtcXG4gICAgLy8gaGFuZGxlIGluIG5leHQgZnJhbWVcXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNjcm9sbGJhci5zY3JvbGxJbnRvVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50LCB7XFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiBzY3JvbGxiYXIuc2l6ZS5jb250YWluZXIuaGVpZ2h0IC8gMixcXG4gICAgICAgICAgICBvZmZzZXRMZWZ0OiBzY3JvbGxiYXIuc2l6ZS5jb250YWluZXIud2lkdGggLyAyLFxcbiAgICAgICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZSxcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gaXNFZGl0YWJsZShlbGVtKSB7XFxuICAgIGlmIChlbGVtLnRhZ05hbWUgPT09ICdJTlBVVCcgfHxcXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHxcXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fFxcbiAgICAgICAgZWxlbS5pc0NvbnRlbnRFZGl0YWJsZSkge1xcbiAgICAgICAgcmV0dXJuICFlbGVtLmRpc2FibGVkO1xcbiAgICB9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Ym9hcmQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL2tleWJvYXJkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL21vdXNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy9tb3VzZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogbW91c2VIYW5kbGVyICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c01vdXNlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1vdXNlSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW91c2VIYW5kbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcblxcblxcbnZhciBEaXJlY3Rpb247XFxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcXFwiWFxcXCJdID0gMF0gPSBcXFwiWFxcXCI7XFxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXFxcIllcXFwiXSA9IDFdID0gXFxcIllcXFwiO1xcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcXG5mdW5jdGlvbiBtb3VzZUhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBhZGRFdmVudCA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImV2ZW50U2NvcGVcXFwiXSkoc2Nyb2xsYmFyKTtcXG4gICAgdmFyIGNvbnRhaW5lciA9IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgdmFyIF9hID0gc2Nyb2xsYmFyLnRyYWNrLCB4QXhpcyA9IF9hLnhBeGlzLCB5QXhpcyA9IF9hLnlBeGlzO1xcbiAgICBmdW5jdGlvbiBjYWxjTW9tZW50dW0oZGlyZWN0aW9uLCBjbGlja1Bvc2l0aW9uKSB7XFxuICAgICAgICB2YXIgc2l6ZSA9IHNjcm9sbGJhci5zaXplLCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdCwgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldDtcXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5YKSB7XFxuICAgICAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBzaXplLmNvbnRhaW5lci53aWR0aCArICh4QXhpcy50aHVtYi5yZWFsU2l6ZSAtIHhBeGlzLnRodW1iLmRpc3BsYXlTaXplKTtcXG4gICAgICAgICAgICByZXR1cm4gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGNsaWNrUG9zaXRpb24gLyB0b3RhbFdpZHRoICogc2l6ZS5jb250ZW50LndpZHRoLCAwLCBsaW1pdC54KSAtIG9mZnNldC54O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlkpIHtcXG4gICAgICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSBzaXplLmNvbnRhaW5lci5oZWlnaHQgKyAoeUF4aXMudGh1bWIucmVhbFNpemUgLSB5QXhpcy50aHVtYi5kaXNwbGF5U2l6ZSk7XFxuICAgICAgICAgICAgcmV0dXJuIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShjbGlja1Bvc2l0aW9uIC8gdG90YWxIZWlnaHQgKiBzaXplLmNvbnRlbnQuaGVpZ2h0LCAwLCBsaW1pdC55KSAtIG9mZnNldC55O1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gZ2V0VHJhY2tEaXJlY3Rpb24oZWxlbSkge1xcbiAgICAgICAgaWYgKE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzT25lT2ZcXFwiXSkoZWxlbSwgW3hBeGlzLmVsZW1lbnQsIHhBeGlzLnRodW1iLmVsZW1lbnRdKSkge1xcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb24uWDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc09uZU9mXFxcIl0pKGVsZW0sIFt5QXhpcy5lbGVtZW50LCB5QXhpcy50aHVtYi5lbGVtZW50XSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9uLlk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICB9XFxuICAgIHZhciBpc01vdXNlRG93bjtcXG4gICAgdmFyIGlzTW91c2VNb3Zpbmc7XFxuICAgIHZhciBzdGFydE9mZnNldFRvVGh1bWI7XFxuICAgIHZhciB0cmFja0RpcmVjdGlvbjtcXG4gICAgdmFyIGNvbnRhaW5lclJlY3Q7XFxuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKGlzTW91c2VNb3ZpbmcgfHwgIU9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzT25lT2ZcXFwiXSkoZXZ0LnRhcmdldCwgW3hBeGlzLmVsZW1lbnQsIHlBeGlzLmVsZW1lbnRdKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0cmFjayA9IGV2dC50YXJnZXQ7XFxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ2V0VHJhY2tEaXJlY3Rpb24odHJhY2spO1xcbiAgICAgICAgdmFyIHJlY3QgPSB0cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIHZhciBjbGlja1BvcyA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCk7XFxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWCkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXRPblRyYWNrID0gY2xpY2tQb3MueCAtIHJlY3QubGVmdCAtIHhBeGlzLnRodW1iLmRpc3BsYXlTaXplIC8gMjtcXG4gICAgICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0oY2FsY01vbWVudHVtKGRpcmVjdGlvbiwgb2Zmc2V0T25UcmFjayksIDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlkpIHtcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0T25UcmFjayA9IGNsaWNrUG9zLnkgLSByZWN0LnRvcCAtIHlBeGlzLnRodW1iLmRpc3BsYXlTaXplIC8gMjtcXG4gICAgICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0oMCwgY2FsY01vbWVudHVtKGRpcmVjdGlvbiwgb2Zmc2V0T25UcmFjaykpO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKCFPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc09uZU9mXFxcIl0pKGV2dC50YXJnZXQsIFt4QXhpcy50aHVtYi5lbGVtZW50LCB5QXhpcy50aHVtYi5lbGVtZW50XSkpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpc01vdXNlRG93biA9IHRydWU7XFxuICAgICAgICB2YXIgdGh1bWIgPSBldnQudGFyZ2V0O1xcbiAgICAgICAgdmFyIGN1cnNvclBvcyA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCk7XFxuICAgICAgICB2YXIgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgICB0cmFja0RpcmVjdGlvbiA9IGdldFRyYWNrRGlyZWN0aW9uKHRodW1iKTtcXG4gICAgICAgIC8vIHBvaW50ZXIgb2Zmc2V0IHRvIHRodW1iXFxuICAgICAgICBzdGFydE9mZnNldFRvVGh1bWIgPSB7XFxuICAgICAgICAgICAgeDogY3Vyc29yUG9zLnggLSB0aHVtYlJlY3QubGVmdCxcXG4gICAgICAgICAgICB5OiBjdXJzb3JQb3MueSAtIHRodW1iUmVjdC50b3AsXFxuICAgICAgICB9O1xcbiAgICAgICAgLy8gY29udGFpbmVyIGJvdW5kaW5nIHJlY3RhbmdsZVxcbiAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIC8vIHByZXZlbnQgc2VsZWN0aW9uLCBzZWU6XFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWRpb3RXdS9zbW9vdGgtc2Nyb2xsYmFyL2lzc3Vlcy80OFxcbiAgICAgICAgT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2V0U3R5bGVcXFwiXSkoc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCB7XFxuICAgICAgICAgICAgJy11c2VyLXNlbGVjdCc6ICdub25lJyxcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG4gICAgYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgaWYgKCFpc01vdXNlRG93bilcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICBpc01vdXNlTW92aW5nID0gdHJ1ZTtcXG4gICAgICAgIHZhciBjdXJzb3JQb3MgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJnZXRQb3NpdGlvblxcXCJdKShldnQpO1xcbiAgICAgICAgaWYgKHRyYWNrRGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWCkge1xcbiAgICAgICAgICAgIC8vIGdldCBwZXJjZW50YWdlIG9mIHBvaW50ZXIgcG9zaXRpb24gaW4gdHJhY2tcXG4gICAgICAgICAgICAvLyB0aGVuIHRyYW5mb3JtIHRvIHB4XFxuICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCBlYXNpbmdcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0T25UcmFjayA9IGN1cnNvclBvcy54IC0gc3RhcnRPZmZzZXRUb1RodW1iLnggLSBjb250YWluZXJSZWN0LmxlZnQ7XFxuICAgICAgICAgICAgc2Nyb2xsYmFyLnNldE1vbWVudHVtKGNhbGNNb21lbnR1bSh0cmFja0RpcmVjdGlvbiwgb2Zmc2V0T25UcmFjayksIDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRyYWNrRGlyZWN0aW9uID09PSBEaXJlY3Rpb24uWSkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXRPblRyYWNrID0gY3Vyc29yUG9zLnkgLSBzdGFydE9mZnNldFRvVGh1bWIueSAtIGNvbnRhaW5lclJlY3QudG9wO1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5zZXRNb21lbnR1bSgwLCBjYWxjTW9tZW50dW0odHJhY2tEaXJlY3Rpb24sIG9mZnNldE9uVHJhY2spKTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ21vdXNldXAgYmx1cicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlzTW91c2VEb3duID0gaXNNb3VzZU1vdmluZyA9IGZhbHNlO1xcbiAgICAgICAgT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2V0U3R5bGVcXFwiXSkoc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCB7XFxuICAgICAgICAgICAgJy11c2VyLXNlbGVjdCc6ICcnLFxcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3VzZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvbW91c2UuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogcmVzaXplSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNSZXNpemVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVzaXplSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzaXplSGFuZGxlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmRlYm91bmNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2RlYm91bmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiByZXNpemVIYW5kbGVyKHNjcm9sbGJhcikge1xcbiAgICB2YXIgYWRkRXZlbnQgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJldmVudFNjb3BlXFxcIl0pKHNjcm9sbGJhcik7XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIGxvZGFzaF9kZWJvdW5jZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShzY3JvbGxiYXIudXBkYXRlLmJpbmQoc2Nyb2xsYmFyKSwgMzAwKSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvcmVzaXplLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3NlbGVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNlbGVjdEhhbmRsZXIgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyRXZlbnRzU2VsZWN0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNlbGVjdEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGVjdEhhbmRsZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC5jbGFtcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsYW1wL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gc2VsZWN0SGFuZGxlcihzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGFkZEV2ZW50ID0gT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZXZlbnRTY29wZVxcXCJdKShzY3JvbGxiYXIpO1xcbiAgICB2YXIgY29udGFpbmVyRWwgPSBzY3JvbGxiYXIuY29udGFpbmVyRWwsIGNvbnRlbnRFbCA9IHNjcm9sbGJhci5jb250ZW50RWw7XFxuICAgIHZhciBpc1NlbGVjdGVkID0gZmFsc2U7XFxuICAgIHZhciBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7IC8vIGZsYWcgdG8gcHJldmVudCBzZWxlY3Rpb24gd2hlbiBjb250ZXh0IG1lbnUgaXMgb3BlbmVkXFxuICAgIHZhciBhbmltYXRpb25JRDtcXG4gICAgZnVuY3Rpb24gc2Nyb2xsKF9hKSB7XFxuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xcbiAgICAgICAgaWYgKCF4ICYmICF5KVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIHZhciBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0LCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdDtcXG4gICAgICAgIC8vIERJU0FMTE9XIGRlbHRhIHRyYW5zZm9ybWF0aW9uXFxuICAgICAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG9mZnNldC54ICsgeCwgMCwgbGltaXQueCkgLSBvZmZzZXQueCwgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG9mZnNldC55ICsgeSwgMCwgbGltaXQueSkgLSBvZmZzZXQueSk7XFxuICAgICAgICBhbmltYXRpb25JRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc2Nyb2xsKHsgeDogeCwgeTogeSB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGFkZEV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIGlmICghaXNTZWxlY3RlZClcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRCk7XFxuICAgICAgICB2YXIgZGlyID0gY2FsY01vbWVudHVtKHNjcm9sbGJhciwgZXZ0KTtcXG4gICAgICAgIHNjcm9sbChkaXIpO1xcbiAgICB9KTtcXG4gICAgLy8gcHJldmVudCBzY3JvbGxpbmcgd2hlbiBjb250ZXh0IG1lbnUgaXMgb3BlbmVkXFxuICAgIC8vIE5PVEU6IGBjb250ZXh0bWVudWAgZXZlbnQgbWF5IGJlIGZpcmVkXFxuICAgIC8vICAgICAgICAgIDEuIEJFRk9SRSBgc2VsZWN0c3RhcnRgOiB3aGVuIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSB0ZXh0IGNvbnRlbnQgLT4gcHJldmVudCBmdXR1cmUgc2Nyb2xsaW5nLFxcbiAgICAvLyAgICAgICAgICAyLiBBRlRFUiBgc2VsZWN0c3RhcnRgOiB3aGVuIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBibGFuayBhcmVhIC0+IGNhbmNlbCBjdXJyZW50IHNjcm9sbGluZyxcXG4gICAgLy8gICAgICAgIHNvIHdlIG5lZWQgdG8gYm90aCBzZXQgdGhlIGZsYWcgYW5kIGNhbmNlbCBjdXJyZW50IHNjcm9sbGluZ1xcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIHNldCB0aGUgZmxhZyB0byBwcmV2ZW50IGZ1dHVyZSBzY3JvbGxpbmdcXG4gICAgICAgIGlzQ29udGV4dE1lbnVPcGVuZWQgPSB0cnVlO1xcbiAgICAgICAgLy8gc3RvcCBjdXJyZW50IHNjcm9sbGluZ1xcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSUQpO1xcbiAgICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xcbiAgICB9KTtcXG4gICAgLy8gcmVzZXQgY29udGV4dCBtZW51IGZsYWcgb24gbW91c2UgZG93blxcbiAgICAvLyB0byBlbnN1cmUgdGhlIHNjcm9sbGluZyBpcyBhbGxvd2VkIGluIHRoZSBuZXh0IHNlbGVjdGlvblxcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudChjb250ZW50RWwsICdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChpc0NvbnRleHRNZW51T3BlbmVkKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSUQpO1xcbiAgICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudCh3aW5kb3csICdtb3VzZXVwIGJsdXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRCk7XFxuICAgICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XFxuICAgICAgICBpc0NvbnRleHRNZW51T3BlbmVkID0gZmFsc2U7XFxuICAgIH0pO1xcbiAgICAvLyBwYXRjaCBmb3IgdG91Y2ggZGV2aWNlc1xcbiAgICBhZGRFdmVudChjb250YWluZXJFbCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsVG9wID0gY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IDA7XFxuICAgIH0pO1xcbn1cXG5mdW5jdGlvbiBjYWxjTW9tZW50dW0oc2Nyb2xsYmFyLCBldnQpIHtcXG4gICAgdmFyIF9hID0gc2Nyb2xsYmFyLmJvdW5kaW5nLCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbSwgbGVmdCA9IF9hLmxlZnQ7XFxuICAgIHZhciBfYiA9IE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKGV2dCksIHggPSBfYi54LCB5ID0gX2IueTtcXG4gICAgdmFyIHJlcyA9IHtcXG4gICAgICAgIHg6IDAsXFxuICAgICAgICB5OiAwLFxcbiAgICB9O1xcbiAgICB2YXIgcGFkZGluZyA9IDIwO1xcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKVxcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgaWYgKHggPiByaWdodCAtIHBhZGRpbmcpIHtcXG4gICAgICAgIHJlcy54ID0gKHggLSByaWdodCArIHBhZGRpbmcpO1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKHggPCBsZWZ0ICsgcGFkZGluZykge1xcbiAgICAgICAgcmVzLnggPSAoeCAtIGxlZnQgLSBwYWRkaW5nKTtcXG4gICAgfVxcbiAgICBpZiAoeSA+IGJvdHRvbSAtIHBhZGRpbmcpIHtcXG4gICAgICAgIHJlcy55ID0gKHkgLSBib3R0b20gKyBwYWRkaW5nKTtcXG4gICAgfVxcbiAgICBlbHNlIGlmICh5IDwgdG9wICsgcGFkZGluZykge1xcbiAgICAgICAgcmVzLnkgPSAoeSAtIHRvcCAtIHBhZGRpbmcpO1xcbiAgICB9XFxuICAgIHJlcy54ICo9IDI7XFxuICAgIHJlcy55ICo9IDI7XFxuICAgIHJldHVybiByZXM7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvc2VsZWN0LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZXZlbnRzL3RvdWNoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy90b3VjaC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogdG91Y2hIYW5kbGVyICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckV2ZW50c1RvdWNoSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInRvdWNoSGFuZGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG91Y2hIYW5kbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIGFjdGl2ZVNjcm9sbGJhcjtcXG5mdW5jdGlvbiB0b3VjaEhhbmRsZXIoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciB0YXJnZXQgPSBzY3JvbGxiYXIub3B0aW9ucy5kZWxlZ2F0ZVRvIHx8IHNjcm9sbGJhci5jb250YWluZXJFbDtcXG4gICAgdmFyIHRvdWNoUmVjb3JkID0gbmV3IF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiVG91Y2hSZWNvcmRcXFwiXSgpO1xcbiAgICB2YXIgYWRkRXZlbnQgPSBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJldmVudFNjb3BlXFxcIl0pKHNjcm9sbGJhcik7XFxuICAgIHZhciBkYW1waW5nO1xcbiAgICB2YXIgcG9pbnRlckNvdW50ID0gMDtcXG4gICAgYWRkRXZlbnQodGFyZ2V0LCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIC8vIHN0YXJ0IHJlY29yZHNcXG4gICAgICAgIHRvdWNoUmVjb3JkLnRyYWNrKGV2dCk7XFxuICAgICAgICAvLyBzdG9wIHNjcm9sbGluZ1xcbiAgICAgICAgc2Nyb2xsYmFyLnNldE1vbWVudHVtKDAsIDApO1xcbiAgICAgICAgLy8gc2F2ZSBkYW1waW5nXFxuICAgICAgICBpZiAocG9pbnRlckNvdW50ID09PSAwKSB7XFxuICAgICAgICAgICAgZGFtcGluZyA9IHNjcm9sbGJhci5vcHRpb25zLmRhbXBpbmc7XFxuICAgICAgICAgICAgc2Nyb2xsYmFyLm9wdGlvbnMuZGFtcGluZyA9IE1hdGgubWF4KGRhbXBpbmcsIDAuNSk7IC8vIGxlc3MgZnJhbWVzIG9uIHRvdWNobW92ZVxcbiAgICAgICAgfVxcbiAgICAgICAgcG9pbnRlckNvdW50Kys7XFxuICAgIH0pO1xcbiAgICBhZGRFdmVudCh0YXJnZXQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICBpZiAoYWN0aXZlU2Nyb2xsYmFyICYmIGFjdGl2ZVNjcm9sbGJhciAhPT0gc2Nyb2xsYmFyKVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIHRvdWNoUmVjb3JkLnVwZGF0ZShldnQpO1xcbiAgICAgICAgdmFyIF9hID0gdG91Y2hSZWNvcmQuZ2V0RGVsdGEoKSwgeCA9IF9hLngsIHkgPSBfYS55O1xcbiAgICAgICAgc2Nyb2xsYmFyLmFkZFRyYW5zZm9ybWFibGVNb21lbnR1bSh4LCB5LCBldnQsIGZ1bmN0aW9uICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgaWYgKHdpbGxTY3JvbGwgJiYgZXZ0LmNhbmNlbGFibGUpIHtcXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICAgIGFjdGl2ZVNjcm9sbGJhciA9IHNjcm9sbGJhcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxuICAgIGFkZEV2ZW50KHRhcmdldCwgJ3RvdWNoY2FuY2VsIHRvdWNoZW5kJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgdmFyIGRlbHRhID0gdG91Y2hSZWNvcmQuZ2V0RWFzaW5nRGlzdGFuY2UoZGFtcGluZyk7XFxuICAgICAgICBzY3JvbGxiYXIuYWRkVHJhbnNmb3JtYWJsZU1vbWVudHVtKGRlbHRhLngsIGRlbHRhLnksIGV2dCk7XFxuICAgICAgICBwb2ludGVyQ291bnQtLTtcXG4gICAgICAgIC8vIHJlc3RvcmUgZGFtcGluZ1xcbiAgICAgICAgaWYgKHBvaW50ZXJDb3VudCA9PT0gMCkge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5vcHRpb25zLmRhbXBpbmcgPSBkYW1waW5nO1xcbiAgICAgICAgfVxcbiAgICAgICAgdG91Y2hSZWNvcmQucmVsZWFzZShldnQpO1xcbiAgICAgICAgYWN0aXZlU2Nyb2xsYmFyID0gbnVsbDtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvdWNoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy90b3VjaC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy93aGVlbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvd2hlZWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHdoZWVsSGFuZGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJFdmVudHNXaGVlbEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ3aGVlbEhhbmRsZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdoZWVsSGFuZGxlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHdoZWVsSGFuZGxlcihzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGFkZEV2ZW50ID0gT2JqZWN0KF91dGlsc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZXZlbnRTY29wZVxcXCJdKShzY3JvbGxiYXIpO1xcbiAgICB2YXIgdGFyZ2V0ID0gc2Nyb2xsYmFyLm9wdGlvbnMuZGVsZWdhdGVUbyB8fCBzY3JvbGxiYXIuY29udGFpbmVyRWw7XFxuICAgIHZhciBldmVudE5hbWUgPSAoJ29ud2hlZWwnIGluIHdpbmRvdyB8fCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJykpID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJztcXG4gICAgYWRkRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZURlbHRhKGV2dCksIHggPSBfYS54LCB5ID0gX2EueTtcXG4gICAgICAgIHNjcm9sbGJhci5hZGRUcmFuc2Zvcm1hYmxlTW9tZW50dW0oeCwgeSwgZXZ0LCBmdW5jdGlvbiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIGlmICh3aWxsU2Nyb2xsKSB7XFxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuLy8gTm9ybWFsaXppbmcgd2hlZWwgZGVsdGFcXG52YXIgREVMVEFfU0NBTEUgPSB7XFxuICAgIFNUQU5EQVJEOiAxLFxcbiAgICBPVEhFUlM6IC0zLFxcbn07XFxudmFyIERFTFRBX01PREUgPSBbMS4wLCAyOC4wLCA1MDAuMF07XFxudmFyIGdldERlbHRhTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7IHJldHVybiBERUxUQV9NT0RFW21vZGVdIHx8IERFTFRBX01PREVbMF07IH07XFxuZnVuY3Rpb24gbm9ybWFsaXplRGVsdGEoZXZ0KSB7XFxuICAgIGlmICgnZGVsdGFYJyBpbiBldnQpIHtcXG4gICAgICAgIHZhciBtb2RlID0gZ2V0RGVsdGFNb2RlKGV2dC5kZWx0YU1vZGUpO1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB4OiBldnQuZGVsdGFYIC8gREVMVEFfU0NBTEUuU1RBTkRBUkQgKiBtb2RlLFxcbiAgICAgICAgICAgIHk6IGV2dC5kZWx0YVkgLyBERUxUQV9TQ0FMRS5TVEFOREFSRCAqIG1vZGUsXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGV2dCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB4OiBldnQud2hlZWxEZWx0YVggLyBERUxUQV9TQ0FMRS5PVEhFUlMsXFxuICAgICAgICAgICAgeTogZXZ0LndoZWVsRGVsdGFZIC8gREVMVEFfU0NBTEUuT1RIRVJTLFxcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICAvLyBpZSB3aXRoIHRvdWNocGFkXFxuICAgIHJldHVybiB7XFxuICAgICAgICB4OiAwLFxcbiAgICAgICAgeTogZXZ0LndoZWVsRGVsdGEgLyBERUxUQV9TQ0FMRS5PVEhFUlMsXFxuICAgIH07XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdoZWVsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2V2ZW50cy93aGVlbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2dldC1zaXplLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvZ2V0LXNpemUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0U2l6ZSAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJHZW9tZXRyeUdldFNpemVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0U2l6ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U2l6ZTsgfSk7XFxuZnVuY3Rpb24gZ2V0U2l6ZShzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGNvbnRhaW5lckVsID0gc2Nyb2xsYmFyLmNvbnRhaW5lckVsLCBjb250ZW50RWwgPSBzY3JvbGxiYXIuY29udGVudEVsO1xcbiAgICB2YXIgY29udGFpbmVyU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXJFbCk7XFxuICAgIHZhciBwYWRkaW5ncyA9IFtcXG4gICAgICAgICdwYWRkaW5nVG9wJyxcXG4gICAgICAgICdwYWRkaW5nQm90dG9tJyxcXG4gICAgICAgICdwYWRkaW5nTGVmdCcsXFxuICAgICAgICAncGFkZGluZ1JpZ2h0JyxcXG4gICAgXS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgIHJldHVybiBjb250YWluZXJTdHlsZXNbcHJvcF0gPyBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlc1twcm9wXSkgOiAwO1xcbiAgICB9KTtcXG4gICAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IHBhZGRpbmdzWzBdICsgcGFkZGluZ3NbMV07XFxuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdzWzJdICsgcGFkZGluZ3NbM107XFxuICAgIHJldHVybiB7XFxuICAgICAgICBjb250YWluZXI6IHtcXG4gICAgICAgICAgICAvLyByZXF1aXJlcyBgb3ZlcmZsb3c6IGhpZGRlbmBcXG4gICAgICAgICAgICB3aWR0aDogY29udGFpbmVyRWwuY2xpZW50V2lkdGgsXFxuICAgICAgICAgICAgaGVpZ2h0OiBjb250YWluZXJFbC5jbGllbnRIZWlnaHQsXFxuICAgICAgICB9LFxcbiAgICAgICAgY29udGVudDoge1xcbiAgICAgICAgICAgIC8vIGJvcmRlciB3aWR0aCBhbmQgcGFkZGluZ3Mgc2hvdWxkIGJlIGluY2x1ZGVkXFxuICAgICAgICAgICAgd2lkdGg6IGNvbnRlbnRFbC5vZmZzZXRXaWR0aCAtIGNvbnRlbnRFbC5jbGllbnRXaWR0aCArIGNvbnRlbnRFbC5zY3JvbGxXaWR0aCArIGhvcml6b250YWxQYWRkaW5nLFxcbiAgICAgICAgICAgIGhlaWdodDogY29udGVudEVsLm9mZnNldEhlaWdodCAtIGNvbnRlbnRFbC5jbGllbnRIZWlnaHQgKyBjb250ZW50RWwuc2Nyb2xsSGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nLFxcbiAgICAgICAgfSxcXG4gICAgfTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNpemUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvZ2V0LXNpemUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdldFNpemUsIGlzVmlzaWJsZSwgdXBkYXRlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5SW5kZXhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtc2l6ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9nZXQtc2l6ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0U2l6ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2dldF9zaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImdldFNpemVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc192aXNpYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXZpc2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvaXMtdmlzaWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNWaXNpYmxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfaXNfdmlzaWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc1Zpc2libGVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91cGRhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBkYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidXBkYXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXBkYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInVwZGF0ZVxcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2lzLXZpc2libGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L2lzLXZpc2libGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBpc1Zpc2libGUgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyR2VvbWV0cnlJc1Zpc2libGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNWaXNpYmxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1Zpc2libGU7IH0pO1xcbmZ1bmN0aW9uIGlzVmlzaWJsZShzY3JvbGxiYXIsIGVsZW0pIHtcXG4gICAgdmFyIGJvdW5kaW5nID0gc2Nyb2xsYmFyLmJvdW5kaW5nO1xcbiAgICB2YXIgdGFyZ2V0Qm91bmRpbmcgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAvLyBjaGVjayBvdmVybGFwcGluZ1xcbiAgICB2YXIgdG9wID0gTWF0aC5tYXgoYm91bmRpbmcudG9wLCB0YXJnZXRCb3VuZGluZy50b3ApO1xcbiAgICB2YXIgbGVmdCA9IE1hdGgubWF4KGJvdW5kaW5nLmxlZnQsIHRhcmdldEJvdW5kaW5nLmxlZnQpO1xcbiAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbihib3VuZGluZy5yaWdodCwgdGFyZ2V0Qm91bmRpbmcucmlnaHQpO1xcbiAgICB2YXIgYm90dG9tID0gTWF0aC5taW4oYm91bmRpbmcuYm90dG9tLCB0YXJnZXRCb3VuZGluZy5ib3R0b20pO1xcbiAgICByZXR1cm4gdG9wIDwgYm90dG9tICYmIGxlZnQgPCByaWdodDtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdmlzaWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pcy12aXNpYmxlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvdXBkYXRlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2dlb21ldHJ5L3VwZGF0ZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogdXBkYXRlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhckdlb21ldHJ5VXBkYXRlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInVwZGF0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlOyB9KTtcXG5mdW5jdGlvbiB1cGRhdGUoc2Nyb2xsYmFyKSB7XFxuICAgIHZhciBuZXdTaXplID0gc2Nyb2xsYmFyLmdldFNpemUoKTtcXG4gICAgdmFyIGxpbWl0ID0ge1xcbiAgICAgICAgeDogTWF0aC5tYXgobmV3U2l6ZS5jb250ZW50LndpZHRoIC0gbmV3U2l6ZS5jb250YWluZXIud2lkdGgsIDApLFxcbiAgICAgICAgeTogTWF0aC5tYXgobmV3U2l6ZS5jb250ZW50LmhlaWdodCAtIG5ld1NpemUuY29udGFpbmVyLmhlaWdodCwgMCksXFxuICAgIH07XFxuICAgIC8vIG1ldHJpY3NcXG4gICAgdmFyIGNvbnRhaW5lckJvdW5kaW5nID0gc2Nyb2xsYmFyLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICB2YXIgYm91bmRpbmcgPSB7XFxuICAgICAgICB0b3A6IE1hdGgubWF4KGNvbnRhaW5lckJvdW5kaW5nLnRvcCwgMCksXFxuICAgICAgICByaWdodDogTWF0aC5taW4oY29udGFpbmVyQm91bmRpbmcucmlnaHQsIHdpbmRvdy5pbm5lcldpZHRoKSxcXG4gICAgICAgIGJvdHRvbTogTWF0aC5taW4oY29udGFpbmVyQm91bmRpbmcuYm90dG9tLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxcbiAgICAgICAgbGVmdDogTWF0aC5tYXgoY29udGFpbmVyQm91bmRpbmcubGVmdCwgMCksXFxuICAgIH07XFxuICAgIC8vIGFzc2lnbiBwcm9wc1xcbiAgICBzY3JvbGxiYXIuc2l6ZSA9IG5ld1NpemU7XFxuICAgIHNjcm9sbGJhci5saW1pdCA9IGxpbWl0O1xcbiAgICBzY3JvbGxiYXIuYm91bmRpbmcgPSBib3VuZGluZztcXG4gICAgLy8gdXBkYXRlIHRyYWNrc1xcbiAgICBzY3JvbGxiYXIudHJhY2sudXBkYXRlKCk7XFxuICAgIC8vIHJlLXBvc2l0aW9uaW5nXFxuICAgIHNjcm9sbGJhci5zZXRQb3NpdGlvbigpO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZ2VvbWV0cnkvdXBkYXRlLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBTY3JvbGxiYXJQbHVnaW4sIGRlZmF1bHQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFySW5kZXhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb2x5ZmlsbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9seWZpbGxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Njcm9sbGJhciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvcGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxiYXJQbHVnaW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiU2Nyb2xsYmFyUGx1Z2luXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3R5bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc3R5bGUuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBjYXN0IGBJLlNjcm9sbGJhcmAgdG8gYFNjcm9sbGJhcmAgdG8gYXZvaWQgZXJyb3JcXG4gKlxcbiAqIGBJLlNjcm9sbGJhcmAgaXMgbm90IGFzc2lnbmFibGUgdG8gYFNjcm9sbGJhcmA6XFxuICogICAgIFxcXCJwcml2YXRlUHJvcFxcXCIgaXMgbWlzc2luZyBpbiBgSS5TY3JvbGxiYXJgXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjY3MlxcbiAqL1xcbnZhciBTbW9vdGhTY3JvbGxiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2V4dGVuZHNcXFwiXSkoU21vb3RoU2Nyb2xsYmFyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBTbW9vdGhTY3JvbGxiYXIoKSB7XFxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGEgc2Nyb2xsYmFyIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBpbml0aWFsaXplIHNjcm9sbGJhciB0b1xcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIEluaXRpYWwgb3B0aW9uc1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJleHBlY3QgZWxlbWVudCB0byBiZSBET00gRWxlbWVudCwgYnV0IGdvdCBcXFwiICsgZWxlbSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBhdHRhY2ggc3R5bGVzaGVldFxcbiAgICAgICAgT2JqZWN0KF9zdHlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJhdHRhY2hTdHlsZVxcXCJdKSgpO1xcbiAgICAgICAgaWYgKF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uaGFzKGVsZW0pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5ldyBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlNjcm9sbGJhclxcXCJdKGVsZW0sIG9wdGlvbnMpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQXV0b21hdGljYWxseSBpbml0IHNjcm9sbGJhciBvbiBhbGwgZWxlbWVudHMgYmFzZSBvbiB0aGUgc2VsZWN0b3IgYFtkYXRhLXNjcm9sbGJhcl1gXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBvcHRpb25zIEluaXRpYWwgb3B0aW9uc1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmluaXRBbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsYmFyXScpLCBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHJldHVybiBTbW9vdGhTY3JvbGxiYXIuaW5pdChlbGVtLCBvcHRpb25zKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYSBzY3JvbGxiYXIgb24gZ2l2ZW4gZWxlbWVudFxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBjaGVja1xcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmhhcyA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxiYXJNYXBcXFwiXS5oYXMoZWxlbSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHNjcm9sbGJhciBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAgICogSWYgbm8gc2Nyb2xsYmFyIGluc3RhbmNlIGV4c2l0cywgcmV0dXJucyBgdW5kZWZpbmVkYFxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBjaGVjay5cXG4gICAgICovXFxuICAgIFNtb290aFNjcm9sbGJhci5nZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBzY3JvbGxiYXIgaW5zdGFuY2VzXFxuICAgICAqL1xcbiAgICBTbW9vdGhTY3JvbGxiYXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxiYXJNYXBcXFwiXS52YWx1ZXMoKSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIHNjcm9sbGJhciBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgdmFyIHNjcm9sbGJhciA9IF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwic2Nyb2xsYmFyTWFwXFxcIl0uZ2V0KGVsZW0pO1xcbiAgICAgICAgaWYgKHNjcm9sbGJhcikge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5kZXN0cm95KCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGFsbCBzY3JvbGxiYXIgaW5zdGFuY2VzIGZyb20gY3VycmVudCBkb2N1bWVudFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRlc3Ryb3lBbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInNjcm9sbGJhck1hcFxcXCJdLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbGJhcikge1xcbiAgICAgICAgICAgIHNjcm9sbGJhci5kZXN0cm95KCk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaGVzIHBsdWdpbnMgdG8gc2Nyb2xsYmFyc1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gLi4uUGx1Z2lucyBTY3JvbGxiYXIgcGx1Z2luIGNsYXNzZXNcXG4gICAgICovXFxuICAgIFNtb290aFNjcm9sbGJhci51c2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgUGx1Z2lucyA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICBQbHVnaW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJhZGRQbHVnaW5zXFxcIl0uYXBwbHkodm9pZCAwLCBQbHVnaW5zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaGVzIGRlZmF1bHQgc3R5bGUgc2hlZXRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXFxuICAgICAqIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgbWFudWFsbHkgdW5sZXNzXFxuICAgICAqIHlvdSByZW1vdmVkIHRoZSBkZWZhdWx0IHN0eWxlcyB2aWEgYFNjcm9sbGJhci5kZXRhY2hTdHlsZSgpYFxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmF0dGFjaFN0eWxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiYXR0YWNoU3R5bGVcXFwiXSkoKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgZGVmYXVsdCBzdHlsZXMgZnJvbSBjdXJyZW50IGRvY3VtZW50LlxcbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gY3NzIGZvciBzY3JvbGxiYXJzLlxcbiAgICAgKi9cXG4gICAgU21vb3RoU2Nyb2xsYmFyLmRldGFjaFN0eWxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGV0YWNoU3R5bGVcXFwiXSkoKTtcXG4gICAgfTtcXG4gICAgU21vb3RoU2Nyb2xsYmFyLnZlcnNpb24gPSBcXFwiOC44LjFcXFwiO1xcbiAgICBTbW9vdGhTY3JvbGxiYXIuU2Nyb2xsYmFyUGx1Z2luID0gX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJTY3JvbGxiYXJQbHVnaW5cXFwiXTtcXG4gICAgcmV0dXJuIFNtb290aFNjcm9sbGJhcjtcXG59KF9zY3JvbGxiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiU2Nyb2xsYmFyXFxcIl0pKTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChTbW9vdGhTY3JvbGxiYXIpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IE9wdGlvbnMgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyT3B0aW9uc0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJPcHRpb25zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPcHRpb25zOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlY29yYXRvcnMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG52YXIgT3B0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gT3B0aW9ucyhjb25maWcpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTW9tZW50dW0gcmVkdWN0aW9uIGRhbXBpbmcgZmFjdG9yLCBhIGZsb2F0IHZhbHVlIGJldHdlZW4gYCgwLCAxKWAuXFxuICAgICAgICAgKiBUaGUgbG93ZXIgdGhlIHZhbHVlIGlzLCB0aGUgbW9yZSBzbW9vdGggdGhlIHNjcm9sbGluZyB3aWxsIGJlXFxuICAgICAgICAgKiAoYWxzbyB0aGUgbW9yZSBwYWludCBmcmFtZXMpLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmRhbXBpbmcgPSAwLjE7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE1pbmltYWwgc2l6ZSBmb3Igc2Nyb2xsYmFyIHRodW1icy5cXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy50aHVtYk1pblNpemUgPSAyMDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogUmVuZGVyIGV2ZXJ5IGZyYW1lIGluIGludGVnZXIgcGl4ZWwgdmFsdWVzXFxuICAgICAgICAgKiBzZXQgdG8gYHRydWVgIHRvIGltcHJvdmUgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnJlbmRlckJ5UGl4ZWxzID0gdHJ1ZTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogS2VlcCBzY3JvbGxiYXIgdHJhY2tzIHZpc2libGVcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5hbHdheXNTaG93VHJhY2tzID0gZmFsc2U7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgb3V0ZXIgc2Nyb2xsYmFycyBjb250aW51ZSBzY3JvbGxpbmdcXG4gICAgICAgICAqIHdoZW4gY3VycmVudCBzY3JvbGxiYXIgcmVhY2hlcyBlZGdlLlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNTY3JvbGxpbmcgPSB0cnVlO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBEZWxlZ2F0ZSB3aGVlbCBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBjb250YWluZXIgZWxlbWVudCBpcyB1c2VkLlxcbiAgICAgICAgICogVGhpcyBvcHRpb24gd2lsbCBiZSB1c2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBmaXhlZCBlbGVtZW50cy5cXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZVRvID0gbnVsbDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogT3B0aW9ucyBmb3IgcGx1Z2lucy4gU3ludGF4OlxcbiAgICAgICAgICogICBwbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luT3B0aW9uczogYW55XFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XFxuICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBjb25maWdbcHJvcF07XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJ3aGVlbEV2ZW50VGFyZ2V0XFxcIiwge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVUbztcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3Ntb290aC1zY3JvbGxiYXJdOiBgb3B0aW9ucy53aGVlbEV2ZW50VGFyZ2V0YCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgdXNlIGBvcHRpb25zLmRlbGVnYXRlVG9gIGluc3RlYWQuJyk7XFxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZVRvID0gZWw7XFxuICAgICAgICB9LFxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fZGVjb3JhdGVcXFwiXSkoW1xcbiAgICAgICAgT2JqZWN0KF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJyYW5nZVxcXCJdKSgwLCAxKVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcImRhbXBpbmdcXFwiLCB2b2lkIDApO1xcbiAgICBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19kZWNvcmF0ZVxcXCJdKShbXFxuICAgICAgICBPYmplY3QoX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJhbmdlXFxcIl0pKDAsIEluZmluaXR5KVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcInRodW1iTWluU2l6ZVxcXCIsIHZvaWQgMCk7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJib29sZWFuXFxcIl1cXG4gICAgXSwgT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJyZW5kZXJCeVBpeGVsc1xcXCIsIHZvaWQgMCk7XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIF9kZWNvcmF0b3JzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJib29sZWFuXFxcIl1cXG4gICAgXSwgT3B0aW9ucy5wcm90b3R5cGUsIFxcXCJhbHdheXNTaG93VHJhY2tzXFxcIiwgdm9pZCAwKTtcXG4gICAgT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fZGVjb3JhdGVcXFwiXSkoW1xcbiAgICAgICAgX2RlY29yYXRvcnNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImJvb2xlYW5cXFwiXVxcbiAgICBdLCBPcHRpb25zLnByb3RvdHlwZSwgXFxcImNvbnRpbnVvdXNTY3JvbGxpbmdcXFwiLCB2b2lkIDApO1xcbiAgICByZXR1cm4gT3B0aW9ucztcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbnMuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BsdWdpbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wbHVnaW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFNjcm9sbGJhclBsdWdpbiwgZ2xvYmFsUGx1Z2lucywgYWRkUGx1Z2lucywgaW5pdFBsdWdpbnMgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUGx1Z2luSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclBsdWdpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyUGx1Z2luOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnbG9iYWxQbHVnaW5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnbG9iYWxQbHVnaW5zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZGRQbHVnaW5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRQbHVnaW5zOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpbml0UGx1Z2luc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5pdFBsdWdpbnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qc1xcXCIpO1xcblxcbnZhciBTY3JvbGxiYXJQbHVnaW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFNjcm9sbGJhclBsdWdpbihzY3JvbGxiYXIsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcXG4gICAgICAgIHRoaXMuc2Nyb2xsYmFyID0gc2Nyb2xsYmFyO1xcbiAgICAgICAgdGhpcy5uYW1lID0gX25ld1RhcmdldC5wbHVnaW5OYW1lO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fYXNzaWduXFxcIl0pKE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgX25ld1RhcmdldC5kZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIFNjcm9sbGJhclBsdWdpbi5wcm90b3R5cGUub25Jbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xcbiAgICBTY3JvbGxiYXJQbHVnaW4ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS5vblJlbmRlciA9IGZ1bmN0aW9uIChfcmVtYWluTW9tZW50dW0pIHsgfTtcXG4gICAgU2Nyb2xsYmFyUGx1Z2luLnByb3RvdHlwZS50cmFuc2Zvcm1EZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgX2V2dCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgZGVsdGEpO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXJQbHVnaW4ucGx1Z2luTmFtZSA9ICcnO1xcbiAgICBTY3JvbGxiYXJQbHVnaW4uZGVmYXVsdE9wdGlvbnMgPSB7fTtcXG4gICAgcmV0dXJuIFNjcm9sbGJhclBsdWdpbjtcXG59KCkpO1xcblxcbnZhciBnbG9iYWxQbHVnaW5zID0ge1xcbiAgICBvcmRlcjogbmV3IFNldCgpLFxcbiAgICBjb25zdHJ1Y3RvcnM6IHt9LFxcbn07XFxuZnVuY3Rpb24gYWRkUGx1Z2lucygpIHtcXG4gICAgdmFyIFBsdWdpbnMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIFBsdWdpbnNbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICBQbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKFApIHtcXG4gICAgICAgIHZhciBwbHVnaW5OYW1lID0gUC5wbHVnaW5OYW1lO1xcbiAgICAgICAgaWYgKCFwbHVnaW5OYW1lKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicGx1Z2luIG5hbWUgaXMgcmVxdWlyZWRcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsb2JhbFBsdWdpbnMub3JkZXIuYWRkKHBsdWdpbk5hbWUpO1xcbiAgICAgICAgZ2xvYmFsUGx1Z2lucy5jb25zdHJ1Y3RvcnNbcGx1Z2luTmFtZV0gPSBQO1xcbiAgICB9KTtcXG59XFxuZnVuY3Rpb24gaW5pdFBsdWdpbnMoc2Nyb2xsYmFyLCBvcHRpb25zKSB7XFxuICAgIHJldHVybiBBcnJheS5mcm9tKGdsb2JhbFBsdWdpbnMub3JkZXIpXFxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XFxuICAgICAgICByZXR1cm4gb3B0aW9uc1twbHVnaW5OYW1lXSAhPT0gZmFsc2U7XFxuICAgIH0pXFxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XFxuICAgICAgICB2YXIgUGx1Z2luID0gZ2xvYmFsUGx1Z2lucy5jb25zdHJ1Y3RvcnNbcGx1Z2luTmFtZV07XFxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgUGx1Z2luKHNjcm9sbGJhciwgb3B0aW9uc1twbHVnaW5OYW1lXSk7XFxuICAgICAgICAvLyBiaW5kIHBsdWdpbiBvcHRpb25zIHRvIGBzY3JvbGxiYXIub3B0aW9uc2BcXG4gICAgICAgIG9wdGlvbnNbcGx1Z2luTmFtZV0gPSBpbnN0YW5jZS5vcHRpb25zO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgICB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BsdWdpbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3BvbHlmaWxscy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wb2x5ZmlsbHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyUG9seWZpbGxzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvbWFwL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfbWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc19tYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfc2V0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL2VzL3NldCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9zZXQvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19zZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX2VzX3NldF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc193ZWFrX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy93ZWFrLW1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy93ZWFrLW1hcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX3dlYWtfbWFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc193ZWFrX21hcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19hcnJheV9mcm9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL2VzL2FycmF5L2Zyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX2VzX2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX2VzX2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfZXNfb2JqZWN0X2Fzc2lnbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9lcy9vYmplY3QvYXNzaWduICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9hc3NpZ24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19lc19vYmplY3RfYXNzaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19lc19vYmplY3RfYXNzaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wb2x5ZmlsbHMuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsYmFyLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBzY3JvbGxiYXJNYXAsIFNjcm9sbGJhciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJTY3JvbGxiYXJKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsYmFyTWFwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxiYXJNYXA7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcHRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29wdGlvbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvb3B0aW9ucy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVjb3JhdG9ycy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvZGVjb3JhdG9ycy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhY2tfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYWNrLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dlb21ldHJ5LyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9nZW9tZXRyeS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Nyb2xsaW5nX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3JvbGxpbmcvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3Njcm9sbGluZy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BsdWdpbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZlbnRzLyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9ldmVudHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyBETyBOT1QgdXNlIFdlYWtNYXAgaGVyZVxcbi8vIC5nZXRBbGwoKSBtZXRob2RzIHJlcXVpcmVzIGBzY3JvbGxiYXJNYXAudmFsdWVzKClgXFxudmFyIHNjcm9sbGJhck1hcCA9IG5ldyBNYXAoKTtcXG52YXIgU2Nyb2xsYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIoY29udGFpbmVyRWwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEN1cnJlbnQgc2Nyb2xsaW5nIG9mZnNldHNcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB7XFxuICAgICAgICAgICAgeDogMCxcXG4gICAgICAgICAgICB5OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTWF4LWFsbG93ZWQgc2Nyb2xsaW5nIG9mZnNldHNcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5saW1pdCA9IHtcXG4gICAgICAgICAgICB4OiBJbmZpbml0eSxcXG4gICAgICAgICAgICB5OiBJbmZpbml0eSxcXG4gICAgICAgIH07XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIENvbnRhaW5lciBib3VuZGluZyByZWN0XFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuYm91bmRpbmcgPSB7XFxuICAgICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcXG4gICAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIC8vIHByaXZhdGUgX29ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbXTtcXG4gICAgICAgIHRoaXMuX21vbWVudHVtID0geyB4OiAwLCB5OiAwIH07XFxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XFxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XFxuICAgICAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBfb3B0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJPcHRpb25zXFxcIl0ob3B0aW9ucyk7XFxuICAgICAgICAvLyBtYXJrIGFzIGEgc2Nyb2xsIGVsZW1lbnRcXG4gICAgICAgIGNvbnRhaW5lckVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGxiYXInLCAndHJ1ZScpO1xcbiAgICAgICAgLy8gbWFrZSBjb250YWluZXIgZm9jdXNhYmxlXFxuICAgICAgICBjb250YWluZXJFbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250YWluZXJFbCwge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vIGVuYWJsZSB0b3VjaCBldmVudCBjYXB0dXJpbmcgaW4gSUUsIHNlZTpcXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pZGlvdFd1L3Ntb290aC1zY3JvbGxiYXIvaXNzdWVzLzM5XFxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XFxuICAgICAgICAgICAgY29udGFpbmVyRWwuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIG1vdW50IGNvbnRlbnRcXG4gICAgICAgIGNvbnRlbnRFbC5jbGFzc05hbWUgPSAnc2Nyb2xsLWNvbnRlbnQnO1xcbiAgICAgICAgQXJyYXkuZnJvbShjb250YWluZXJFbC5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgICAgICAgY29udGVudEVsLmFwcGVuZENoaWxkKG5vZGUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xcbiAgICAgICAgLy8gYXR0YWNoIHRyYWNrXFxuICAgICAgICB0aGlzLnRyYWNrID0gbmV3IF90cmFja19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVHJhY2tDb250cm9sbGVyXFxcIl0odGhpcyk7XFxuICAgICAgICAvLyBpbml0aWFsIG1lYXN1cmluZ1xcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5nZXRTaXplKCk7XFxuICAgICAgICAvLyBpbml0IHBsdWdpbnNcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBPYmplY3QoX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJpbml0UGx1Z2luc1xcXCJdKSh0aGlzLCB0aGlzLm9wdGlvbnMucGx1Z2lucyk7XFxuICAgICAgICAvLyBwcmVzZXJ2ZSBzY3JvbGwgb2Zmc2V0XFxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGNvbnRhaW5lckVsLnNjcm9sbExlZnQsIHNjcm9sbFRvcCA9IGNvbnRhaW5lckVsLnNjcm9sbFRvcDtcXG4gICAgICAgIGNvbnRhaW5lckVsLnNjcm9sbExlZnQgPSBjb250YWluZXJFbC5zY3JvbGxUb3AgPSAwO1xcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHtcXG4gICAgICAgICAgICB3aXRob3V0Q2FsbGJhY2tzOiB0cnVlLFxcbiAgICAgICAgfSk7XFxuICAgICAgICAvLyBGSVhNRTogdXBkYXRlIHR5cGVzY3JpcHRcXG4gICAgICAgIHZhciBSZXNpemVPYnNlcnZlciA9IHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcXG4gICAgICAgIC8vIG9ic2VydmVcXG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoY29udGVudEVsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNjcm9sbGJhck1hcC5zZXQoY29udGFpbmVyRWwsIHRoaXMpO1xcbiAgICAgICAgLy8gd2FpdCBmb3IgRE9NIHJlYWR5XFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9pbml0KCk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcInBhcmVudFxcXCIsIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogUGFyZW50IHNjcm9sbGJhclxcbiAgICAgICAgICovXFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuY29udGFpbmVyRWwucGFyZW50RWxlbWVudDtcXG4gICAgICAgICAgICB3aGlsZSAoZWxlbSkge1xcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50U2Nyb2xsYmFyID0gc2Nyb2xsYmFyTWFwLmdldChlbGVtKTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNjcm9sbGJhcikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFNjcm9sbGJhcjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnRFbGVtZW50O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcInNjcm9sbFRvcFxcXCIsIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogR2V0cyBvciBzZXRzIGBzY3JvbGxiYXIub2Zmc2V0LnlgXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldC55O1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHkpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuc2Nyb2xsTGVmdCwgeSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbGJhci5wcm90b3R5cGUsIFxcXCJzY3JvbGxMZWZ0XFxcIiwge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYHNjcm9sbGJhci5vZmZzZXQueGBcXG4gICAgICAgICAqL1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoeCkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgdGhpcy5zY3JvbGxUb3ApO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSk7XFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBzY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICogYW5kIHRoZSBjb250ZW50IHdyYXBwZXIgZWxlbWVudFxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdChfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImdldFNpemVcXFwiXSkodGhpcyk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBGb3JjZXMgc2Nyb2xsYmFyIHRvIHVwZGF0ZSBnZW9tZXRyeSBpbmZvbWF0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBCeSBkZWZhdWx0LCBzY3JvbGxiYXJzIGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2l0aCBgMTAwbXNgIGRlYm91bmNlIChvciBgTXV0YXRpb25PYnNlcnZlcmAgZmlyZXMpLlxcbiAgICAgKiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgdG8gZm9yY2UgYW4gdXBkYXRlIHdoZW4geW91IG1vZGlmaWVkIGNvbnRlbnRzXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE9iamVjdChfZ2VvbWV0cnlfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInVwZGF0ZVxcXCJdKSh0aGlzKTtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uVXBkYXRlKCk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlldyBhcmVhXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0KF9nZW9tZXRyeV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiaXNWaXNpYmxlXFxcIl0pKHRoaXMsIGVsZW0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgc2Nyb2xsYmFyIHRvIHRoZSBnaXZlbiBvZmZzZXQgd2l0aG91dCBlYXNpbmdcXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IHRoaXMub2Zmc2V0Lng7IH1cXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHsgeSA9IHRoaXMub2Zmc2V0Lnk7IH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XFxuICAgICAgICB2YXIgc3RhdHVzID0gT2JqZWN0KF9zY3JvbGxpbmdfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcInNldFBvc2l0aW9uXFxcIl0pKHRoaXMsIHgsIHkpO1xcbiAgICAgICAgaWYgKCFzdGF0dXMgfHwgb3B0aW9ucy53aXRob3V0Q2FsbGJhY2tzKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICAgICAgZm4uY2FsbChfdGhpcywgc3RhdHVzKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2Nyb2xscyB0byBnaXZlbiBwb3NpdGlvbiB3aXRoIGVhc2luZyBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbiwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkgeyB4ID0gdGhpcy5vZmZzZXQueDsgfVxcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gdGhpcy5vZmZzZXQueTsgfVxcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAwOyB9XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxcbiAgICAgICAgT2JqZWN0KF9zY3JvbGxpbmdfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcInNjcm9sbFRvXFxcIl0pKHRoaXMsIHgsIHksIGR1cmF0aW9uLCBvcHRpb25zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFNjcm9sbHMgdGhlIHRhcmdldCBlbGVtZW50IGludG8gdmlzaWJsZSBhcmVhIG9mIHNjcm9sbGJhcixcXG4gICAgICogbGlrZXMgdGhlIERPTSBtZXRob2QgYGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKS5cXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cXG4gICAgICAgIE9iamVjdChfc2Nyb2xsaW5nX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJzY3JvbGxJbnRvVmlld1xcXCJdKSh0aGlzLCBlbGVtLCBvcHRpb25zKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEFkZHMgc2Nyb2xsaW5nIGxpc3RlbmVyXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignW3Ntb290aC1zY3JvbGxiYXJdIHNjcm9sbGluZyBsaXN0ZW5lciBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmFkZChmbik7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGBzY3JvbGxiYXIuYWRkTGlzdGVuZXIoKWBcXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZm4pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQWRkcyBtb21lbnR1bSBhbmQgYXBwbHlzIGRlbHRhIHRyYW5zZm9ybWVycy5cXG4gICAgICovXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuYWRkVHJhbnNmb3JtYWJsZU1vbWVudHVtID0gZnVuY3Rpb24gKHgsIHksIGZyb21FdmVudCwgY2FsbGJhY2spIHtcXG4gICAgICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCgpO1xcbiAgICAgICAgdmFyIGZpbmFsRGVsdGEgPSB0aGlzLl9wbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIHBsdWdpbikge1xcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW4udHJhbnNmb3JtRGVsdGEoZGVsdGEsIGZyb21FdmVudCkgfHwgZGVsdGE7XFxuICAgICAgICB9LCB7IHg6IHgsIHk6IHkgfSk7XFxuICAgICAgICB2YXIgd2lsbFNjcm9sbCA9ICF0aGlzLl9zaG91bGRQcm9wYWdhdGVNb21lbnR1bShmaW5hbERlbHRhLngsIGZpbmFsRGVsdGEueSk7XFxuICAgICAgICBpZiAod2lsbFNjcm9sbCkge1xcbiAgICAgICAgICAgIHRoaXMuYWRkTW9tZW50dW0oZmluYWxEZWx0YS54LCBmaW5hbERlbHRhLnkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB3aWxsU2Nyb2xsKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEluY3JlYXNlcyBzY3JvbGxiYXIncyBtb21lbnR1bVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5hZGRNb21lbnR1bSA9IGZ1bmN0aW9uICh4LCB5KSB7XFxuICAgICAgICB0aGlzLnNldE1vbWVudHVtKHRoaXMuX21vbWVudHVtLnggKyB4LCB0aGlzLl9tb21lbnR1bS55ICsgeSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHNjcm9sbGJhcidzIG1vbWVudHVtIHRvIGdpdmVuIHZhbHVlXFxuICAgICAqL1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKHgsIHkpIHtcXG4gICAgICAgIGlmICh0aGlzLmxpbWl0LnggPT09IDApIHtcXG4gICAgICAgICAgICB4ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLmxpbWl0LnkgPT09IDApIHtcXG4gICAgICAgICAgICB5ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVuZGVyQnlQaXhlbHMpIHtcXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuX21vbWVudHVtLnggPSB4O1xcbiAgICAgICAgdGhpcy5fbW9tZW50dW0ueSA9IHk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgb3B0aW9ucyBmb3Igc3BlY2lmaWMgcGx1Z2luXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBwbHVnaW5OYW1lIE5hbWUgb2YgdGhlIHBsdWdpblxcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIEFuIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydGllcyB0aGF0IHlvdSB3YW50IHRvIHVwZGF0ZVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS51cGRhdGVQbHVnaW5PcHRpb25zID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUsIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgaWYgKHBsdWdpbi5uYW1lID09PSBwbHVnaW5OYW1lKSB7XFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGx1Z2luLm9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250YWluZXJFbCA9IF9hLmNvbnRhaW5lckVsLCBjb250ZW50RWwgPSBfYS5jb250ZW50RWw7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJjbGVhckV2ZW50c09uXFxcIl0pKHRoaXMpO1xcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmNsZWFyKCk7XFxuICAgICAgICB0aGlzLnNldE1vbWVudHVtKDAsIDApO1xcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVySUQpO1xcbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XFxuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2Nyb2xsYmFyTWFwLmRlbGV0ZSh0aGlzLmNvbnRhaW5lckVsKTtcXG4gICAgICAgIC8vIHJlc3RvcmUgY29udGVudHNcXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShjb250ZW50RWwuY2hpbGROb2Rlcyk7XFxuICAgICAgICB3aGlsZSAoY29udGFpbmVyRWwuZmlyc3RDaGlsZCkge1xcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmZpcnN0Q2hpbGQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgLy8gcmVzZXQgc2Nyb2xsIHBvc2l0aW9uXFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250YWluZXJFbCwge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJyxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XFxuICAgICAgICBjb250YWluZXJFbC5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xcbiAgICAgICAgLy8gaW52b2tlIHBsdWdpbi5vbkRlc3Ryb3lcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uRGVzdHJveSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLl9wbHVnaW5zLmxlbmd0aCA9IDA7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcXG4gICAgICAgIC8vIGluaXQgZXZldCBoYW5kbGVyc1xcbiAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50c19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xcbiAgICAgICAgICAgIF9ldmVudHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bcHJvcF0oX3RoaXMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvLyBpbnZva2UgYHBsdWdpbi5vbkluaXRgXFxuICAgICAgICB0aGlzLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xcbiAgICAgICAgICAgIHBsdWdpbi5vbkluaXQoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX3VwZGF0ZURlYm91bmNlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XFxuICAgIH07XFxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdG8gcHJvcGFnYXRlIG1vbm1lbnR1bSB0byBwYXJlbnQgc2Nyb2xsYmFyXFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgc2l0dWF0aW9ucyBhcmUgY29uc2lkZXJlZCBhcyBgdHJ1ZWA6XFxuICAgIC8vICAgICAgICAgMS4gY29udGludW91cyBzY3JvbGxpbmcgaXMgZW5hYmxlZCAoYXV0b21hdGljYWxseSBkaXNhYmxlZCB3aGVuIG92ZXJzY3JvbGwgaXMgZW5hYmxlZClcXG4gICAgLy8gICAgICAgICAyLiBzY3JvbGxiYXIgcmVhY2hlcyBvbmUgc2lkZSBhbmQgaXMgbm90IGFib3V0IHRvIHNjcm9sbCBvbiB0aGUgb3RoZXIgZGlyZWN0aW9uXFxuICAgIFNjcm9sbGJhci5wcm90b3R5cGUuX3Nob3VsZFByb3BhZ2F0ZU1vbWVudHVtID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XFxuICAgICAgICBpZiAoZGVsdGFYID09PSB2b2lkIDApIHsgZGVsdGFYID0gMDsgfVxcbiAgICAgICAgaWYgKGRlbHRhWSA9PT0gdm9pZCAwKSB7IGRlbHRhWSA9IDA7IH1cXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBvZmZzZXQgPSBfYS5vZmZzZXQsIGxpbWl0ID0gX2EubGltaXQ7XFxuICAgICAgICBpZiAoIW9wdGlvbnMuY29udGludW91c1Njcm9sbGluZylcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUgd2hlbiBzY3JvbGxiYXIgaXMgXFxcInVuc2Nyb2xsYWJsZVxcXCIsIHNlZSAjMTA2XFxuICAgICAgICBpZiAobGltaXQueCA9PT0gMCAmJiBsaW1pdC55ID09PSAwKSB7XFxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVib3VuY2VkKCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGVzdFggPSBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkoZGVsdGFYICsgb2Zmc2V0LngsIDAsIGxpbWl0LngpO1xcbiAgICAgICAgdmFyIGRlc3RZID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKGRlbHRhWSArIG9mZnNldC55LCAwLCBsaW1pdC55KTtcXG4gICAgICAgIHZhciByZXMgPSB0cnVlO1xcbiAgICAgICAgLy8gb2Zmc2V0cyBhcmUgbm90IGFib3V0IHRvIGNoYW5nZVxcbiAgICAgICAgLy8gYCY9YCBvcGVyYXRvciBpcyBub3QgYWxsb3dlZCBmb3IgYm9vbGVhbiB0eXBlc1xcbiAgICAgICAgcmVzID0gcmVzICYmIChkZXN0WCA9PT0gb2Zmc2V0LngpO1xcbiAgICAgICAgcmVzID0gcmVzICYmIChkZXN0WSA9PT0gb2Zmc2V0LnkpO1xcbiAgICAgICAgLy8gY3VycmVudCBvZmZzZXRzIGFyZSBvbiB0aGUgZWRnZVxcbiAgICAgICAgcmVzID0gcmVzICYmIChvZmZzZXQueCA9PT0gbGltaXQueCB8fCBvZmZzZXQueCA9PT0gMCB8fCBvZmZzZXQueSA9PT0gbGltaXQueSB8fCBvZmZzZXQueSA9PT0gMCk7XFxuICAgICAgICByZXR1cm4gcmVzO1xcbiAgICB9O1xcbiAgICBTY3JvbGxiYXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX21vbWVudHVtID0gdGhpcy5fbW9tZW50dW07XFxuICAgICAgICBpZiAoX21vbWVudHVtLnggfHwgX21vbWVudHVtLnkpIHtcXG4gICAgICAgICAgICB2YXIgbmV4dFggPSB0aGlzLl9uZXh0VGljaygneCcpO1xcbiAgICAgICAgICAgIHZhciBuZXh0WSA9IHRoaXMuX25leHRUaWNrKCd5Jyk7XFxuICAgICAgICAgICAgX21vbWVudHVtLnggPSBuZXh0WC5tb21lbnR1bTtcXG4gICAgICAgICAgICBfbW9tZW50dW0ueSA9IG5leHRZLm1vbWVudHVtO1xcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24obmV4dFgucG9zaXRpb24sIG5leHRZLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciByZW1haW4gPSBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRoaXMuX21vbWVudHVtKTtcXG4gICAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgICAgICAgcGx1Z2luLm9uUmVuZGVyKHJlbWFpbik7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuX3JlbmRlcklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpKTtcXG4gICAgfTtcXG4gICAgU2Nyb2xsYmFyLnByb3RvdHlwZS5fbmV4dFRpY2sgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBfbW9tZW50dW0gPSBfYS5fbW9tZW50dW07XFxuICAgICAgICB2YXIgY3VycmVudCA9IG9mZnNldFtkaXJlY3Rpb25dO1xcbiAgICAgICAgdmFyIHJlbWFpbiA9IF9tb21lbnR1bVtkaXJlY3Rpb25dO1xcbiAgICAgICAgaWYgKE1hdGguYWJzKHJlbWFpbikgPD0gMC4xKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgbW9tZW50dW06IDAsXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50ICsgcmVtYWluLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbmV4dE1vbWVudHVtID0gcmVtYWluICogKDEgLSBvcHRpb25zLmRhbXBpbmcpO1xcbiAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyQnlQaXhlbHMpIHtcXG4gICAgICAgICAgICBuZXh0TW9tZW50dW0gfD0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbW9tZW50dW06IG5leHRNb21lbnR1bSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogY3VycmVudCArIHJlbWFpbiAtIG5leHRNb21lbnR1bSxcXG4gICAgICAgIH07XFxuICAgIH07XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIE9iamVjdChfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVib3VuY2VcXFwiXSkoMTAwLCB7IGxlYWRpbmc6IHRydWUgfSlcXG4gICAgXSwgU2Nyb2xsYmFyLnByb3RvdHlwZSwgXFxcIl91cGRhdGVEZWJvdW5jZWRcXFwiLCBudWxsKTtcXG4gICAgcmV0dXJuIFNjcm9sbGJhcjtcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbGJhci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxiYXIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBzZXRQb3NpdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEludG9WaWV3ICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldC1wb3NpdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2V0LXBvc2l0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzZXRQb3NpdGlvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldF9wb3NpdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzZXRQb3NpdGlvblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Njcm9sbF90b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY3JvbGwtdG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC10by5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9zY3JvbGxfdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwic2Nyb2xsVG9cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JvbGxfaW50b192aWV3X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Njcm9sbC1pbnRvLXZpZXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbEludG9WaWV3XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2Nyb2xsX2ludG9fdmlld19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzY3JvbGxJbnRvVmlld1xcXCJdOyB9KTtcXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvaW5kZXguanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLWludG8tdmlldy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3Njcm9sbGluZy9zY3JvbGwtaW50by12aWV3LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNjcm9sbEludG9WaWV3ICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1Njcm9sbEludG9WaWV3SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNjcm9sbEludG9WaWV3XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxJbnRvVmlldzsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHNjcm9sbGJhciwgZWxlbSwgX2EpIHtcXG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuYWxpZ25Ub1RvcCwgYWxpZ25Ub1RvcCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2Iub25seVNjcm9sbElmTmVlZGVkLCBvbmx5U2Nyb2xsSWZOZWVkZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5vZmZzZXRUb3AsIG9mZnNldFRvcCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gX2Iub2Zmc2V0TGVmdCwgb2Zmc2V0TGVmdCA9IF9mID09PSB2b2lkIDAgPyAwIDogX2YsIF9nID0gX2Iub2Zmc2V0Qm90dG9tLCBvZmZzZXRCb3R0b20gPSBfZyA9PT0gdm9pZCAwID8gMCA6IF9nO1xcbiAgICB2YXIgY29udGFpbmVyRWwgPSBzY3JvbGxiYXIuY29udGFpbmVyRWwsIGJvdW5kaW5nID0gc2Nyb2xsYmFyLmJvdW5kaW5nLCBvZmZzZXQgPSBzY3JvbGxiYXIub2Zmc2V0LCBsaW1pdCA9IHNjcm9sbGJhci5saW1pdDtcXG4gICAgaWYgKCFlbGVtIHx8ICFjb250YWluZXJFbC5jb250YWlucyhlbGVtKSlcXG4gICAgICAgIHJldHVybjtcXG4gICAgdmFyIHRhcmdldEJvdW5kaW5nID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgaWYgKG9ubHlTY3JvbGxJZk5lZWRlZCAmJiBzY3JvbGxiYXIuaXNWaXNpYmxlKGVsZW0pKVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICB2YXIgZGVsdGEgPSBhbGlnblRvVG9wID8gdGFyZ2V0Qm91bmRpbmcudG9wIC0gYm91bmRpbmcudG9wIC0gb2Zmc2V0VG9wIDogdGFyZ2V0Qm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgb2Zmc2V0Qm90dG9tO1xcbiAgICBzY3JvbGxiYXIuc2V0TW9tZW50dW0odGFyZ2V0Qm91bmRpbmcubGVmdCAtIGJvdW5kaW5nLmxlZnQgLSBvZmZzZXRMZWZ0LCBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZGVsdGEsIC1vZmZzZXQueSwgbGltaXQueSAtIG9mZnNldC55KSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC1pbnRvLXZpZXcuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3Njcm9sbC1pbnRvLXZpZXcuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogc2Nyb2xsVG8gKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyU2Nyb2xsaW5nU2Nyb2xsVG9Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2Nyb2xsVG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbFRvOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guY2xhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbGFtcC9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuXFxudmFyIGFuaW1hdGlvbklEU3RvcmFnZSA9IG5ldyBXZWFrTWFwKCk7XFxuZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsYmFyLCB4LCB5LCBkdXJhdGlvbiwgX2EpIHtcXG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAwOyB9XFxuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmVhc2luZywgZWFzaW5nID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFYXNpbmcgOiBfYywgY2FsbGJhY2sgPSBfYi5jYWxsYmFjaztcXG4gICAgdmFyIG9wdGlvbnMgPSBzY3JvbGxiYXIub3B0aW9ucywgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldCwgbGltaXQgPSBzY3JvbGxiYXIubGltaXQ7XFxuICAgIGlmIChvcHRpb25zLnJlbmRlckJ5UGl4ZWxzKSB7XFxuICAgICAgICAvLyBlbnN1cmUgcmVzb2x2ZWQgd2l0aCBpbnRlZ2VyXFxuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xcbiAgICB9XFxuICAgIHZhciBzdGFydFggPSBvZmZzZXQueDtcXG4gICAgdmFyIHN0YXJ0WSA9IG9mZnNldC55O1xcbiAgICB2YXIgZGlzWCA9IGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh4LCAwLCBsaW1pdC54KSAtIHN0YXJ0WDtcXG4gICAgdmFyIGRpc1kgPSBsb2Rhc2hfY2xhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoeSwgMCwgbGltaXQueSkgLSBzdGFydFk7XFxuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XFxuICAgIGZ1bmN0aW9uIHNjcm9sbCgpIHtcXG4gICAgICAgIHZhciBlbGFwc2UgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBkdXJhdGlvbiA/IGVhc2luZyhNYXRoLm1pbihlbGFwc2UgLyBkdXJhdGlvbiwgMSkpIDogMTtcXG4gICAgICAgIHNjcm9sbGJhci5zZXRQb3NpdGlvbihzdGFydFggKyBkaXNYICogcHJvZ3Jlc3MsIHN0YXJ0WSArIGRpc1kgKiBwcm9ncmVzcyk7XFxuICAgICAgICBpZiAoZWxhcHNlID49IGR1cmF0aW9uKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjcm9sbGJhcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbCk7XFxuICAgICAgICAgICAgYW5pbWF0aW9uSURTdG9yYWdlLnNldChzY3JvbGxiYXIsIGFuaW1hdGlvbklEKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JRFN0b3JhZ2UuZ2V0KHNjcm9sbGJhcikpO1xcbiAgICBzY3JvbGwoKTtcXG59XFxuLyoqXFxuICogZWFzZU91dEN1YmljXFxuICovXFxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh0KSB7XFxuICAgIHJldHVybiBNYXRoLnBvdygodCAtIDEpLCAzKSArIDE7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC10by5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zY3JvbGxpbmcvc2Nyb2xsLXRvLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldFBvc2l0aW9uICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclNjcm9sbGluZ1NldFBvc2l0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNldFBvc2l0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRQb3NpdGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoLmNsYW1wICovIFxcXCIuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xhbXAvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBzZXRQb3NpdGlvbihzY3JvbGxiYXIsIHgsIHkpIHtcXG4gICAgdmFyIG9wdGlvbnMgPSBzY3JvbGxiYXIub3B0aW9ucywgb2Zmc2V0ID0gc2Nyb2xsYmFyLm9mZnNldCwgbGltaXQgPSBzY3JvbGxiYXIubGltaXQsIHRyYWNrID0gc2Nyb2xsYmFyLnRyYWNrLCBjb250ZW50RWwgPSBzY3JvbGxiYXIuY29udGVudEVsO1xcbiAgICBpZiAob3B0aW9ucy5yZW5kZXJCeVBpeGVscykge1xcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XFxuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcXG4gICAgfVxcbiAgICB4ID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKHgsIDAsIGxpbWl0LngpO1xcbiAgICB5ID0gbG9kYXNoX2NsYW1wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKHksIDAsIGxpbWl0LnkpO1xcbiAgICAvLyBwb3NpdGlvbiBjaGFuZ2VkIC0+IHNob3cgdHJhY2sgZm9yIDMwMG1zXFxuICAgIGlmICh4ICE9PSBvZmZzZXQueClcXG4gICAgICAgIHRyYWNrLnhBeGlzLnNob3coKTtcXG4gICAgaWYgKHkgIT09IG9mZnNldC55KVxcbiAgICAgICAgdHJhY2sueUF4aXMuc2hvdygpO1xcbiAgICBpZiAoIW9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgdHJhY2suYXV0b0hpZGVPbklkbGUoKTtcXG4gICAgfVxcbiAgICBpZiAoeCA9PT0gb2Zmc2V0LnggJiYgeSA9PT0gb2Zmc2V0LnkpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIG9mZnNldC54ID0geDtcXG4gICAgb2Zmc2V0LnkgPSB5O1xcbiAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJzZXRTdHlsZVxcXCJdKShjb250ZW50RWwsIHtcXG4gICAgICAgICctdHJhbnNmb3JtJzogXFxcInRyYW5zbGF0ZTNkKFxcXCIgKyAteCArIFxcXCJweCwgXFxcIiArIC15ICsgXFxcInB4LCAwKVxcXCIsXFxuICAgIH0pO1xcbiAgICB0cmFjay51cGRhdGUoKTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIG9mZnNldDogT2JqZWN0KHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIl9fYXNzaWduXFxcIl0pKHt9LCBvZmZzZXQpLFxcbiAgICAgICAgbGltaXQ6IE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2Fzc2lnblxcXCJdKSh7fSwgbGltaXQpLFxcbiAgICB9O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtcG9zaXRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc2Nyb2xsaW5nL3NldC1wb3NpdGlvbi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3N0eWxlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvc3R5bGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogYXR0YWNoU3R5bGUsIGRldGFjaFN0eWxlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclN0eWxlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImF0dGFjaFN0eWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdHRhY2hTdHlsZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGV0YWNoU3R5bGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRldGFjaFN0eWxlOyB9KTtcXG52YXIgVFJBQ0tfQkcgPSAncmdiYSgyMjIsIDIyMiwgMjIyLCAuNzUpJztcXG52YXIgVEhVTUJfQkcgPSAncmdiYSgwLCAwLCAwLCAuNSknO1xcbi8vIHNldHMgY29udGVudCdzIGRpc3BsYXkgdHlwZSB0byBgZmxvdy1yb290YCB0byBzdXBwcmVzcyBtYXJnaW4gY29sbGFwc2luZ1xcbnZhciBTQ1JPTExCQVJfU1RZTEUgPSBcXFwiXFxcXG5bZGF0YS1zY3JvbGxiYXJdIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbn1cXFxcblxcXFxuLnNjcm9sbC1jb250ZW50IHtcXFxcbiAgZGlzcGxheTogZmxvdy1yb290O1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXFxcbn1cXFxcblxcXFxuLnNjcm9sbGJhci10cmFjayB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgb3BhY2l0eTogMDtcXFxcbiAgei1pbmRleDogMTtcXFxcbiAgYmFja2dyb3VuZDogXFxcIiArIFRSQUNLX0JHICsgXFxcIjtcXFxcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgMC41cyBlYXNlLW91dDtcXFxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgMC41cyBlYXNlLW91dDtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdHJhY2suc2hvdyxcXFxcbi5zY3JvbGxiYXItdHJhY2s6aG92ZXIge1xcXFxuICBvcGFjaXR5OiAxO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb24tZGVsYXk6IDBzO1xcXFxuICAgICAgICAgIHRyYW5zaXRpb24tZGVsYXk6IDBzO1xcXFxufVxcXFxuXFxcXG4uc2Nyb2xsYmFyLXRyYWNrLXgge1xcXFxuICBib3R0b206IDA7XFxcXG4gIGxlZnQ6IDA7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICBoZWlnaHQ6IDhweDtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdHJhY2steSB7XFxcXG4gIHRvcDogMDtcXFxcbiAgcmlnaHQ6IDA7XFxcXG4gIHdpZHRoOiA4cHg7XFxcXG4gIGhlaWdodDogMTAwJTtcXFxcbn1cXFxcbi5zY3JvbGxiYXItdGh1bWIge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHRvcDogMDtcXFxcbiAgbGVmdDogMDtcXFxcbiAgd2lkdGg6IDhweDtcXFxcbiAgaGVpZ2h0OiA4cHg7XFxcXG4gIGJhY2tncm91bmQ6IFxcXCIgKyBUSFVNQl9CRyArIFxcXCI7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXFxcbn1cXFxcblxcXCI7XFxudmFyIFNUWUxFX0lEID0gJ3Ntb290aC1zY3JvbGxiYXItc3R5bGUnO1xcbnZhciBpc1N0eWxlQXR0YWNoZWQgPSBmYWxzZTtcXG5mdW5jdGlvbiBhdHRhY2hTdHlsZSgpIHtcXG4gICAgaWYgKGlzU3R5bGVBdHRhY2hlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcXG4gICAgc3R5bGVFbC5pZCA9IFNUWUxFX0lEO1xcbiAgICBzdHlsZUVsLnRleHRDb250ZW50ID0gU0NST0xMQkFSX1NUWUxFO1xcbiAgICBpZiAoZG9jdW1lbnQuaGVhZCkge1xcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcXG4gICAgfVxcbiAgICBpc1N0eWxlQXR0YWNoZWQgPSB0cnVlO1xcbn1cXG5mdW5jdGlvbiBkZXRhY2hTdHlsZSgpIHtcXG4gICAgaWYgKCFpc1N0eWxlQXR0YWNoZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNUWUxFX0lEKTtcXG4gICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLnBhcmVudE5vZGUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdHlsZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbCk7XFxuICAgIGlzU3R5bGVBdHRhY2hlZCA9IGZhbHNlO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci9zdHlsZS5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9kaXJlY3Rpb24uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRyYWNrRGlyZWN0aW9uICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclRyYWNrRGlyZWN0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrRGlyZWN0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFja0RpcmVjdGlvbjsgfSk7XFxudmFyIFRyYWNrRGlyZWN0aW9uO1xcbihmdW5jdGlvbiAoVHJhY2tEaXJlY3Rpb24pIHtcXG4gICAgVHJhY2tEaXJlY3Rpb25bXFxcIlhcXFwiXSA9IFxcXCJ4XFxcIjtcXG4gICAgVHJhY2tEaXJlY3Rpb25bXFxcIllcXFwiXSA9IFxcXCJ5XFxcIjtcXG59KShUcmFja0RpcmVjdGlvbiB8fCAoVHJhY2tEaXJlY3Rpb24gPSB7fSkpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9kaXJlY3Rpb24uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRyYWNrQ29udHJvbGxlciAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrQ29udHJvbGxlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhY2tDb250cm9sbGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFxcXCIuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlyZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlY29yYXRvcnMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2RlY29yYXRvcnMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG52YXIgVHJhY2tDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBUcmFja0NvbnRyb2xsZXIoX3Njcm9sbGJhcikge1xcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyID0gX3Njcm9sbGJhcjtcXG4gICAgICAgIHZhciB0aHVtYk1pblNpemUgPSBfc2Nyb2xsYmFyLm9wdGlvbnMudGh1bWJNaW5TaXplO1xcbiAgICAgICAgdGhpcy54QXhpcyA9IG5ldyBfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiU2Nyb2xsYmFyVHJhY2tcXFwiXShfZGlyZWN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlRyYWNrRGlyZWN0aW9uXFxcIl0uWCwgdGh1bWJNaW5TaXplKTtcXG4gICAgICAgIHRoaXMueUF4aXMgPSBuZXcgX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlNjcm9sbGJhclRyYWNrXFxcIl0oX2RpcmVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJUcmFja0RpcmVjdGlvblxcXCJdLlksIHRodW1iTWluU2l6ZSk7XFxuICAgICAgICB0aGlzLnhBeGlzLmF0dGFjaFRvKF9zY3JvbGxiYXIuY29udGFpbmVyRWwpO1xcbiAgICAgICAgdGhpcy55QXhpcy5hdHRhY2hUbyhfc2Nyb2xsYmFyLmNvbnRhaW5lckVsKTtcXG4gICAgICAgIGlmIChfc2Nyb2xsYmFyLm9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgICAgIHRoaXMueEF4aXMuc2hvdygpO1xcbiAgICAgICAgICAgIHRoaXMueUF4aXMuc2hvdygpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGVzIHRyYWNrIGFwcGVhcmFuY2VcXG4gICAgICovXFxuICAgIFRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fc2Nyb2xsYmFyLCBzaXplID0gX2Euc2l6ZSwgb2Zmc2V0ID0gX2Eub2Zmc2V0O1xcbiAgICAgICAgdGhpcy54QXhpcy51cGRhdGUob2Zmc2V0LngsIHNpemUuY29udGFpbmVyLndpZHRoLCBzaXplLmNvbnRlbnQud2lkdGgpO1xcbiAgICAgICAgdGhpcy55QXhpcy51cGRhdGUob2Zmc2V0LnksIHNpemUuY29udGFpbmVyLmhlaWdodCwgc2l6ZS5jb250ZW50LmhlaWdodCk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGhpZGUgdHJhY2tzIHdoZW4gc2Nyb2xsYmFyIGlzIGluIGlkbGUgc3RhdGVcXG4gICAgICovXFxuICAgIFRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuYXV0b0hpZGVPbklkbGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsYmFyLm9wdGlvbnMuYWx3YXlzU2hvd1RyYWNrcykge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMueEF4aXMuaGlkZSgpO1xcbiAgICAgICAgdGhpcy55QXhpcy5oaWRlKCk7XFxuICAgIH07XFxuICAgIE9iamVjdCh0c2xpYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJfX2RlY29yYXRlXFxcIl0pKFtcXG4gICAgICAgIE9iamVjdChfZGVjb3JhdG9yc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVib3VuY2VcXFwiXSkoMzAwKVxcbiAgICBdLCBUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcXFwiYXV0b0hpZGVPbklkbGVcXFwiLCBudWxsKTtcXG4gICAgcmV0dXJuIFRyYWNrQ29udHJvbGxlcjtcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdGh1bWIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90aHVtYi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBTY3JvbGxiYXJUaHVtYiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJUcmFja1RodW1iSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlNjcm9sbGJhclRodW1iXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTY3JvbGxiYXJUaHVtYjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlyZWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL2RpcmVjdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG52YXIgU2Nyb2xsYmFyVGh1bWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFNjcm9sbGJhclRodW1iKF9kaXJlY3Rpb24sIF9taW5TaXplKSB7XFxuICAgICAgICBpZiAoX21pblNpemUgPT09IHZvaWQgMCkgeyBfbWluU2l6ZSA9IDA7IH1cXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XFxuICAgICAgICB0aGlzLl9taW5TaXplID0gX21pblNpemU7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFRodW1iIGVsZW1lbnRcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIERpc3BsYXkgc2l6ZSBvZiB0aGUgdGh1bWJcXG4gICAgICAgICAqIHdpbGwgYWx3YXlzIGJlIGdyZWF0ZXIgdGhhbiBgc2Nyb2xsYmFyLm9wdGlvbnMudGh1bWJNaW5TaXplYFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gMDtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogQWN0dWFsIHNpemUgb2YgdGhlIHRodW1iXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMucmVhbFNpemUgPSAwO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBUaHVtYiBvZmZzZXQgdG8gdGhlIHRvcFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXFxcInNjcm9sbGJhci10aHVtYiBzY3JvbGxiYXItdGh1bWItXFxcIiArIF9kaXJlY3Rpb247XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaCB0byB0cmFjayBlbGVtZW50XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB0cmFja0VsIFRyYWNrIGVsZW1lbnRcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uICh0cmFja0VsKSB7XFxuICAgICAgICB0cmFja0VsLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsT2Zmc2V0LCBjb250YWluZXJTaXplLCBwYWdlU2l6ZSkge1xcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRodW1iIHNpemVcXG4gICAgICAgIC8vIHBhZ2VTaXplID4gY29udGFpbmVyU2l6ZSAtPiBzY3JvbGxhYmxlXFxuICAgICAgICB0aGlzLnJlYWxTaXplID0gTWF0aC5taW4oY29udGFpbmVyU2l6ZSAvIHBhZ2VTaXplLCAxKSAqIGNvbnRhaW5lclNpemU7XFxuICAgICAgICB0aGlzLmRpc3BsYXlTaXplID0gTWF0aC5tYXgodGhpcy5yZWFsU2l6ZSwgdGhpcy5fbWluU2l6ZSk7XFxuICAgICAgICAvLyBjYWxjdWxhdGUgdGh1bWIgb2Zmc2V0XFxuICAgICAgICB0aGlzLm9mZnNldCA9IHNjcm9sbE9mZnNldCAvIHBhZ2VTaXplICogKGNvbnRhaW5lclNpemUgKyAodGhpcy5yZWFsU2l6ZSAtIHRoaXMuZGlzcGxheVNpemUpKTtcXG4gICAgICAgIE9iamVjdChfdXRpbHNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInNldFN0eWxlXFxcIl0pKHRoaXMuZWxlbWVudCwgdGhpcy5fZ2V0U3R5bGUoKSk7XFxuICAgIH07XFxuICAgIFNjcm9sbGJhclRodW1iLnByb3RvdHlwZS5fZ2V0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2RpcmVjdGlvbikge1xcbiAgICAgICAgICAgIGNhc2UgX2RpcmVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJUcmFja0RpcmVjdGlvblxcXCJdLlg6XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5kaXNwbGF5U2l6ZSArIFxcXCJweFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAnLXRyYW5zZm9ybSc6IFxcXCJ0cmFuc2xhdGUzZChcXFwiICsgdGhpcy5vZmZzZXQgKyBcXFwicHgsIDAsIDApXFxcIixcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBjYXNlIF9kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiVHJhY2tEaXJlY3Rpb25cXFwiXS5ZOlxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmRpc3BsYXlTaXplICsgXFxcInB4XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICctdHJhbnNmb3JtJzogXFxcInRyYW5zbGF0ZTNkKDAsIFxcXCIgKyB0aGlzLm9mZnNldCArIFxcXCJweCwgMClcXFwiLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICByZXR1cm4gU2Nyb2xsYmFyVGh1bWI7XFxufSgpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHVtYi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci90cmFjay90aHVtYi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdHJhY2suanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogU2Nyb2xsYmFyVHJhY2sgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVHJhY2tUcmFja0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxiYXJUcmFja1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2Nyb2xsYmFyVHJhY2s7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGh1bWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGh1bWIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdHJhY2svdGh1bWIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxuXFxudmFyIFNjcm9sbGJhclRyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBTY3JvbGxiYXJUcmFjayhkaXJlY3Rpb24sIHRodW1iTWluU2l6ZSkge1xcbiAgICAgICAgaWYgKHRodW1iTWluU2l6ZSA9PT0gdm9pZCAwKSB7IHRodW1iTWluU2l6ZSA9IDA7IH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVHJhY2sgZWxlbWVudFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcXFwic2Nyb2xsYmFyLXRyYWNrIHNjcm9sbGJhci10cmFjay1cXFwiICsgZGlyZWN0aW9uO1xcbiAgICAgICAgdGhpcy50aHVtYiA9IG5ldyBfdGh1bWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiU2Nyb2xsYmFyVGh1bWJcXFwiXShkaXJlY3Rpb24sIHRodW1iTWluU2l6ZSk7XFxuICAgICAgICB0aGlzLnRodW1iLmF0dGFjaFRvKHRoaXMuZWxlbWVudCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEF0dGFjaCB0byBzY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHNjcm9sbGJhckNvbnRhaW5lciBTY3JvbGxiYXIgY29udGFpbmVyIGVsZW1lbnRcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRyYWNrLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJDb250YWluZXIpIHtcXG4gICAgICAgIHNjcm9sbGJhckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogU2hvdyB0cmFjayBpbW1lZGlhdGVseVxcbiAgICAgKi9cXG4gICAgU2Nyb2xsYmFyVHJhY2sucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEhpZGUgdHJhY2sgaW1tZWRpYXRlbHlcXG4gICAgICovXFxuICAgIFNjcm9sbGJhclRyYWNrLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcXG4gICAgfTtcXG4gICAgU2Nyb2xsYmFyVHJhY2sucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzY3JvbGxPZmZzZXQsIGNvbnRhaW5lclNpemUsIHBhZ2VTaXplKSB7XFxuICAgICAgICBPYmplY3QoX3V0aWxzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJzZXRTdHlsZVxcXCJdKSh0aGlzLmVsZW1lbnQsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBwYWdlU2l6ZSA8PSBjb250YWluZXJTaXplID8gJ25vbmUnIDogJ2Jsb2NrJyxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy50aHVtYi51cGRhdGUoc2Nyb2xsT2Zmc2V0LCBjb250YWluZXJTaXplLCBwYWdlU2l6ZSk7XFxuICAgIH07XFxuICAgIHJldHVybiBTY3JvbGxiYXJUcmFjaztcXG59KCkpO1xcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3RyYWNrL3RyYWNrLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZXZlbnQtaHViLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2V2ZW50LWh1Yi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZXZlbnRTY29wZSwgY2xlYXJFdmVudHNPbiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0V2ZW50SHViSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50U2NvcGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV2ZW50U2NvcGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsZWFyRXZlbnRzT25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsZWFyRXZlbnRzT247IH0pO1xcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucztcXG52YXIgZXZlbnRNYXAgPSBuZXcgV2Vha01hcCgpO1xcbmZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XFxuICAgIGlmIChldmVudExpc3RlbmVyT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lck9wdGlvbnM7XFxuICAgIH1cXG4gICAgdmFyIHN1cHBvcnRQYXNzaXZlRXZlbnQgPSBmYWxzZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBzdXBwb3J0UGFzc2l2ZUV2ZW50ID0gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBub29wLCBvcHRpb25zKTtcXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG5vb3AsIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlKSB7IH1cXG4gICAgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0UGFzc2l2ZUV2ZW50ID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XFxuICAgIHJldHVybiBldmVudExpc3RlbmVyT3B0aW9ucztcXG59XFxuZnVuY3Rpb24gZXZlbnRTY29wZShzY3JvbGxiYXIpIHtcXG4gICAgdmFyIGNvbmZpZ3MgPSBldmVudE1hcC5nZXQoc2Nyb2xsYmFyKSB8fCBbXTtcXG4gICAgZXZlbnRNYXAuc2V0KHNjcm9sbGJhciwgY29uZmlncyk7XFxuICAgIHJldHVybiBmdW5jdGlvbiBhZGRFdmVudChlbGVtLCBldmVudHMsIGZuKSB7XFxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuICAgICAgICAgICAgLy8gaWdub3JlIGRlZmF1bHQgcHJldmVudGVkIGV2ZW50c1xcbiAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm4oZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXZlbnRzLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XFxuICAgICAgICAgICAgY29uZmlncy5wdXNoKHsgZWxlbTogZWxlbSwgZXZlbnROYW1lOiBldmVudE5hbWUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XFxuICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZ2V0T3B0aW9ucygpKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbn1cXG5mdW5jdGlvbiBjbGVhckV2ZW50c09uKHNjcm9sbGJhcikge1xcbiAgICB2YXIgY29uZmlncyA9IGV2ZW50TWFwLmdldChzY3JvbGxiYXIpO1xcbiAgICBpZiAoIWNvbmZpZ3MpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XFxuICAgICAgICB2YXIgZWxlbSA9IF9hLmVsZW0sIGV2ZW50TmFtZSA9IF9hLmV2ZW50TmFtZSwgaGFuZGxlciA9IF9hLmhhbmRsZXI7XFxuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBnZXRPcHRpb25zKCkpO1xcbiAgICB9KTtcXG4gICAgZXZlbnRNYXAuZGVsZXRlKHNjcm9sbGJhcik7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LWh1Yi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9ldmVudC1odWIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0UG9pbnRlckRhdGEgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzU21vb3RoU2Nyb2xsYmFyVXRpbHNHZXRQb2ludGVyRGF0YUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnZXRQb2ludGVyRGF0YVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UG9pbnRlckRhdGE7IH0pO1xcbi8qKlxcbiAqIEdldCBwb2ludGVyL3RvdWNoIGRhdGFcXG4gKi9cXG5mdW5jdGlvbiBnZXRQb2ludGVyRGF0YShldnQpIHtcXG4gICAgLy8gaWYgaXMgdG91Y2ggZXZlbnQsIHJldHVybiBsYXN0IGl0ZW0gaW4gdG91Y2hMaXN0XFxuICAgIC8vIGVsc2UgcmV0dXJuIG9yaWdpbmFsIGV2ZW50XFxuICAgIHJldHVybiBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzW2V2dC50b3VjaGVzLmxlbmd0aCAtIDFdIDogZXZ0O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcG9pbnRlci1kYXRhLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb2ludGVyLWRhdGEuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9zaXRpb24uanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvc2l0aW9uLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBnZXRQb3NpdGlvbiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0dldFBvc2l0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImdldFBvc2l0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRQb3NpdGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9pbnRlcl9kYXRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldC1wb2ludGVyLWRhdGEgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvaW50ZXItZGF0YS5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEdldCBwb2ludGVyL2ZpbmdlciBwb3NpdGlvblxcbiAqL1xcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGV2dCkge1xcbiAgICB2YXIgZGF0YSA9IE9iamVjdChfZ2V0X3BvaW50ZXJfZGF0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJnZXRQb2ludGVyRGF0YVxcXCJdKShldnQpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgeDogZGF0YS5jbGllbnRYLFxcbiAgICAgICAgeTogZGF0YS5jbGllbnRZLFxcbiAgICB9O1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcG9zaXRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvZ2V0LXBvc2l0aW9uLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9pbmRleC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBldmVudFNjb3BlLCBjbGVhckV2ZW50c09uLCBnZXRQb2ludGVyRGF0YSwgZ2V0UG9zaXRpb24sIGlzT25lT2YsIHNldFN0eWxlLCBUcmFja2VyLCBUb3VjaFJlY29yZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0luZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRfaHViX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50LWh1YiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9ldmVudC1odWIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50U2NvcGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudF9odWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZXZlbnRTY29wZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsZWFyRXZlbnRzT25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudF9odWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiY2xlYXJFdmVudHNPblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldF9wb2ludGVyX2RhdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvaW50ZXItZGF0YSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9nZXQtcG9pbnRlci1kYXRhLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJnZXRQb2ludGVyRGF0YVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2dldF9wb2ludGVyX2RhdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZ2V0UG9pbnRlckRhdGFcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvc2l0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb3NpdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZ2V0UG9zaXRpb25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZ2V0UG9zaXRpb25cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19vbmVfb2ZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb25lLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNPbmVPZlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2lzX29uZV9vZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc09uZU9mXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2V0X3N0eWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NldC1zdHlsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInNldFN0eWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0X3N0eWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcInNldFN0eWxlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdG91Y2hfcmVjb3JkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvdWNoLXJlY29yZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90b3VjaF9yZWNvcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVHJhY2tlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvdWNoUmVjb3JkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdG91Y2hfcmVjb3JkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRvdWNoUmVjb3JkXFxcIl07IH0pO1xcblxcblxcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2luZGV4LmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvaXMtb25lLW9mLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogaXNPbmVPZiAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc0lzT25lT2ZKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaXNPbmVPZlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPbmVPZjsgfSk7XFxuLyoqXFxuICogQ2hlY2sgaWYgYGFgIGlzIG9uZSBvZiBgWy4uLmJdYFxcbiAqL1xcbmZ1bmN0aW9uIGlzT25lT2YoYSwgYikge1xcbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSBbXTsgfVxcbiAgICByZXR1cm4gYi5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBhID09PSB2OyB9KTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtb25lLW9mLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2lzLW9uZS1vZi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL3NldC1zdHlsZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldFN0eWxlICovXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1Ntb290aFNjcm9sbGJhclV0aWxzU2V0U3R5bGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic2V0U3R5bGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldFN0eWxlOyB9KTtcXG52YXIgVkVORE9SX1BSRUZJWCA9IFtcXG4gICAgJ3dlYmtpdCcsXFxuICAgICdtb3onLFxcbiAgICAnbXMnLFxcbiAgICAnbycsXFxuXTtcXG52YXIgUkUgPSBuZXcgUmVnRXhwKFxcXCJeLSg/ISg/OlxcXCIgKyBWRU5ET1JfUFJFRklYLmpvaW4oJ3wnKSArIFxcXCIpLSlcXFwiKTtcXG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlcykge1xcbiAgICB2YXIgcmVzID0ge307XFxuICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xcbiAgICAgICAgaWYgKCFSRS50ZXN0KHByb3ApKSB7XFxuICAgICAgICAgICAgcmVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB2YWwgPSBzdHlsZXNbcHJvcF07XFxuICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKC9eLS8sICcnKTtcXG4gICAgICAgIHJlc1twcm9wXSA9IHZhbDtcXG4gICAgICAgIFZFTkRPUl9QUkVGSVguZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XFxuICAgICAgICAgICAgcmVzW1xcXCItXFxcIiArIHByZWZpeCArIFxcXCItXFxcIiArIHByb3BdID0gdmFsO1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gcmVzO1xcbn1cXG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtLCBzdHlsZXMpIHtcXG4gICAgc3R5bGVzID0gYXV0b1ByZWZpeChzdHlsZXMpO1xcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcXG4gICAgICAgIHZhciBjc3NQcm9wID0gcHJvcC5yZXBsYWNlKC9eLS8sICcnKS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xcbiAgICAgICAgZWxlbS5zdHlsZVtjc3NQcm9wXSA9IHN0eWxlc1twcm9wXTtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldC1zdHlsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy9zZXQtc3R5bGUuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbGJhci91dGlscy90b3VjaC1yZWNvcmQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvdG91Y2gtcmVjb3JkLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBUcmFja2VyLCBUb3VjaFJlY29yZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNTbW9vdGhTY3JvbGxiYXJVdGlsc1RvdWNoUmVjb3JkSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyYWNrZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYWNrZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvdWNoUmVjb3JkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUb3VjaFJlY29yZDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRzbGliX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXBvc2l0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL3V0aWxzL2dldC1wb3NpdGlvbi5qc1xcXCIpO1xcblxcblxcbnZhciBUcmFja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBUcmFja2VyKHRvdWNoKSB7XFxuICAgICAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIHRoaXMuZGVsdGEgPSB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XFxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IE9iamVjdChfZ2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKHRvdWNoKTtcXG4gICAgfVxcbiAgICBUcmFja2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodG91Y2gpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHZlbG9jaXR5ID0gX2EudmVsb2NpdHksIHVwZGF0ZVRpbWUgPSBfYS51cGRhdGVUaW1lLCBsYXN0UG9zaXRpb24gPSBfYS5sYXN0UG9zaXRpb247XFxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IE9iamVjdChfZ2V0X3Bvc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImdldFBvc2l0aW9uXFxcIl0pKHRvdWNoKTtcXG4gICAgICAgIHZhciBkZWx0YSA9IHtcXG4gICAgICAgICAgICB4OiAtKHBvc2l0aW9uLnggLSBsYXN0UG9zaXRpb24ueCksXFxuICAgICAgICAgICAgeTogLShwb3NpdGlvbi55IC0gbGFzdFBvc2l0aW9uLnkpLFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IChub3cgLSB1cGRhdGVUaW1lKSB8fCAxNi43O1xcbiAgICAgICAgdmFyIHZ4ID0gZGVsdGEueCAvIGR1cmF0aW9uICogMTYuNztcXG4gICAgICAgIHZhciB2eSA9IGRlbHRhLnkgLyBkdXJhdGlvbiAqIDE2Ljc7XFxuICAgICAgICB2ZWxvY2l0eS54ID0gdnggKiB0aGlzLnZlbG9jaXR5TXVsdGlwbGllcjtcXG4gICAgICAgIHZlbG9jaXR5LnkgPSB2eSAqIHRoaXMudmVsb2NpdHlNdWx0aXBsaWVyO1xcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gbm93O1xcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgfTtcXG4gICAgcmV0dXJuIFRyYWNrZXI7XFxufSgpKTtcXG5cXG52YXIgVG91Y2hSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFRvdWNoUmVjb3JkKCkge1xcbiAgICAgICAgdGhpcy5fdG91Y2hMaXN0ID0ge307XFxuICAgIH1cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvdWNoUmVjb3JkLnByb3RvdHlwZSwgXFxcIl9wcmltaXRpdmVWYWx1ZVxcXCIsIHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVG91Y2hJRCAhPT0gdW5kZWZpbmVkO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0RGVsdGEgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdHJhY2tlciA9IHRoaXMuX2dldEFjdGl2ZVRyYWNrZXIoKTtcXG4gICAgICAgIGlmICghdHJhY2tlcikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRyYWNrZXIuZGVsdGEpO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdHJhY2tlciA9IHRoaXMuX2dldEFjdGl2ZVRyYWNrZXIoKTtcXG4gICAgICAgIGlmICghdHJhY2tlcikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBPYmplY3QodHNsaWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiX19hc3NpZ25cXFwiXSkoe30sIHRyYWNrZXIudmVsb2NpdHkpO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuZ2V0RWFzaW5nRGlzdGFuY2UgPSBmdW5jdGlvbiAoZGFtcGluZykge1xcbiAgICAgICAgdmFyIGRlQWNjZWxlcmF0aW9uID0gMSAtIGRhbXBpbmc7XFxuICAgICAgICB2YXIgZGlzdGFuY2UgPSB7XFxuICAgICAgICAgICAgeDogMCxcXG4gICAgICAgICAgICB5OiAwLFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciB2ZWwgPSB0aGlzLmdldFZlbG9jaXR5KCk7XFxuICAgICAgICBPYmplY3Qua2V5cyh2ZWwpLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzbWFsbCB2ZWxvY2l0eVxcbiAgICAgICAgICAgIHZhciB2ID0gTWF0aC5hYnModmVsW2Rpcl0pIDw9IDEwID8gMCA6IHZlbFtkaXJdO1xcbiAgICAgICAgICAgIHdoaWxlICh2ICE9PSAwKSB7XFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlW2Rpcl0gKz0gdjtcXG4gICAgICAgICAgICAgICAgdiA9ICh2ICogZGVBY2NlbGVyYXRpb24pIHwgMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZXZ0LnRhcmdldFRvdWNoZXM7XFxuICAgICAgICBBcnJheS5mcm9tKHRhcmdldFRvdWNoZXMpLmZvckVhY2goZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2FkZCh0b3VjaCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaExpc3Q7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldnQudG91Y2hlcywgY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XFxuICAgICAgICBBcnJheS5mcm9tKHRvdWNoZXMpLmZvckVhY2goZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX3JlbmV3KHRvdWNoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSUQoY2hhbmdlZFRvdWNoZXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTGlzdDtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FjdGl2ZVRvdWNoSUQ7XFxuICAgICAgICBBcnJheS5mcm9tKGV2dC5jaGFuZ2VkVG91Y2hlcykuZm9yRWFjaChmdW5jdGlvbiAodG91Y2gpIHtcXG4gICAgICAgICAgICBfdGhpcy5fZGVsZXRlKHRvdWNoKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgaWYgKHRoaXMuX2hhcyh0b3VjaCkpIHtcXG4gICAgICAgICAgICAvLyByZXNldCB0cmFja2VyXFxuICAgICAgICAgICAgdGhpcy5fZGVsZXRlKHRvdWNoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0cmFja2VyID0gbmV3IFRyYWNrZXIodG91Y2gpO1xcbiAgICAgICAgdGhpcy5fdG91Y2hMaXN0W3RvdWNoLmlkZW50aWZpZXJdID0gdHJhY2tlcjtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLl9yZW5ldyA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgaWYgKCF0aGlzLl9oYXModG91Y2gpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB0aGlzLl90b3VjaExpc3RbdG91Y2guaWRlbnRpZmllcl07XFxuICAgICAgICB0cmFja2VyLnVwZGF0ZSh0b3VjaCk7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS5fZGVsZXRlID0gZnVuY3Rpb24gKHRvdWNoKSB7XFxuICAgICAgICBkZWxldGUgdGhpcy5fdG91Y2hMaXN0W3RvdWNoLmlkZW50aWZpZXJdO1xcbiAgICB9O1xcbiAgICBUb3VjaFJlY29yZC5wcm90b3R5cGUuX2hhcyA9IGZ1bmN0aW9uICh0b3VjaCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTGlzdC5oYXNPd25Qcm9wZXJ0eSh0b3VjaC5pZGVudGlmaWVyKTtcXG4gICAgfTtcXG4gICAgVG91Y2hSZWNvcmQucHJvdG90eXBlLl9zZXRBY3RpdmVJRCA9IGZ1bmN0aW9uICh0b3VjaGVzKSB7XFxuICAgICAgICB0aGlzLl9hY3RpdmVUb3VjaElEID0gdG91Y2hlc1t0b3VjaGVzLmxlbmd0aCAtIDFdLmlkZW50aWZpZXI7XFxuICAgIH07XFxuICAgIFRvdWNoUmVjb3JkLnByb3RvdHlwZS5fZ2V0QWN0aXZlVHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF90b3VjaExpc3QgPSBfYS5fdG91Y2hMaXN0LCBfYWN0aXZlVG91Y2hJRCA9IF9hLl9hY3RpdmVUb3VjaElEO1xcbiAgICAgICAgcmV0dXJuIF90b3VjaExpc3RbX2FjdGl2ZVRvdWNoSURdO1xcbiAgICB9O1xcbiAgICByZXR1cm4gVG91Y2hSZWNvcmQ7XFxufSgpKTtcXG5cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3VjaC1yZWNvcmQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGxiYXIvdXRpbHMvdG91Y2gtcmVjb3JkLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3Rpbnktc2xpZGVyL2Rpc3QvdGlueS1zbGlkZXIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvdGlueS1zbGlkZXIvZGlzdC90aW55LXNsaWRlci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNUaW55U2xpZGVyRGlzdFRpbnlTbGlkZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xcblxcbnZhciB3aW4kMSA9IHdpbmRvdztcXG52YXIgcmFmID0gd2luJDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbiQxLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW4kMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luJDEubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNiKSB7XFxuICByZXR1cm4gc2V0VGltZW91dChjYiwgMTYpO1xcbn07XFxuXFxudmFyIHdpbiA9IHdpbmRvdztcXG52YXIgY2FmID0gd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbi5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoaWQpIHtcXG4gIGNsZWFyVGltZW91dChpZCk7XFxufTtcXG5cXG5mdW5jdGlvbiBleHRlbmQoKSB7XFxuICB2YXIgb2JqLFxcbiAgICAgIG5hbWUsXFxuICAgICAgY29weSxcXG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXFxuICAgICAgaSA9IDEsXFxuICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG5cXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKChvYmogPSBhcmd1bWVudHNbaV0pICE9PSBudWxsKSB7XFxuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xcbiAgICAgICAgY29weSA9IG9ialtuYW1lXTtcXG5cXG4gICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRhcmdldDtcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tTdG9yYWdlVmFsdWUodmFsdWUpIHtcXG4gIHJldHVybiBbJ3RydWUnLCAnZmFsc2UnXS5pbmRleE9mKHZhbHVlKSA+PSAwID8gSlNPTi5wYXJzZSh2YWx1ZSkgOiB2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlKHN0b3JhZ2UsIGtleSwgdmFsdWUsIGFjY2Vzcykge1xcbiAgaWYgKGFjY2Vzcykge1xcbiAgICB0cnkge1xcbiAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcXG4gICAgfSBjYXRjaCAoZSkge31cXG4gIH1cXG5cXG4gIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0U2xpZGVJZCgpIHtcXG4gIHZhciBpZCA9IHdpbmRvdy50bnNJZDtcXG4gIHdpbmRvdy50bnNJZCA9ICFpZCA/IDEgOiBpZCArIDE7XFxuICByZXR1cm4gJ3RucycgKyB3aW5kb3cudG5zSWQ7XFxufVxcblxcbmZ1bmN0aW9uIGdldEJvZHkoKSB7XFxuICB2YXIgZG9jID0gZG9jdW1lbnQsXFxuICAgICAgYm9keSA9IGRvYy5ib2R5O1xcblxcbiAgaWYgKCFib2R5KSB7XFxuICAgIGJvZHkgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm9keScpO1xcbiAgICBib2R5LmZha2UgPSB0cnVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGJvZHk7XFxufVxcblxcbnZhciBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcbmZ1bmN0aW9uIHNldEZha2VCb2R5KGJvZHkpIHtcXG4gIHZhciBkb2NPdmVyZmxvdyA9ICcnO1xcblxcbiAgaWYgKGJvZHkuZmFrZSkge1xcbiAgICBkb2NPdmVyZmxvdyA9IGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3c7IC8vYXZvaWQgY3Jhc2hpbmcgSUU4LCBpZiBiYWNrZ3JvdW5kIGltYWdlIGlzIHVzZWRcXG5cXG4gICAgYm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7IC8vU2FmYXJpIDUuMTMvNS4xLjQgT1NYIHN0b3BzIGxvYWRpbmcgaWYgOjotd2Via2l0LXNjcm9sbGJhciBpcyB1c2VkIGFuZCBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlXFxuXFxuICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSBkb2NFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XFxuICAgIGRvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoYm9keSk7XFxuICB9XFxuXFxuICByZXR1cm4gZG9jT3ZlcmZsb3c7XFxufVxcblxcbmZ1bmN0aW9uIHJlc2V0RmFrZUJvZHkoYm9keSwgZG9jT3ZlcmZsb3cpIHtcXG4gIGlmIChib2R5LmZha2UpIHtcXG4gICAgYm9keS5yZW1vdmUoKTtcXG4gICAgZG9jRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IGRvY092ZXJmbG93OyAvLyBUcmlnZ2VyIGxheW91dCBzbyBraW5ldGljIHNjcm9sbGluZyBpc24ndCBkaXNhYmxlZCBpbiBpT1M2K1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcXG5cXG4gICAgZG9jRWxlbWVudC5vZmZzZXRIZWlnaHQ7XFxuICB9XFxufVxcblxcbi8vIGdldCBjc3MtY2FsYyBcXG5mdW5jdGlvbiBjYWxjKCkge1xcbiAgdmFyIGRvYyA9IGRvY3VtZW50LFxcbiAgICAgIGJvZHkgPSBnZXRCb2R5KCksXFxuICAgICAgZG9jT3ZlcmZsb3cgPSBzZXRGYWtlQm9keShib2R5KSxcXG4gICAgICBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuICBib2R5LmFwcGVuZENoaWxkKGRpdik7XFxuXFxuICB0cnkge1xcbiAgICB2YXIgc3RyID0gJygxMHB4ICogMTApJyxcXG4gICAgICAgIHZhbHMgPSBbJ2NhbGMnICsgc3RyLCAnLW1vei1jYWxjJyArIHN0ciwgJy13ZWJraXQtY2FsYycgKyBzdHJdLFxcbiAgICAgICAgdmFsO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xcbiAgICAgIHZhbCA9IHZhbHNbaV07XFxuICAgICAgZGl2LnN0eWxlLndpZHRoID0gdmFsO1xcblxcbiAgICAgIGlmIChkaXYub2Zmc2V0V2lkdGggPT09IDEwMCkge1xcbiAgICAgICAgcmVzdWx0ID0gdmFsLnJlcGxhY2Uoc3RyLCAnJyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGUpIHt9XFxuXFxuICBib2R5LmZha2UgPyByZXNldEZha2VCb2R5KGJvZHksIGRvY092ZXJmbG93KSA6IGRpdi5yZW1vdmUoKTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbi8vIGdldCBzdWJwaXhlbCBzdXBwb3J0IHZhbHVlXFxuZnVuY3Rpb24gcGVyY2VudGFnZUxheW91dCgpIHtcXG4gIC8vIGNoZWNrIHN1YnBpeGVsIGxheW91dCBzdXBwb3J0aW5nXFxuICB2YXIgZG9jID0gZG9jdW1lbnQsXFxuICAgICAgYm9keSA9IGdldEJvZHkoKSxcXG4gICAgICBkb2NPdmVyZmxvdyA9IHNldEZha2VCb2R5KGJvZHkpLFxcbiAgICAgIHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxuICAgICAgb3V0ZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxuICAgICAgc3RyID0gJycsXFxuICAgICAgY291bnQgPSA3MCxcXG4gICAgICBwZXJQYWdlID0gMyxcXG4gICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcXG4gIHdyYXBwZXIuY2xhc3NOYW1lID0gXFxcInRucy10LXN1YnAyXFxcIjtcXG4gIG91dGVyLmNsYXNzTmFtZSA9IFxcXCJ0bnMtdC1jdFxcXCI7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcXG4gICAgc3RyICs9ICc8ZGl2PjwvZGl2Pic7XFxuICB9XFxuXFxuICBvdXRlci5pbm5lckhUTUwgPSBzdHI7XFxuICB3cmFwcGVyLmFwcGVuZENoaWxkKG91dGVyKTtcXG4gIGJvZHkuYXBwZW5kQ2hpbGQod3JhcHBlcik7XFxuICBzdXBwb3J0ZWQgPSBNYXRoLmFicyh3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBvdXRlci5jaGlsZHJlbltjb3VudCAtIHBlclBhZ2VdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIDwgMjtcXG4gIGJvZHkuZmFrZSA/IHJlc2V0RmFrZUJvZHkoYm9keSwgZG9jT3ZlcmZsb3cpIDogd3JhcHBlci5yZW1vdmUoKTtcXG4gIHJldHVybiBzdXBwb3J0ZWQ7XFxufVxcblxcbmZ1bmN0aW9uIG1lZGlhcXVlcnlTdXBwb3J0KCkge1xcbiAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhIHx8IHdpbmRvdy5tc01hdGNoTWVkaWEpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICB2YXIgZG9jID0gZG9jdW1lbnQsXFxuICAgICAgYm9keSA9IGdldEJvZHkoKSxcXG4gICAgICBkb2NPdmVyZmxvdyA9IHNldEZha2VCb2R5KGJvZHkpLFxcbiAgICAgIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXG4gICAgICBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxcbiAgICAgIHJ1bGUgPSAnQG1lZGlhIGFsbCBhbmQgKG1pbi13aWR0aDoxcHgpey50bnMtbXEtdGVzdHtwb3NpdGlvbjphYnNvbHV0ZX19JyxcXG4gICAgICBwb3NpdGlvbjtcXG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xcbiAgZGl2LmNsYXNzTmFtZSA9ICd0bnMtbXEtdGVzdCc7XFxuICBib2R5LmFwcGVuZENoaWxkKHN0eWxlKTtcXG4gIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcXG5cXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XFxuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJ1bGU7XFxuICB9IGVsc2Uge1xcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUocnVsZSkpO1xcbiAgfVxcblxcbiAgcG9zaXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdikucG9zaXRpb24gOiBkaXYuY3VycmVudFN0eWxlWydwb3NpdGlvbiddO1xcbiAgYm9keS5mYWtlID8gcmVzZXRGYWtlQm9keShib2R5LCBkb2NPdmVyZmxvdykgOiBkaXYucmVtb3ZlKCk7XFxuICByZXR1cm4gcG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCI7XFxufVxcblxcbi8vIGNyZWF0ZSBhbmQgYXBwZW5kIHN0eWxlIHNoZWV0XFxuZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldChtZWRpYSwgbm9uY2UpIHtcXG4gIC8vIENyZWF0ZSB0aGUgPHN0eWxlPiB0YWdcXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7IC8vIHN0eWxlLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJ0ZXh0L2Nzc1xcXCIpO1xcbiAgLy8gQWRkIGEgbWVkaWEgKGFuZC9vciBtZWRpYSBxdWVyeSkgaGVyZSBpZiB5b3UnZCBsaWtlIVxcbiAgLy8gc3R5bGUuc2V0QXR0cmlidXRlKFxcXCJtZWRpYVxcXCIsIFxcXCJzY3JlZW5cXFwiKVxcbiAgLy8gc3R5bGUuc2V0QXR0cmlidXRlKFxcXCJtZWRpYVxcXCIsIFxcXCJvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aCA6IDEwMjRweClcXFwiKVxcblxcbiAgaWYgKG1lZGlhKSB7XFxuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcXFwibWVkaWFcXFwiLCBtZWRpYSk7XFxuICB9IC8vIEFkZCBub25jZSBhdHRyaWJ1dGUgZm9yIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5XFxuXFxuXFxuICBpZiAobm9uY2UpIHtcXG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKFxcXCJub25jZVxcXCIsIG5vbmNlKTtcXG4gIH0gLy8gV2ViS2l0IGhhY2sgOihcXG4gIC8vIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJcXFwiKSk7XFxuICAvLyBBZGQgdGhlIDxzdHlsZT4gZWxlbWVudCB0byB0aGUgcGFnZVxcblxcblxcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpLmFwcGVuZENoaWxkKHN0eWxlKTtcXG4gIHJldHVybiBzdHlsZS5zaGVldCA/IHN0eWxlLnNoZWV0IDogc3R5bGUuc3R5bGVTaGVldDtcXG59XFxuXFxuLy8gY3Jvc3MgYnJvd3NlcnMgYWRkUnVsZSBtZXRob2RcXG5mdW5jdGlvbiBhZGRDU1NSdWxlKHNoZWV0LCBzZWxlY3RvciwgcnVsZXMsIGluZGV4KSB7XFxuICAvLyByZXR1cm4gcmFmKGZ1bmN0aW9uKCkge1xcbiAgJ2luc2VydFJ1bGUnIGluIHNoZWV0ID8gc2hlZXQuaW5zZXJ0UnVsZShzZWxlY3RvciArICd7JyArIHJ1bGVzICsgJ30nLCBpbmRleCkgOiBzaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBydWxlcywgaW5kZXgpOyAvLyB9KTtcXG59XFxuXFxuLy8gY3Jvc3MgYnJvd3NlcnMgYWRkUnVsZSBtZXRob2RcXG5mdW5jdGlvbiByZW1vdmVDU1NSdWxlKHNoZWV0LCBpbmRleCkge1xcbiAgLy8gcmV0dXJuIHJhZihmdW5jdGlvbigpIHtcXG4gICdkZWxldGVSdWxlJyBpbiBzaGVldCA/IHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpIDogc2hlZXQucmVtb3ZlUnVsZShpbmRleCk7IC8vIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRDc3NSdWxlc0xlbmd0aChzaGVldCkge1xcbiAgdmFyIHJ1bGUgPSAnaW5zZXJ0UnVsZScgaW4gc2hlZXQgPyBzaGVldC5jc3NSdWxlcyA6IHNoZWV0LnJ1bGVzO1xcbiAgcmV0dXJuIHJ1bGUubGVuZ3RoO1xcbn1cXG5cXG5mdW5jdGlvbiB0b0RlZ3JlZSh5LCB4KSB7XFxuICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqICgxODAgLyBNYXRoLlBJKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0VG91Y2hEaXJlY3Rpb24oYW5nbGUsIHJhbmdlKSB7XFxuICB2YXIgZGlyZWN0aW9uID0gZmFsc2UsXFxuICAgICAgZ2FwID0gTWF0aC5hYnMoOTAgLSBNYXRoLmFicyhhbmdsZSkpO1xcblxcbiAgaWYgKGdhcCA+PSA5MCAtIHJhbmdlKSB7XFxuICAgIGRpcmVjdGlvbiA9ICdob3Jpem9udGFsJztcXG4gIH0gZWxzZSBpZiAoZ2FwIDw9IHJhbmdlKSB7XFxuICAgIGRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCc7XFxuICB9XFxuXFxuICByZXR1cm4gZGlyZWN0aW9uO1xcbn1cXG5cXG4vLyBodHRwczovL3RvZGRtb3R0by5jb20vZGl0Y2gtdGhlLWFycmF5LWZvcmVhY2gtY2FsbC1ub2RlbGlzdC1oYWNrL1xcbmZ1bmN0aW9uIGZvckVhY2goYXJyLCBjYWxsYmFjaywgc2NvcGUpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJbaV0sIGkpO1xcbiAgfVxcbn1cXG5cXG52YXIgY2xhc3NMaXN0U3VwcG9ydCA9ICgnY2xhc3NMaXN0JyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdfJykpO1xcblxcbnZhciBoYXNDbGFzcyA9IGNsYXNzTGlzdFN1cHBvcnQgPyBmdW5jdGlvbiAoZWwsIHN0cikge1xcbiAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhzdHIpO1xcbn0gOiBmdW5jdGlvbiAoZWwsIHN0cikge1xcbiAgcmV0dXJuIGVsLmNsYXNzTmFtZS5pbmRleE9mKHN0cikgPj0gMDtcXG59O1xcblxcbnZhciBhZGRDbGFzcyA9IGNsYXNzTGlzdFN1cHBvcnQgPyBmdW5jdGlvbiAoZWwsIHN0cikge1xcbiAgaWYgKCFoYXNDbGFzcyhlbCwgc3RyKSkge1xcbiAgICBlbC5jbGFzc0xpc3QuYWRkKHN0cik7XFxuICB9XFxufSA6IGZ1bmN0aW9uIChlbCwgc3RyKSB7XFxuICBpZiAoIWhhc0NsYXNzKGVsLCBzdHIpKSB7XFxuICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBzdHI7XFxuICB9XFxufTtcXG5cXG52YXIgcmVtb3ZlQ2xhc3MgPSBjbGFzc0xpc3RTdXBwb3J0ID8gZnVuY3Rpb24gKGVsLCBzdHIpIHtcXG4gIGlmIChoYXNDbGFzcyhlbCwgc3RyKSkge1xcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKHN0cik7XFxuICB9XFxufSA6IGZ1bmN0aW9uIChlbCwgc3RyKSB7XFxuICBpZiAoaGFzQ2xhc3MoZWwsIHN0cikpIHtcXG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2Uoc3RyLCAnJyk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBoYXNBdHRyKGVsLCBhdHRyKSB7XFxuICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKGF0dHIpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRBdHRyKGVsLCBhdHRyKSB7XFxuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xcbn1cXG5cXG5mdW5jdGlvbiBpc05vZGVMaXN0KGVsKSB7XFxuICAvLyBPbmx5IE5vZGVMaXN0IGhhcyB0aGUgXFxcIml0ZW0oKVxcXCIgZnVuY3Rpb25cXG4gIHJldHVybiB0eXBlb2YgZWwuaXRlbSAhPT0gXFxcInVuZGVmaW5lZFxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIHNldEF0dHJzKGVscywgYXR0cnMpIHtcXG4gIGVscyA9IGlzTm9kZUxpc3QoZWxzKSB8fCBlbHMgaW5zdGFuY2VvZiBBcnJheSA/IGVscyA6IFtlbHNdO1xcblxcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhdHRycykgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSBlbHMubGVuZ3RoOyBpLS07KSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xcbiAgICAgIGVsc1tpXS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVBdHRycyhlbHMsIGF0dHJzKSB7XFxuICBlbHMgPSBpc05vZGVMaXN0KGVscykgfHwgZWxzIGluc3RhbmNlb2YgQXJyYXkgPyBlbHMgOiBbZWxzXTtcXG4gIGF0dHJzID0gYXR0cnMgaW5zdGFuY2VvZiBBcnJheSA/IGF0dHJzIDogW2F0dHJzXTtcXG4gIHZhciBhdHRyTGVuZ3RoID0gYXR0cnMubGVuZ3RoO1xcblxcbiAgZm9yICh2YXIgaSA9IGVscy5sZW5ndGg7IGktLTspIHtcXG4gICAgZm9yICh2YXIgaiA9IGF0dHJMZW5ndGg7IGotLTspIHtcXG4gICAgICBlbHNbaV0ucmVtb3ZlQXR0cmlidXRlKGF0dHJzW2pdKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhcnJheUZyb21Ob2RlTGlzdChubCkge1xcbiAgdmFyIGFyciA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBubC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgYXJyLnB1c2gobmxbaV0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGFycjtcXG59XFxuXFxuZnVuY3Rpb24gaGlkZUVsZW1lbnQoZWwsIGZvcmNlSGlkZSkge1xcbiAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzaG93RWxlbWVudChlbCwgZm9yY2VIaWRlKSB7XFxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XFxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNWaXNpYmxlKGVsKSB7XFxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkgIT09ICdub25lJztcXG59XFxuXFxuZnVuY3Rpb24gd2hpY2hQcm9wZXJ0eShwcm9wcykge1xcbiAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIGFyciA9IFtwcm9wc10sXFxuICAgICAgICBQcm9wcyA9IHByb3BzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcHMuc3Vic3RyKDEpLFxcbiAgICAgICAgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnLCAnTyddO1xcbiAgICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcXG4gICAgICBpZiAocHJlZml4ICE9PSAnbXMnIHx8IHByb3BzID09PSAndHJhbnNmb3JtJykge1xcbiAgICAgICAgYXJyLnB1c2gocHJlZml4ICsgUHJvcHMpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHByb3BzID0gYXJyO1xcbiAgfVxcblxcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmFrZWVsZW1lbnQnKTtcXG4gICAgICBwcm9wcy5sZW5ndGg7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XFxuXFxuICAgIGlmIChlbC5zdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIHByb3A7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTsgLy8gZXhwbGljaXQgZm9yIGllOS1cXG59XFxuXFxuZnVuY3Rpb24gaGFzM0RUcmFuc2Zvcm1zKHRmKSB7XFxuICBpZiAoIXRmKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGlmICghd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIGRvYyA9IGRvY3VtZW50LFxcbiAgICAgIGJvZHkgPSBnZXRCb2R5KCksXFxuICAgICAgZG9jT3ZlcmZsb3cgPSBzZXRGYWtlQm9keShib2R5KSxcXG4gICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdwJyksXFxuICAgICAgaGFzM2QsXFxuICAgICAgY3NzVEYgPSB0Zi5sZW5ndGggPiA5ID8gJy0nICsgdGYuc2xpY2UoMCwgLTkpLnRvTG93ZXJDYXNlKCkgKyAnLScgOiAnJztcXG4gIGNzc1RGICs9ICd0cmFuc2Zvcm0nOyAvLyBBZGQgaXQgdG8gdGhlIGJvZHkgdG8gZ2V0IHRoZSBjb21wdXRlZCBzdHlsZVxcblxcbiAgYm9keS5pbnNlcnRCZWZvcmUoZWwsIG51bGwpO1xcbiAgZWwuc3R5bGVbdGZdID0gJ3RyYW5zbGF0ZTNkKDFweCwxcHgsMXB4KSc7XFxuICBoYXMzZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKGNzc1RGKTtcXG4gIGJvZHkuZmFrZSA/IHJlc2V0RmFrZUJvZHkoYm9keSwgZG9jT3ZlcmZsb3cpIDogZWwucmVtb3ZlKCk7XFxuICByZXR1cm4gaGFzM2QgIT09IHVuZGVmaW5lZCAmJiBoYXMzZC5sZW5ndGggPiAwICYmIGhhczNkICE9PSBcXFwibm9uZVxcXCI7XFxufVxcblxcbi8vIGdldCB0cmFuc2l0aW9uZW5kLCBhbmltYXRpb25lbmQgYmFzZWQgb24gdHJhbnNpdGlvbkR1cmF0aW9uXFxuLy8gQHByb3Bpbjogc3RyaW5nXFxuLy8gQHByb3BPdXQ6IHN0cmluZywgZmlyc3QtbGV0dGVyIHVwcGVyY2FzZVxcbi8vIFVzYWdlOiBnZXRFbmRQcm9wZXJ0eSgnV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJywgJ1RyYW5zaXRpb24nKSA9PiB3ZWJraXRUcmFuc2l0aW9uRW5kXFxuZnVuY3Rpb24gZ2V0RW5kUHJvcGVydHkocHJvcEluLCBwcm9wT3V0KSB7XFxuICB2YXIgZW5kUHJvcCA9IGZhbHNlO1xcblxcbiAgaWYgKC9eV2Via2l0Ly50ZXN0KHByb3BJbikpIHtcXG4gICAgZW5kUHJvcCA9ICd3ZWJraXQnICsgcHJvcE91dCArICdFbmQnO1xcbiAgfSBlbHNlIGlmICgvXk8vLnRlc3QocHJvcEluKSkge1xcbiAgICBlbmRQcm9wID0gJ28nICsgcHJvcE91dCArICdFbmQnO1xcbiAgfSBlbHNlIGlmIChwcm9wSW4pIHtcXG4gICAgZW5kUHJvcCA9IHByb3BPdXQudG9Mb3dlckNhc2UoKSArICdlbmQnO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVuZFByb3A7XFxufVxcblxcbi8vIFRlc3QgdmlhIGEgZ2V0dGVyIGluIHRoZSBvcHRpb25zIG9iamVjdCB0byBzZWUgaWYgdGhlIHBhc3NpdmUgcHJvcGVydHkgaXMgYWNjZXNzZWRcXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XFxuXFxudHJ5IHtcXG4gIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSk7XFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwidGVzdFxcXCIsIG51bGwsIG9wdHMpO1xcbn0gY2F0Y2ggKGUpIHt9XFxuXFxudmFyIHBhc3NpdmVPcHRpb24gPSBzdXBwb3J0c1Bhc3NpdmUgPyB7XFxuICBwYXNzaXZlOiB0cnVlXFxufSA6IGZhbHNlO1xcblxcbmZ1bmN0aW9uIGFkZEV2ZW50cyhlbCwgb2JqLCBwcmV2ZW50U2Nyb2xsaW5nKSB7XFxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xcbiAgICB2YXIgb3B0aW9uID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddLmluZGV4T2YocHJvcCkgPj0gMCAmJiAhcHJldmVudFNjcm9sbGluZyA/IHBhc3NpdmVPcHRpb24gOiBmYWxzZTtcXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihwcm9wLCBvYmpbcHJvcF0sIG9wdGlvbik7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50cyhlbCwgb2JqKSB7XFxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xcbiAgICB2YXIgb3B0aW9uID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddLmluZGV4T2YocHJvcCkgPj0gMCA/IHBhc3NpdmVPcHRpb24gOiBmYWxzZTtcXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwcm9wLCBvYmpbcHJvcF0sIG9wdGlvbik7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIEV2ZW50cygpIHtcXG4gIHJldHVybiB7XFxuICAgIHRvcGljczoge30sXFxuICAgIG9uOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBmbikge1xcbiAgICAgIHRoaXMudG9waWNzW2V2ZW50TmFtZV0gPSB0aGlzLnRvcGljc1tldmVudE5hbWVdIHx8IFtdO1xcbiAgICAgIHRoaXMudG9waWNzW2V2ZW50TmFtZV0ucHVzaChmbik7XFxuICAgIH0sXFxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZm4pIHtcXG4gICAgICBpZiAodGhpcy50b3BpY3NbZXZlbnROYW1lXSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvcGljc1tldmVudE5hbWVdLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmICh0aGlzLnRvcGljc1tldmVudE5hbWVdW2ldID09PSBmbikge1xcbiAgICAgICAgICAgIHRoaXMudG9waWNzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBlbWl0OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XFxuICAgICAgZGF0YS50eXBlID0gZXZlbnROYW1lO1xcblxcbiAgICAgIGlmICh0aGlzLnRvcGljc1tldmVudE5hbWVdKSB7XFxuICAgICAgICB0aGlzLnRvcGljc1tldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICAgIGZuKGRhdGEsIGV2ZW50TmFtZSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIGpzVHJhbnNmb3JtKGVsZW1lbnQsIGF0dHIsIHByZWZpeCwgcG9zdGZpeCwgdG8sIGR1cmF0aW9uLCBjYWxsYmFjaykge1xcbiAgdmFyIHRpY2sgPSBNYXRoLm1pbihkdXJhdGlvbiwgMTApLFxcbiAgICAgIHVuaXQgPSB0by5pbmRleE9mKCclJykgPj0gMCA/ICclJyA6ICdweCcsXFxuICAgICAgdG8gPSB0by5yZXBsYWNlKHVuaXQsICcnKSxcXG4gICAgICBmcm9tID0gTnVtYmVyKGVsZW1lbnQuc3R5bGVbYXR0cl0ucmVwbGFjZShwcmVmaXgsICcnKS5yZXBsYWNlKHBvc3RmaXgsICcnKS5yZXBsYWNlKHVuaXQsICcnKSksXFxuICAgICAgcG9zaXRpb25UaWNrID0gKHRvIC0gZnJvbSkgLyBkdXJhdGlvbiAqIHRpY2s7XFxuICBzZXRUaW1lb3V0KG1vdmVFbGVtZW50LCB0aWNrKTtcXG5cXG4gIGZ1bmN0aW9uIG1vdmVFbGVtZW50KCkge1xcbiAgICBkdXJhdGlvbiAtPSB0aWNrO1xcbiAgICBmcm9tICs9IHBvc2l0aW9uVGljaztcXG4gICAgZWxlbWVudC5zdHlsZVthdHRyXSA9IHByZWZpeCArIGZyb20gKyB1bml0ICsgcG9zdGZpeDtcXG5cXG4gICAgaWYgKGR1cmF0aW9uID4gMCkge1xcbiAgICAgIHNldFRpbWVvdXQobW92ZUVsZW1lbnQsIHRpY2spO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxiYWNrKCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gT2JqZWN0LmtleXNcXG5pZiAoIU9iamVjdC5rZXlzKSB7XFxuICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgdmFyIGtleXMgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcXG4gICAgICAgIGtleXMucHVzaChuYW1lKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGtleXM7XFxuICB9O1xcbn0gLy8gQ2hpbGROb2RlLnJlbW92ZVxcblxcblxcbmlmICghKFxcXCJyZW1vdmVcXFwiIGluIEVsZW1lbnQucHJvdG90eXBlKSkge1xcbiAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XFxuICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xcbiAgICB9XFxuICB9O1xcbn1cXG52YXIgdG5zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBleHRlbmQoe1xcbiAgICBjb250YWluZXI6ICcuc2xpZGVyJyxcXG4gICAgbW9kZTogJ2Nhcm91c2VsJyxcXG4gICAgYXhpczogJ2hvcml6b250YWwnLFxcbiAgICBpdGVtczogMSxcXG4gICAgZ3V0dGVyOiAwLFxcbiAgICBlZGdlUGFkZGluZzogMCxcXG4gICAgZml4ZWRXaWR0aDogZmFsc2UsXFxuICAgIGF1dG9XaWR0aDogZmFsc2UsXFxuICAgIHZpZXdwb3J0TWF4OiBmYWxzZSxcXG4gICAgc2xpZGVCeTogMSxcXG4gICAgY2VudGVyOiBmYWxzZSxcXG4gICAgY29udHJvbHM6IHRydWUsXFxuICAgIGNvbnRyb2xzUG9zaXRpb246ICd0b3AnLFxcbiAgICBjb250cm9sc1RleHQ6IFsncHJldicsICduZXh0J10sXFxuICAgIGNvbnRyb2xzQ29udGFpbmVyOiBmYWxzZSxcXG4gICAgcHJldkJ1dHRvbjogZmFsc2UsXFxuICAgIG5leHRCdXR0b246IGZhbHNlLFxcbiAgICBuYXY6IHRydWUsXFxuICAgIG5hdlBvc2l0aW9uOiAndG9wJyxcXG4gICAgbmF2Q29udGFpbmVyOiBmYWxzZSxcXG4gICAgbmF2QXNUaHVtYm5haWxzOiBmYWxzZSxcXG4gICAgYXJyb3dLZXlzOiBmYWxzZSxcXG4gICAgc3BlZWQ6IDMwMCxcXG4gICAgYXV0b3BsYXk6IGZhbHNlLFxcbiAgICBhdXRvcGxheVBvc2l0aW9uOiAndG9wJyxcXG4gICAgYXV0b3BsYXlUaW1lb3V0OiA1MDAwLFxcbiAgICBhdXRvcGxheURpcmVjdGlvbjogJ2ZvcndhcmQnLFxcbiAgICBhdXRvcGxheVRleHQ6IFsnc3RhcnQnLCAnc3RvcCddLFxcbiAgICBhdXRvcGxheUhvdmVyUGF1c2U6IGZhbHNlLFxcbiAgICBhdXRvcGxheUJ1dHRvbjogZmFsc2UsXFxuICAgIGF1dG9wbGF5QnV0dG9uT3V0cHV0OiB0cnVlLFxcbiAgICBhdXRvcGxheVJlc2V0T25WaXNpYmlsaXR5OiB0cnVlLFxcbiAgICBhbmltYXRlSW46ICd0bnMtZmFkZUluJyxcXG4gICAgYW5pbWF0ZU91dDogJ3Rucy1mYWRlT3V0JyxcXG4gICAgYW5pbWF0ZU5vcm1hbDogJ3Rucy1ub3JtYWwnLFxcbiAgICBhbmltYXRlRGVsYXk6IGZhbHNlLFxcbiAgICBsb29wOiB0cnVlLFxcbiAgICByZXdpbmQ6IGZhbHNlLFxcbiAgICBhdXRvSGVpZ2h0OiBmYWxzZSxcXG4gICAgcmVzcG9uc2l2ZTogZmFsc2UsXFxuICAgIGxhenlsb2FkOiBmYWxzZSxcXG4gICAgbGF6eWxvYWRTZWxlY3RvcjogJy50bnMtbGF6eS1pbWcnLFxcbiAgICB0b3VjaDogdHJ1ZSxcXG4gICAgbW91c2VEcmFnOiBmYWxzZSxcXG4gICAgc3dpcGVBbmdsZTogMTUsXFxuICAgIG5lc3RlZDogZmFsc2UsXFxuICAgIHByZXZlbnRBY3Rpb25XaGVuUnVubmluZzogZmFsc2UsXFxuICAgIHByZXZlbnRTY3JvbGxPblRvdWNoOiBmYWxzZSxcXG4gICAgZnJlZXphYmxlOiB0cnVlLFxcbiAgICBvbkluaXQ6IGZhbHNlLFxcbiAgICB1c2VMb2NhbFN0b3JhZ2U6IHRydWUsXFxuICAgIG5vbmNlOiBmYWxzZVxcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XFxuICB2YXIgZG9jID0gZG9jdW1lbnQsXFxuICAgICAgd2luID0gd2luZG93LFxcbiAgICAgIEtFWVMgPSB7XFxuICAgIEVOVEVSOiAxMyxcXG4gICAgU1BBQ0U6IDMyLFxcbiAgICBMRUZUOiAzNyxcXG4gICAgUklHSFQ6IDM5XFxuICB9LFxcbiAgICAgIHRuc1N0b3JhZ2UgPSB7fSxcXG4gICAgICBsb2NhbFN0b3JhZ2VBY2Nlc3MgPSBvcHRpb25zLnVzZUxvY2FsU3RvcmFnZTtcXG5cXG4gIGlmIChsb2NhbFN0b3JhZ2VBY2Nlc3MpIHtcXG4gICAgLy8gY2hlY2sgYnJvd3NlciB2ZXJzaW9uIGFuZCBsb2NhbCBzdG9yYWdlIGFjY2Vzc1xcbiAgICB2YXIgYnJvd3NlckluZm8gPSBuYXZpZ2F0b3IudXNlckFnZW50O1xcbiAgICB2YXIgdWlkID0gbmV3IERhdGUoKTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICB0bnNTdG9yYWdlID0gd2luLmxvY2FsU3RvcmFnZTtcXG5cXG4gICAgICBpZiAodG5zU3RvcmFnZSkge1xcbiAgICAgICAgdG5zU3RvcmFnZS5zZXRJdGVtKHVpZCwgdWlkKTtcXG4gICAgICAgIGxvY2FsU3RvcmFnZUFjY2VzcyA9IHRuc1N0b3JhZ2UuZ2V0SXRlbSh1aWQpID09IHVpZDtcXG4gICAgICAgIHRuc1N0b3JhZ2UucmVtb3ZlSXRlbSh1aWQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsb2NhbFN0b3JhZ2VBY2Nlc3MgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VBY2Nlc3MpIHtcXG4gICAgICAgIHRuc1N0b3JhZ2UgPSB7fTtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBsb2NhbFN0b3JhZ2VBY2Nlc3MgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAobG9jYWxTdG9yYWdlQWNjZXNzKSB7XFxuICAgICAgLy8gcmVtb3ZlIHN0b3JhZ2Ugd2hlbiBicm93c2VyIHZlcnNpb24gY2hhbmdlc1xcbiAgICAgIGlmICh0bnNTdG9yYWdlWyd0bnNBcHAnXSAmJiB0bnNTdG9yYWdlWyd0bnNBcHAnXSAhPT0gYnJvd3NlckluZm8pIHtcXG4gICAgICAgIFsndEMnLCAndFBMJywgJ3RNUScsICd0VGYnLCAndDNEJywgJ3RURHUnLCAndFREZScsICd0QUR1JywgJ3RBRGUnLCAndFRFJywgJ3RBRSddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgICAgdG5zU3RvcmFnZS5yZW1vdmVJdGVtKGl0ZW0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyB1cGRhdGUgYnJvd3NlckluZm9cXG5cXG5cXG4gICAgICBsb2NhbFN0b3JhZ2VbJ3Ruc0FwcCddID0gYnJvd3NlckluZm87XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBDQUxDID0gdG5zU3RvcmFnZVsndEMnXSA/IGNoZWNrU3RvcmFnZVZhbHVlKHRuc1N0b3JhZ2VbJ3RDJ10pIDogc2V0TG9jYWxTdG9yYWdlKHRuc1N0b3JhZ2UsICd0QycsIGNhbGMoKSwgbG9jYWxTdG9yYWdlQWNjZXNzKSxcXG4gICAgICBQRVJDRU5UQUdFTEFZT1VUID0gdG5zU3RvcmFnZVsndFBMJ10gPyBjaGVja1N0b3JhZ2VWYWx1ZSh0bnNTdG9yYWdlWyd0UEwnXSkgOiBzZXRMb2NhbFN0b3JhZ2UodG5zU3RvcmFnZSwgJ3RQTCcsIHBlcmNlbnRhZ2VMYXlvdXQoKSwgbG9jYWxTdG9yYWdlQWNjZXNzKSxcXG4gICAgICBDU1NNUSA9IHRuc1N0b3JhZ2VbJ3RNUSddID8gY2hlY2tTdG9yYWdlVmFsdWUodG5zU3RvcmFnZVsndE1RJ10pIDogc2V0TG9jYWxTdG9yYWdlKHRuc1N0b3JhZ2UsICd0TVEnLCBtZWRpYXF1ZXJ5U3VwcG9ydCgpLCBsb2NhbFN0b3JhZ2VBY2Nlc3MpLFxcbiAgICAgIFRSQU5TRk9STSA9IHRuc1N0b3JhZ2VbJ3RUZiddID8gY2hlY2tTdG9yYWdlVmFsdWUodG5zU3RvcmFnZVsndFRmJ10pIDogc2V0TG9jYWxTdG9yYWdlKHRuc1N0b3JhZ2UsICd0VGYnLCB3aGljaFByb3BlcnR5KCd0cmFuc2Zvcm0nKSwgbG9jYWxTdG9yYWdlQWNjZXNzKSxcXG4gICAgICBIQVMzRFRSQU5TRk9STVMgPSB0bnNTdG9yYWdlWyd0M0QnXSA/IGNoZWNrU3RvcmFnZVZhbHVlKHRuc1N0b3JhZ2VbJ3QzRCddKSA6IHNldExvY2FsU3RvcmFnZSh0bnNTdG9yYWdlLCAndDNEJywgaGFzM0RUcmFuc2Zvcm1zKFRSQU5TRk9STSksIGxvY2FsU3RvcmFnZUFjY2VzcyksXFxuICAgICAgVFJBTlNJVElPTkRVUkFUSU9OID0gdG5zU3RvcmFnZVsndFREdSddID8gY2hlY2tTdG9yYWdlVmFsdWUodG5zU3RvcmFnZVsndFREdSddKSA6IHNldExvY2FsU3RvcmFnZSh0bnNTdG9yYWdlLCAndFREdScsIHdoaWNoUHJvcGVydHkoJ3RyYW5zaXRpb25EdXJhdGlvbicpLCBsb2NhbFN0b3JhZ2VBY2Nlc3MpLFxcbiAgICAgIFRSQU5TSVRJT05ERUxBWSA9IHRuc1N0b3JhZ2VbJ3RURGUnXSA/IGNoZWNrU3RvcmFnZVZhbHVlKHRuc1N0b3JhZ2VbJ3RURGUnXSkgOiBzZXRMb2NhbFN0b3JhZ2UodG5zU3RvcmFnZSwgJ3RURGUnLCB3aGljaFByb3BlcnR5KCd0cmFuc2l0aW9uRGVsYXknKSwgbG9jYWxTdG9yYWdlQWNjZXNzKSxcXG4gICAgICBBTklNQVRJT05EVVJBVElPTiA9IHRuc1N0b3JhZ2VbJ3RBRHUnXSA/IGNoZWNrU3RvcmFnZVZhbHVlKHRuc1N0b3JhZ2VbJ3RBRHUnXSkgOiBzZXRMb2NhbFN0b3JhZ2UodG5zU3RvcmFnZSwgJ3RBRHUnLCB3aGljaFByb3BlcnR5KCdhbmltYXRpb25EdXJhdGlvbicpLCBsb2NhbFN0b3JhZ2VBY2Nlc3MpLFxcbiAgICAgIEFOSU1BVElPTkRFTEFZID0gdG5zU3RvcmFnZVsndEFEZSddID8gY2hlY2tTdG9yYWdlVmFsdWUodG5zU3RvcmFnZVsndEFEZSddKSA6IHNldExvY2FsU3RvcmFnZSh0bnNTdG9yYWdlLCAndEFEZScsIHdoaWNoUHJvcGVydHkoJ2FuaW1hdGlvbkRlbGF5JyksIGxvY2FsU3RvcmFnZUFjY2VzcyksXFxuICAgICAgVFJBTlNJVElPTkVORCA9IHRuc1N0b3JhZ2VbJ3RURSddID8gY2hlY2tTdG9yYWdlVmFsdWUodG5zU3RvcmFnZVsndFRFJ10pIDogc2V0TG9jYWxTdG9yYWdlKHRuc1N0b3JhZ2UsICd0VEUnLCBnZXRFbmRQcm9wZXJ0eShUUkFOU0lUSU9ORFVSQVRJT04sICdUcmFuc2l0aW9uJyksIGxvY2FsU3RvcmFnZUFjY2VzcyksXFxuICAgICAgQU5JTUFUSU9ORU5EID0gdG5zU3RvcmFnZVsndEFFJ10gPyBjaGVja1N0b3JhZ2VWYWx1ZSh0bnNTdG9yYWdlWyd0QUUnXSkgOiBzZXRMb2NhbFN0b3JhZ2UodG5zU3RvcmFnZSwgJ3RBRScsIGdldEVuZFByb3BlcnR5KEFOSU1BVElPTkRVUkFUSU9OLCAnQW5pbWF0aW9uJyksIGxvY2FsU3RvcmFnZUFjY2Vzcyk7IC8vIGdldCBlbGVtZW50IG5vZGVzIGZyb20gc2VsZWN0b3JzXFxuXFxuICB2YXIgc3VwcG9ydENvbnNvbGVXYXJuID0gd2luLmNvbnNvbGUgJiYgdHlwZW9mIHdpbi5jb25zb2xlLndhcm4gPT09IFxcXCJmdW5jdGlvblxcXCIsXFxuICAgICAgdG5zTGlzdCA9IFsnY29udGFpbmVyJywgJ2NvbnRyb2xzQ29udGFpbmVyJywgJ3ByZXZCdXR0b24nLCAnbmV4dEJ1dHRvbicsICduYXZDb250YWluZXInLCAnYXV0b3BsYXlCdXR0b24nXSxcXG4gICAgICBvcHRpb25zRWxlbWVudHMgPSB7fTtcXG4gIHRuc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNbaXRlbV0gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgdmFyIHN0ciA9IG9wdGlvbnNbaXRlbV0sXFxuICAgICAgICAgIGVsID0gZG9jLnF1ZXJ5U2VsZWN0b3Ioc3RyKTtcXG4gICAgICBvcHRpb25zRWxlbWVudHNbaXRlbV0gPSBzdHI7XFxuXFxuICAgICAgaWYgKGVsICYmIGVsLm5vZGVOYW1lKSB7XFxuICAgICAgICBvcHRpb25zW2l0ZW1dID0gZWw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChzdXBwb3J0Q29uc29sZVdhcm4pIHtcXG4gICAgICAgICAgY29uc29sZS53YXJuKCdDYW5cXFxcJ3QgZmluZCcsIG9wdGlvbnNbaXRlbV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7IC8vIG1ha2Ugc3VyZSBhdCBsZWFzdCAxIHNsaWRlXFxuXFxuICBpZiAob3B0aW9ucy5jb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoIDwgMSkge1xcbiAgICBpZiAoc3VwcG9ydENvbnNvbGVXYXJuKSB7XFxuICAgICAgY29uc29sZS53YXJuKCdObyBzbGlkZXMgZm91bmQgaW4nLCBvcHRpb25zLmNvbnRhaW5lcik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfSAvLyB1cGRhdGUgb3B0aW9uc1xcblxcblxcbiAgdmFyIHJlc3BvbnNpdmUgPSBvcHRpb25zLnJlc3BvbnNpdmUsXFxuICAgICAgbmVzdGVkID0gb3B0aW9ucy5uZXN0ZWQsXFxuICAgICAgY2Fyb3VzZWwgPSBvcHRpb25zLm1vZGUgPT09ICdjYXJvdXNlbCcgPyB0cnVlIDogZmFsc2U7XFxuXFxuICBpZiAocmVzcG9uc2l2ZSkge1xcbiAgICAvLyBhcHBseSByZXNwb25zaXZlWzBdIHRvIG9wdGlvbnMgYW5kIHJlbW92ZSBpdFxcbiAgICBpZiAoMCBpbiByZXNwb25zaXZlKSB7XFxuICAgICAgb3B0aW9ucyA9IGV4dGVuZChvcHRpb25zLCByZXNwb25zaXZlWzBdKTtcXG4gICAgICBkZWxldGUgcmVzcG9uc2l2ZVswXTtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVzcG9uc2l2ZVRlbSA9IHt9O1xcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2l2ZSkge1xcbiAgICAgIHZhciB2YWwgPSByZXNwb25zaXZlW2tleV07IC8vIHVwZGF0ZSByZXNwb25zaXZlXFxuICAgICAgLy8gZnJvbTogMzAwOiAyXFxuICAgICAgLy8gdG86XFxuICAgICAgLy8gICAzMDA6IHtcXG4gICAgICAvLyAgICAgaXRlbXM6IDJcXG4gICAgICAvLyAgIH1cXG5cXG4gICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyA/IHtcXG4gICAgICAgIGl0ZW1zOiB2YWxcXG4gICAgICB9IDogdmFsO1xcbiAgICAgIHJlc3BvbnNpdmVUZW1ba2V5XSA9IHZhbDtcXG4gICAgfVxcblxcbiAgICByZXNwb25zaXZlID0gcmVzcG9uc2l2ZVRlbTtcXG4gICAgcmVzcG9uc2l2ZVRlbSA9IG51bGw7XFxuICB9IC8vIHVwZGF0ZSBvcHRpb25zXFxuXFxuXFxuICBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9iaikge1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKCFjYXJvdXNlbCkge1xcbiAgICAgICAgaWYgKGtleSA9PT0gJ3NsaWRlQnknKSB7XFxuICAgICAgICAgIG9ialtrZXldID0gJ3BhZ2UnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGtleSA9PT0gJ2VkZ2VQYWRkaW5nJykge1xcbiAgICAgICAgICBvYmpba2V5XSA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGtleSA9PT0gJ2F1dG9IZWlnaHQnKSB7XFxuICAgICAgICAgIG9ialtrZXldID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyB1cGRhdGUgcmVzcG9uc2l2ZSBvcHRpb25zXFxuXFxuXFxuICAgICAgaWYgKGtleSA9PT0gJ3Jlc3BvbnNpdmUnKSB7XFxuICAgICAgICB1cGRhdGVPcHRpb25zKG9ialtrZXldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICghY2Fyb3VzZWwpIHtcXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcXG4gIH0gLy8gPT09IGRlZmluZSBhbmQgc2V0IHZhcmlhYmxlcyA9PT1cXG5cXG5cXG4gIGlmICghY2Fyb3VzZWwpIHtcXG4gICAgb3B0aW9ucy5heGlzID0gJ2hvcml6b250YWwnO1xcbiAgICBvcHRpb25zLnNsaWRlQnkgPSAncGFnZSc7XFxuICAgIG9wdGlvbnMuZWRnZVBhZGRpbmcgPSBmYWxzZTtcXG4gICAgdmFyIGFuaW1hdGVJbiA9IG9wdGlvbnMuYW5pbWF0ZUluLFxcbiAgICAgICAgYW5pbWF0ZU91dCA9IG9wdGlvbnMuYW5pbWF0ZU91dCxcXG4gICAgICAgIGFuaW1hdGVEZWxheSA9IG9wdGlvbnMuYW5pbWF0ZURlbGF5LFxcbiAgICAgICAgYW5pbWF0ZU5vcm1hbCA9IG9wdGlvbnMuYW5pbWF0ZU5vcm1hbDtcXG4gIH1cXG5cXG4gIHZhciBob3Jpem9udGFsID0gb3B0aW9ucy5heGlzID09PSAnaG9yaXpvbnRhbCcgPyB0cnVlIDogZmFsc2UsXFxuICAgICAgb3V0ZXJXcmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxcbiAgICAgIGlubmVyV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXG4gICAgICBtaWRkbGVXcmFwcGVyLFxcbiAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxcbiAgICAgIGNvbnRhaW5lclBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlLFxcbiAgICAgIGNvbnRhaW5lckhUTUwgPSBjb250YWluZXIub3V0ZXJIVE1MLFxcbiAgICAgIHNsaWRlSXRlbXMgPSBjb250YWluZXIuY2hpbGRyZW4sXFxuICAgICAgc2xpZGVDb3VudCA9IHNsaWRlSXRlbXMubGVuZ3RoLFxcbiAgICAgIGJyZWFrcG9pbnRab25lLFxcbiAgICAgIHdpbmRvd1dpZHRoID0gZ2V0V2luZG93V2lkdGgoKSxcXG4gICAgICBpc09uID0gZmFsc2U7XFxuXFxuICBpZiAocmVzcG9uc2l2ZSkge1xcbiAgICBzZXRCcmVha3BvaW50Wm9uZSgpO1xcbiAgfVxcblxcbiAgaWYgKGNhcm91c2VsKSB7XFxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgKz0gJyB0bnMtdnBmaXgnO1xcbiAgfSAvLyBmaXhlZFdpZHRoOiB2aWV3cG9ydCA+IHJpZ2h0Qm91bmRhcnkgPiBpbmRleE1heFxcblxcblxcbiAgdmFyIGF1dG9XaWR0aCA9IG9wdGlvbnMuYXV0b1dpZHRoLFxcbiAgICAgIGZpeGVkV2lkdGggPSBnZXRPcHRpb24oJ2ZpeGVkV2lkdGgnKSxcXG4gICAgICBlZGdlUGFkZGluZyA9IGdldE9wdGlvbignZWRnZVBhZGRpbmcnKSxcXG4gICAgICBndXR0ZXIgPSBnZXRPcHRpb24oJ2d1dHRlcicpLFxcbiAgICAgIHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRXaWR0aCgpLFxcbiAgICAgIGNlbnRlciA9IGdldE9wdGlvbignY2VudGVyJyksXFxuICAgICAgaXRlbXMgPSAhYXV0b1dpZHRoID8gTWF0aC5mbG9vcihnZXRPcHRpb24oJ2l0ZW1zJykpIDogMSxcXG4gICAgICBzbGlkZUJ5ID0gZ2V0T3B0aW9uKCdzbGlkZUJ5JyksXFxuICAgICAgdmlld3BvcnRNYXggPSBvcHRpb25zLnZpZXdwb3J0TWF4IHx8IG9wdGlvbnMuZml4ZWRXaWR0aFZpZXdwb3J0V2lkdGgsXFxuICAgICAgYXJyb3dLZXlzID0gZ2V0T3B0aW9uKCdhcnJvd0tleXMnKSxcXG4gICAgICBzcGVlZCA9IGdldE9wdGlvbignc3BlZWQnKSxcXG4gICAgICByZXdpbmQgPSBvcHRpb25zLnJld2luZCxcXG4gICAgICBsb29wID0gcmV3aW5kID8gZmFsc2UgOiBvcHRpb25zLmxvb3AsXFxuICAgICAgYXV0b0hlaWdodCA9IGdldE9wdGlvbignYXV0b0hlaWdodCcpLFxcbiAgICAgIGNvbnRyb2xzID0gZ2V0T3B0aW9uKCdjb250cm9scycpLFxcbiAgICAgIGNvbnRyb2xzVGV4dCA9IGdldE9wdGlvbignY29udHJvbHNUZXh0JyksXFxuICAgICAgbmF2ID0gZ2V0T3B0aW9uKCduYXYnKSxcXG4gICAgICB0b3VjaCA9IGdldE9wdGlvbigndG91Y2gnKSxcXG4gICAgICBtb3VzZURyYWcgPSBnZXRPcHRpb24oJ21vdXNlRHJhZycpLFxcbiAgICAgIGF1dG9wbGF5ID0gZ2V0T3B0aW9uKCdhdXRvcGxheScpLFxcbiAgICAgIGF1dG9wbGF5VGltZW91dCA9IGdldE9wdGlvbignYXV0b3BsYXlUaW1lb3V0JyksXFxuICAgICAgYXV0b3BsYXlUZXh0ID0gZ2V0T3B0aW9uKCdhdXRvcGxheVRleHQnKSxcXG4gICAgICBhdXRvcGxheUhvdmVyUGF1c2UgPSBnZXRPcHRpb24oJ2F1dG9wbGF5SG92ZXJQYXVzZScpLFxcbiAgICAgIGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHkgPSBnZXRPcHRpb24oJ2F1dG9wbGF5UmVzZXRPblZpc2liaWxpdHknKSxcXG4gICAgICBzaGVldCA9IGNyZWF0ZVN0eWxlU2hlZXQobnVsbCwgZ2V0T3B0aW9uKCdub25jZScpKSxcXG4gICAgICBsYXp5bG9hZCA9IG9wdGlvbnMubGF6eWxvYWQsXFxuICAgICAgbGF6eWxvYWRTZWxlY3RvciA9IG9wdGlvbnMubGF6eWxvYWRTZWxlY3RvcixcXG4gICAgICBzbGlkZVBvc2l0aW9ucyxcXG4gICAgICAvLyBjb2xsZWN0aW9uIG9mIHNsaWRlIHBvc2l0aW9uc1xcbiAgc2xpZGVJdGVtc091dCA9IFtdLFxcbiAgICAgIGNsb25lQ291bnQgPSBsb29wID8gZ2V0Q2xvbmVDb3VudEZvckxvb3AoKSA6IDAsXFxuICAgICAgc2xpZGVDb3VudE5ldyA9ICFjYXJvdXNlbCA/IHNsaWRlQ291bnQgKyBjbG9uZUNvdW50IDogc2xpZGVDb3VudCArIGNsb25lQ291bnQgKiAyLFxcbiAgICAgIGhhc1JpZ2h0RGVhZFpvbmUgPSAoZml4ZWRXaWR0aCB8fCBhdXRvV2lkdGgpICYmICFsb29wID8gdHJ1ZSA6IGZhbHNlLFxcbiAgICAgIHJpZ2h0Qm91bmRhcnkgPSBmaXhlZFdpZHRoID8gZ2V0UmlnaHRCb3VuZGFyeSgpIDogbnVsbCxcXG4gICAgICB1cGRhdGVJbmRleEJlZm9yZVRyYW5zZm9ybSA9ICFjYXJvdXNlbCB8fCAhbG9vcCA/IHRydWUgOiBmYWxzZSxcXG4gICAgICAvLyB0cmFuc2Zvcm1cXG4gIHRyYW5zZm9ybUF0dHIgPSBob3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCcsXFxuICAgICAgdHJhbnNmb3JtUHJlZml4ID0gJycsXFxuICAgICAgdHJhbnNmb3JtUG9zdGZpeCA9ICcnLFxcbiAgICAgIC8vIGluZGV4XFxuICBnZXRJbmRleE1heCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGZpeGVkV2lkdGgpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGNlbnRlciAmJiAhbG9vcCA/IHNsaWRlQ291bnQgLSAxIDogTWF0aC5jZWlsKC1yaWdodEJvdW5kYXJ5IC8gKGZpeGVkV2lkdGggKyBndXR0ZXIpKTtcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKGF1dG9XaWR0aCkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlQ291bnROZXc7IGkrKykge1xcbiAgICAgICAgICBpZiAoc2xpZGVQb3NpdGlvbnNbaV0gPj0gLXJpZ2h0Qm91bmRhcnkpIHtcXG4gICAgICAgICAgICByZXR1cm4gaTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChjZW50ZXIgJiYgY2Fyb3VzZWwgJiYgIWxvb3ApIHtcXG4gICAgICAgICAgcmV0dXJuIHNsaWRlQ291bnQgLSAxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGxvb3AgfHwgY2Fyb3VzZWwgPyBNYXRoLm1heCgwLCBzbGlkZUNvdW50TmV3IC0gTWF0aC5jZWlsKGl0ZW1zKSkgOiBzbGlkZUNvdW50TmV3IC0gMTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KCksXFxuICAgICAgaW5kZXggPSBnZXRTdGFydEluZGV4KGdldE9wdGlvbignc3RhcnRJbmRleCcpKSxcXG4gICAgICBpbmRleENhY2hlZCA9IGluZGV4O1xcbiAgICAgIGdldEN1cnJlbnRTbGlkZSgpO1xcbiAgICAgIHZhciBpbmRleE1pbiA9IDAsXFxuICAgICAgaW5kZXhNYXggPSAhYXV0b1dpZHRoID8gZ2V0SW5kZXhNYXgoKSA6IG51bGwsXFxuICAgICAgcHJldmVudEFjdGlvbldoZW5SdW5uaW5nID0gb3B0aW9ucy5wcmV2ZW50QWN0aW9uV2hlblJ1bm5pbmcsXFxuICAgICAgc3dpcGVBbmdsZSA9IG9wdGlvbnMuc3dpcGVBbmdsZSxcXG4gICAgICBtb3ZlRGlyZWN0aW9uRXhwZWN0ZWQgPSBzd2lwZUFuZ2xlID8gJz8nIDogdHJ1ZSxcXG4gICAgICBydW5uaW5nID0gZmFsc2UsXFxuICAgICAgb25Jbml0ID0gb3B0aW9ucy5vbkluaXQsXFxuICAgICAgZXZlbnRzID0gbmV3IEV2ZW50cygpLFxcbiAgICAgIC8vIGlkLCBjbGFzc1xcbiAgbmV3Q29udGFpbmVyQ2xhc3NlcyA9ICcgdG5zLXNsaWRlciB0bnMtJyArIG9wdGlvbnMubW9kZSxcXG4gICAgICBzbGlkZUlkID0gY29udGFpbmVyLmlkIHx8IGdldFNsaWRlSWQoKSxcXG4gICAgICBkaXNhYmxlID0gZ2V0T3B0aW9uKCdkaXNhYmxlJyksXFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcXG4gICAgICBmcmVlemFibGUgPSBvcHRpb25zLmZyZWV6YWJsZSxcXG4gICAgICBmcmVlemUgPSBmcmVlemFibGUgJiYgIWF1dG9XaWR0aCA/IGdldEZyZWV6ZSgpIDogZmFsc2UsXFxuICAgICAgZnJvemVuID0gZmFsc2UsXFxuICAgICAgY29udHJvbHNFdmVudHMgPSB7XFxuICAgICdjbGljayc6IG9uQ29udHJvbHNDbGljayxcXG4gICAgJ2tleWRvd24nOiBvbkNvbnRyb2xzS2V5ZG93blxcbiAgfSxcXG4gICAgICBuYXZFdmVudHMgPSB7XFxuICAgICdjbGljayc6IG9uTmF2Q2xpY2ssXFxuICAgICdrZXlkb3duJzogb25OYXZLZXlkb3duXFxuICB9LFxcbiAgICAgIGhvdmVyRXZlbnRzID0ge1xcbiAgICAnbW91c2VvdmVyJzogbW91c2VvdmVyUGF1c2UsXFxuICAgICdtb3VzZW91dCc6IG1vdXNlb3V0UmVzdGFydFxcbiAgfSxcXG4gICAgICB2aXNpYmlsaXR5RXZlbnQgPSB7XFxuICAgICd2aXNpYmlsaXR5Y2hhbmdlJzogb25WaXNpYmlsaXR5Q2hhbmdlXFxuICB9LFxcbiAgICAgIGRvY21lbnRLZXlkb3duRXZlbnQgPSB7XFxuICAgICdrZXlkb3duJzogb25Eb2N1bWVudEtleWRvd25cXG4gIH0sXFxuICAgICAgdG91Y2hFdmVudHMgPSB7XFxuICAgICd0b3VjaHN0YXJ0Jzogb25QYW5TdGFydCxcXG4gICAgJ3RvdWNobW92ZSc6IG9uUGFuTW92ZSxcXG4gICAgJ3RvdWNoZW5kJzogb25QYW5FbmQsXFxuICAgICd0b3VjaGNhbmNlbCc6IG9uUGFuRW5kXFxuICB9LFxcbiAgICAgIGRyYWdFdmVudHMgPSB7XFxuICAgICdtb3VzZWRvd24nOiBvblBhblN0YXJ0LFxcbiAgICAnbW91c2Vtb3ZlJzogb25QYW5Nb3ZlLFxcbiAgICAnbW91c2V1cCc6IG9uUGFuRW5kLFxcbiAgICAnbW91c2VsZWF2ZSc6IG9uUGFuRW5kXFxuICB9LFxcbiAgICAgIGhhc0NvbnRyb2xzID0gaGFzT3B0aW9uKCdjb250cm9scycpLFxcbiAgICAgIGhhc05hdiA9IGhhc09wdGlvbignbmF2JyksXFxuICAgICAgbmF2QXNUaHVtYm5haWxzID0gYXV0b1dpZHRoID8gdHJ1ZSA6IG9wdGlvbnMubmF2QXNUaHVtYm5haWxzLFxcbiAgICAgIGhhc0F1dG9wbGF5ID0gaGFzT3B0aW9uKCdhdXRvcGxheScpLFxcbiAgICAgIGhhc1RvdWNoID0gaGFzT3B0aW9uKCd0b3VjaCcpLFxcbiAgICAgIGhhc01vdXNlRHJhZyA9IGhhc09wdGlvbignbW91c2VEcmFnJyksXFxuICAgICAgc2xpZGVBY3RpdmVDbGFzcyA9ICd0bnMtc2xpZGUtYWN0aXZlJyxcXG4gICAgICBzbGlkZUNsb25lZENsYXNzID0gJ3Rucy1zbGlkZS1jbG9uZWQnLFxcbiAgICAgIGltZ0NvbXBsZXRlQ2xhc3MgPSAndG5zLWNvbXBsZXRlJyxcXG4gICAgICBpbWdFdmVudHMgPSB7XFxuICAgICdsb2FkJzogb25JbWdMb2FkZWQsXFxuICAgICdlcnJvcic6IG9uSW1nRmFpbGVkXFxuICB9LFxcbiAgICAgIGltZ3NDb21wbGV0ZSxcXG4gICAgICBsaXZlcmVnaW9uQ3VycmVudCxcXG4gICAgICBwcmV2ZW50U2Nyb2xsID0gb3B0aW9ucy5wcmV2ZW50U2Nyb2xsT25Ub3VjaCA9PT0gJ2ZvcmNlJyA/IHRydWUgOiBmYWxzZTsgLy8gY29udHJvbHNcXG5cXG5cXG4gIGlmIChoYXNDb250cm9scykge1xcbiAgICB2YXIgY29udHJvbHNDb250YWluZXIgPSBvcHRpb25zLmNvbnRyb2xzQ29udGFpbmVyLFxcbiAgICAgICAgY29udHJvbHNDb250YWluZXJIVE1MID0gb3B0aW9ucy5jb250cm9sc0NvbnRhaW5lciA/IG9wdGlvbnMuY29udHJvbHNDb250YWluZXIub3V0ZXJIVE1MIDogJycsXFxuICAgICAgICBwcmV2QnV0dG9uID0gb3B0aW9ucy5wcmV2QnV0dG9uLFxcbiAgICAgICAgbmV4dEJ1dHRvbiA9IG9wdGlvbnMubmV4dEJ1dHRvbixcXG4gICAgICAgIHByZXZCdXR0b25IVE1MID0gb3B0aW9ucy5wcmV2QnV0dG9uID8gb3B0aW9ucy5wcmV2QnV0dG9uLm91dGVySFRNTCA6ICcnLFxcbiAgICAgICAgbmV4dEJ1dHRvbkhUTUwgPSBvcHRpb25zLm5leHRCdXR0b24gPyBvcHRpb25zLm5leHRCdXR0b24ub3V0ZXJIVE1MIDogJycsXFxuICAgICAgICBwcmV2SXNCdXR0b24sXFxuICAgICAgICBuZXh0SXNCdXR0b247XFxuICB9IC8vIG5hdlxcblxcblxcbiAgaWYgKGhhc05hdikge1xcbiAgICB2YXIgbmF2Q29udGFpbmVyID0gb3B0aW9ucy5uYXZDb250YWluZXIsXFxuICAgICAgICBuYXZDb250YWluZXJIVE1MID0gb3B0aW9ucy5uYXZDb250YWluZXIgPyBvcHRpb25zLm5hdkNvbnRhaW5lci5vdXRlckhUTUwgOiAnJyxcXG4gICAgICAgIG5hdkl0ZW1zLFxcbiAgICAgICAgcGFnZXMgPSBhdXRvV2lkdGggPyBzbGlkZUNvdW50IDogZ2V0UGFnZXMoKSxcXG4gICAgICAgIHBhZ2VzQ2FjaGVkID0gMCxcXG4gICAgICAgIG5hdkNsaWNrZWQgPSAtMSxcXG4gICAgICAgIG5hdkN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnROYXZJbmRleCgpLFxcbiAgICAgICAgbmF2Q3VycmVudEluZGV4Q2FjaGVkID0gbmF2Q3VycmVudEluZGV4LFxcbiAgICAgICAgbmF2QWN0aXZlQ2xhc3MgPSAndG5zLW5hdi1hY3RpdmUnLFxcbiAgICAgICAgbmF2U3RyID0gJ0Nhcm91c2VsIFBhZ2UgJyxcXG4gICAgICAgIG5hdlN0ckN1cnJlbnQgPSAnIChDdXJyZW50IFNsaWRlKSc7XFxuICB9IC8vIGF1dG9wbGF5XFxuXFxuXFxuICBpZiAoaGFzQXV0b3BsYXkpIHtcXG4gICAgdmFyIGF1dG9wbGF5RGlyZWN0aW9uID0gb3B0aW9ucy5hdXRvcGxheURpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gMSA6IC0xLFxcbiAgICAgICAgYXV0b3BsYXlCdXR0b24gPSBvcHRpb25zLmF1dG9wbGF5QnV0dG9uLFxcbiAgICAgICAgYXV0b3BsYXlCdXR0b25IVE1MID0gb3B0aW9ucy5hdXRvcGxheUJ1dHRvbiA/IG9wdGlvbnMuYXV0b3BsYXlCdXR0b24ub3V0ZXJIVE1MIDogJycsXFxuICAgICAgICBhdXRvcGxheUh0bWxTdHJpbmdzID0gWyc8c3BhbiBjbGFzcz1cXFxcJ3Rucy12aXN1YWxseS1oaWRkZW5cXFxcJz4nLCAnIGFuaW1hdGlvbjwvc3Bhbj4nXSxcXG4gICAgICAgIGF1dG9wbGF5VGltZXIsXFxuICAgICAgICBhbmltYXRpbmcsXFxuICAgICAgICBhdXRvcGxheUhvdmVyUGF1c2VkLFxcbiAgICAgICAgYXV0b3BsYXlVc2VyUGF1c2VkLFxcbiAgICAgICAgYXV0b3BsYXlWaXNpYmlsaXR5UGF1c2VkO1xcbiAgfVxcblxcbiAgaWYgKGhhc1RvdWNoIHx8IGhhc01vdXNlRHJhZykge1xcbiAgICB2YXIgaW5pdFBvc2l0aW9uID0ge30sXFxuICAgICAgICBsYXN0UG9zaXRpb24gPSB7fSxcXG4gICAgICAgIHRyYW5zbGF0ZUluaXQsXFxuICAgICAgICBwYW5TdGFydCA9IGZhbHNlLFxcbiAgICAgICAgcmFmSW5kZXgsXFxuICAgICAgICBnZXREaXN0ID0gaG9yaXpvbnRhbCA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEueCAtIGIueDtcXG4gICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEueSAtIGIueTtcXG4gICAgfTtcXG4gIH0gLy8gZGlzYWJsZSBzbGlkZXIgd2hlbiBzbGlkZWNvdW50IDw9IGl0ZW1zXFxuXFxuXFxuICBpZiAoIWF1dG9XaWR0aCkge1xcbiAgICByZXNldFZhcmlibGVzV2hlbkRpc2FibGUoZGlzYWJsZSB8fCBmcmVlemUpO1xcbiAgfVxcblxcbiAgaWYgKFRSQU5TRk9STSkge1xcbiAgICB0cmFuc2Zvcm1BdHRyID0gVFJBTlNGT1JNO1xcbiAgICB0cmFuc2Zvcm1QcmVmaXggPSAndHJhbnNsYXRlJztcXG5cXG4gICAgaWYgKEhBUzNEVFJBTlNGT1JNUykge1xcbiAgICAgIHRyYW5zZm9ybVByZWZpeCArPSBob3Jpem9udGFsID8gJzNkKCcgOiAnM2QoMHB4LCAnO1xcbiAgICAgIHRyYW5zZm9ybVBvc3RmaXggPSBob3Jpem9udGFsID8gJywgMHB4LCAwcHgpJyA6ICcsIDBweCknO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRyYW5zZm9ybVByZWZpeCArPSBob3Jpem9udGFsID8gJ1goJyA6ICdZKCc7XFxuICAgICAgdHJhbnNmb3JtUG9zdGZpeCA9ICcpJztcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGNhcm91c2VsKSB7XFxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBjb250YWluZXIuY2xhc3NOYW1lLnJlcGxhY2UoJ3Rucy12cGZpeCcsICcnKTtcXG4gIH1cXG5cXG4gIGluaXRTdHJ1Y3R1cmUoKTtcXG4gIGluaXRTaGVldCgpO1xcbiAgaW5pdFNsaWRlclRyYW5zZm9ybSgpOyAvLyA9PT0gQ09NTU9OIEZVTkNUSU9OUyA9PT0gLy9cXG5cXG4gIGZ1bmN0aW9uIHJlc2V0VmFyaWJsZXNXaGVuRGlzYWJsZShjb25kaXRpb24pIHtcXG4gICAgaWYgKGNvbmRpdGlvbikge1xcbiAgICAgIGNvbnRyb2xzID0gbmF2ID0gdG91Y2ggPSBtb3VzZURyYWcgPSBhcnJvd0tleXMgPSBhdXRvcGxheSA9IGF1dG9wbGF5SG92ZXJQYXVzZSA9IGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHkgPSBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFNsaWRlKCkge1xcbiAgICB2YXIgdGVtID0gY2Fyb3VzZWwgPyBpbmRleCAtIGNsb25lQ291bnQgOiBpbmRleDtcXG5cXG4gICAgd2hpbGUgKHRlbSA8IDApIHtcXG4gICAgICB0ZW0gKz0gc2xpZGVDb3VudDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGVtICUgc2xpZGVDb3VudCArIDE7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRTdGFydEluZGV4KGluZCkge1xcbiAgICBpbmQgPSBpbmQgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihsb29wID8gc2xpZGVDb3VudCAtIDEgOiBzbGlkZUNvdW50IC0gaXRlbXMsIGluZCkpIDogMDtcXG4gICAgcmV0dXJuIGNhcm91c2VsID8gaW5kICsgY2xvbmVDb3VudCA6IGluZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldEFic0luZGV4KGkpIHtcXG4gICAgaWYgKGkgPT0gbnVsbCkge1xcbiAgICAgIGkgPSBpbmRleDtcXG4gICAgfVxcblxcbiAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICBpIC09IGNsb25lQ291bnQ7XFxuICAgIH1cXG5cXG4gICAgd2hpbGUgKGkgPCAwKSB7XFxuICAgICAgaSArPSBzbGlkZUNvdW50O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBNYXRoLmZsb29yKGkgJSBzbGlkZUNvdW50KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnROYXZJbmRleCgpIHtcXG4gICAgdmFyIGFic0luZGV4ID0gZ2V0QWJzSW5kZXgoKSxcXG4gICAgICAgIHJlc3VsdDtcXG4gICAgcmVzdWx0ID0gbmF2QXNUaHVtYm5haWxzID8gYWJzSW5kZXggOiBmaXhlZFdpZHRoIHx8IGF1dG9XaWR0aCA/IE1hdGguY2VpbCgoYWJzSW5kZXggKyAxKSAqIHBhZ2VzIC8gc2xpZGVDb3VudCAtIDEpIDogTWF0aC5mbG9vcihhYnNJbmRleCAvIGl0ZW1zKTsgLy8gc2V0IGFjdGl2ZSBuYXYgdG8gdGhlIGxhc3Qgb25lIHdoZW4gcmVhY2hlcyB0aGUgcmlnaHQgZWRnZVxcblxcbiAgICBpZiAoIWxvb3AgJiYgY2Fyb3VzZWwgJiYgaW5kZXggPT09IGluZGV4TWF4KSB7XFxuICAgICAgcmVzdWx0ID0gcGFnZXMgLSAxO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRJdGVtc01heCgpIHtcXG4gICAgLy8gZml4ZWRXaWR0aCBvciBhdXRvV2lkdGggd2hpbGUgdmlld3BvcnRNYXggaXMgbm90IGF2YWlsYWJsZVxcbiAgICBpZiAoYXV0b1dpZHRoIHx8IGZpeGVkV2lkdGggJiYgIXZpZXdwb3J0TWF4KSB7XFxuICAgICAgcmV0dXJuIHNsaWRlQ291bnQgLSAxOyAvLyBtb3N0IGNhc2VzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHN0ciA9IGZpeGVkV2lkdGggPyAnZml4ZWRXaWR0aCcgOiAnaXRlbXMnLFxcbiAgICAgICAgICBhcnIgPSBbXTtcXG5cXG4gICAgICBpZiAoZml4ZWRXaWR0aCB8fCBvcHRpb25zW3N0cl0gPCBzbGlkZUNvdW50KSB7XFxuICAgICAgICBhcnIucHVzaChvcHRpb25zW3N0cl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVzcG9uc2l2ZSkge1xcbiAgICAgICAgZm9yICh2YXIgYnAgaW4gcmVzcG9uc2l2ZSkge1xcbiAgICAgICAgICB2YXIgdGVtID0gcmVzcG9uc2l2ZVticF1bc3RyXTtcXG5cXG4gICAgICAgICAgaWYgKHRlbSAmJiAoZml4ZWRXaWR0aCB8fCB0ZW0gPCBzbGlkZUNvdW50KSkge1xcbiAgICAgICAgICAgIGFyci5wdXNoKHRlbSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XFxuICAgICAgICBhcnIucHVzaCgwKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIE1hdGguY2VpbChmaXhlZFdpZHRoID8gdmlld3BvcnRNYXggLyBNYXRoLm1pbi5hcHBseShudWxsLCBhcnIpIDogTWF0aC5tYXguYXBwbHkobnVsbCwgYXJyKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldENsb25lQ291bnRGb3JMb29wKCkge1xcbiAgICB2YXIgaXRlbXNNYXggPSBnZXRJdGVtc01heCgpLFxcbiAgICAgICAgcmVzdWx0ID0gY2Fyb3VzZWwgPyBNYXRoLmNlaWwoKGl0ZW1zTWF4ICogNSAtIHNsaWRlQ291bnQpIC8gMikgOiBpdGVtc01heCAqIDQgLSBzbGlkZUNvdW50O1xcbiAgICByZXN1bHQgPSBNYXRoLm1heChpdGVtc01heCwgcmVzdWx0KTtcXG4gICAgcmV0dXJuIGhhc09wdGlvbignZWRnZVBhZGRpbmcnKSA/IHJlc3VsdCArIDEgOiByZXN1bHQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcXG4gICAgcmV0dXJuIHdpbi5pbm5lcldpZHRoIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jLmJvZHkuY2xpZW50V2lkdGg7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRJbnNlcnRQb3NpdGlvbihwb3MpIHtcXG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgPyAnYWZ0ZXJiZWdpbicgOiAnYmVmb3JlZW5kJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldENsaWVudFdpZHRoKGVsKSB7XFxuICAgIGlmIChlbCA9PSBudWxsKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxuICAgICAgICByZWN0LFxcbiAgICAgICAgd2lkdGg7XFxuICAgIGVsLmFwcGVuZENoaWxkKGRpdik7XFxuICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHdpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcXG4gICAgZGl2LnJlbW92ZSgpO1xcbiAgICByZXR1cm4gd2lkdGggfHwgZ2V0Q2xpZW50V2lkdGgoZWwucGFyZW50Tm9kZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRWaWV3cG9ydFdpZHRoKCkge1xcbiAgICB2YXIgZ2FwID0gZWRnZVBhZGRpbmcgPyBlZGdlUGFkZGluZyAqIDIgLSBndXR0ZXIgOiAwO1xcbiAgICByZXR1cm4gZ2V0Q2xpZW50V2lkdGgoY29udGFpbmVyUGFyZW50KSAtIGdhcDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGhhc09wdGlvbihpdGVtKSB7XFxuICAgIGlmIChvcHRpb25zW2l0ZW1dKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHJlc3BvbnNpdmUpIHtcXG4gICAgICAgIGZvciAodmFyIGJwIGluIHJlc3BvbnNpdmUpIHtcXG4gICAgICAgICAgaWYgKHJlc3BvbnNpdmVbYnBdW2l0ZW1dKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9IC8vIGdldCBvcHRpb246XFxuICAvLyBmaXhlZCB3aWR0aDogdmlld3BvcnQsIGZpeGVkV2lkdGgsIGd1dHRlciA9PiBpdGVtc1xcbiAgLy8gb3RoZXJzOiB3aW5kb3cgd2lkdGggPT4gYWxsIHZhcmlhYmxlc1xcbiAgLy8gYWxsOiBpdGVtcyA9PiBzbGlkZUJ5XFxuXFxuXFxuICBmdW5jdGlvbiBnZXRPcHRpb24oaXRlbSwgd3cpIHtcXG4gICAgaWYgKHd3ID09IG51bGwpIHtcXG4gICAgICB3dyA9IHdpbmRvd1dpZHRoO1xcbiAgICB9XFxuXFxuICAgIGlmIChpdGVtID09PSAnaXRlbXMnICYmIGZpeGVkV2lkdGgpIHtcXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigodmlld3BvcnQgKyBndXR0ZXIpIC8gKGZpeGVkV2lkdGggKyBndXR0ZXIpKSB8fCAxO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25zW2l0ZW1dO1xcblxcbiAgICAgIGlmIChyZXNwb25zaXZlKSB7XFxuICAgICAgICBmb3IgKHZhciBicCBpbiByZXNwb25zaXZlKSB7XFxuICAgICAgICAgIC8vIGJwOiBjb252ZXJ0IHN0cmluZyB0byBudW1iZXJcXG4gICAgICAgICAgaWYgKHd3ID49IHBhcnNlSW50KGJwKSkge1xcbiAgICAgICAgICAgIGlmIChpdGVtIGluIHJlc3BvbnNpdmVbYnBdKSB7XFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXNwb25zaXZlW2JwXVtpdGVtXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGl0ZW0gPT09ICdzbGlkZUJ5JyAmJiByZXN1bHQgPT09ICdwYWdlJykge1xcbiAgICAgICAgcmVzdWx0ID0gZ2V0T3B0aW9uKCdpdGVtcycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWNhcm91c2VsICYmIChpdGVtID09PSAnc2xpZGVCeScgfHwgaXRlbSA9PT0gJ2l0ZW1zJykpIHtcXG4gICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IocmVzdWx0KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0U2xpZGVNYXJnaW5MZWZ0KGkpIHtcXG4gICAgcmV0dXJuIENBTEMgPyBDQUxDICsgJygnICsgaSAqIDEwMCArICclIC8gJyArIHNsaWRlQ291bnROZXcgKyAnKScgOiBpICogMTAwIC8gc2xpZGVDb3VudE5ldyArICclJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldElubmVyV3JhcHBlclN0eWxlcyhlZGdlUGFkZGluZ1RlbSwgZ3V0dGVyVGVtLCBmaXhlZFdpZHRoVGVtLCBzcGVlZFRlbSwgYXV0b0hlaWdodEJQKSB7XFxuICAgIHZhciBzdHIgPSAnJztcXG5cXG4gICAgaWYgKGVkZ2VQYWRkaW5nVGVtICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICB2YXIgZ2FwID0gZWRnZVBhZGRpbmdUZW07XFxuXFxuICAgICAgaWYgKGd1dHRlclRlbSkge1xcbiAgICAgICAgZ2FwIC09IGd1dHRlclRlbTtcXG4gICAgICB9XFxuXFxuICAgICAgc3RyID0gaG9yaXpvbnRhbCA/ICdtYXJnaW46IDAgJyArIGdhcCArICdweCAwICcgKyBlZGdlUGFkZGluZ1RlbSArICdweDsnIDogJ21hcmdpbjogJyArIGVkZ2VQYWRkaW5nVGVtICsgJ3B4IDAgJyArIGdhcCArICdweCAwOyc7XFxuICAgIH0gZWxzZSBpZiAoZ3V0dGVyVGVtICYmICFmaXhlZFdpZHRoVGVtKSB7XFxuICAgICAgdmFyIGd1dHRlclRlbVVuaXQgPSAnLScgKyBndXR0ZXJUZW0gKyAncHgnLFxcbiAgICAgICAgICBkaXIgPSBob3Jpem9udGFsID8gZ3V0dGVyVGVtVW5pdCArICcgMCAwJyA6ICcwICcgKyBndXR0ZXJUZW1Vbml0ICsgJyAwJztcXG4gICAgICBzdHIgPSAnbWFyZ2luOiAwICcgKyBkaXIgKyAnOyc7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFjYXJvdXNlbCAmJiBhdXRvSGVpZ2h0QlAgJiYgVFJBTlNJVElPTkRVUkFUSU9OICYmIHNwZWVkVGVtKSB7XFxuICAgICAgc3RyICs9IGdldFRyYW5zaXRpb25EdXJhdGlvblN0eWxlKHNwZWVkVGVtKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyV2lkdGgoZml4ZWRXaWR0aFRlbSwgZ3V0dGVyVGVtLCBpdGVtc1RlbSkge1xcbiAgICBpZiAoZml4ZWRXaWR0aFRlbSkge1xcbiAgICAgIHJldHVybiAoZml4ZWRXaWR0aFRlbSArIGd1dHRlclRlbSkgKiBzbGlkZUNvdW50TmV3ICsgJ3B4JztcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gQ0FMQyA/IENBTEMgKyAnKCcgKyBzbGlkZUNvdW50TmV3ICogMTAwICsgJyUgLyAnICsgaXRlbXNUZW0gKyAnKScgOiBzbGlkZUNvdW50TmV3ICogMTAwIC8gaXRlbXNUZW0gKyAnJSc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFNsaWRlV2lkdGhTdHlsZShmaXhlZFdpZHRoVGVtLCBndXR0ZXJUZW0sIGl0ZW1zVGVtKSB7XFxuICAgIHZhciB3aWR0aDtcXG5cXG4gICAgaWYgKGZpeGVkV2lkdGhUZW0pIHtcXG4gICAgICB3aWR0aCA9IGZpeGVkV2lkdGhUZW0gKyBndXR0ZXJUZW0gKyAncHgnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICghY2Fyb3VzZWwpIHtcXG4gICAgICAgIGl0ZW1zVGVtID0gTWF0aC5mbG9vcihpdGVtc1RlbSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkaXZpZGVuZCA9IGNhcm91c2VsID8gc2xpZGVDb3VudE5ldyA6IGl0ZW1zVGVtO1xcbiAgICAgIHdpZHRoID0gQ0FMQyA/IENBTEMgKyAnKDEwMCUgLyAnICsgZGl2aWRlbmQgKyAnKScgOiAxMDAgLyBkaXZpZGVuZCArICclJztcXG4gICAgfVxcblxcbiAgICB3aWR0aCA9ICd3aWR0aDonICsgd2lkdGg7IC8vIGlubmVyIHNsaWRlcjogb3ZlcndyaXRlIG91dGVyIHNsaWRlciBzdHlsZXNcXG5cXG4gICAgcmV0dXJuIG5lc3RlZCAhPT0gJ2lubmVyJyA/IHdpZHRoICsgJzsnIDogd2lkdGggKyAnICFpbXBvcnRhbnQ7JztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFNsaWRlR3V0dGVyU3R5bGUoZ3V0dGVyVGVtKSB7XFxuICAgIHZhciBzdHIgPSAnJzsgLy8gZ3V0dGVyIG1heWJlIGludGVyZ2VyIHx8IDBcXG4gICAgLy8gc28gY2FuJ3QgdXNlICdpZiAoZ3V0dGVyKSdcXG5cXG4gICAgaWYgKGd1dHRlclRlbSAhPT0gZmFsc2UpIHtcXG4gICAgICB2YXIgcHJvcCA9IGhvcml6b250YWwgPyAncGFkZGluZy0nIDogJ21hcmdpbi0nLFxcbiAgICAgICAgICBkaXIgPSBob3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xcbiAgICAgIHN0ciA9IHByb3AgKyBkaXIgKyAnOiAnICsgZ3V0dGVyVGVtICsgJ3B4Oyc7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldENTU1ByZWZpeChuYW1lLCBudW0pIHtcXG4gICAgdmFyIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gbnVtKS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgICBpZiAocHJlZml4KSB7XFxuICAgICAgcHJlZml4ID0gJy0nICsgcHJlZml4ICsgJy0nO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwcmVmaXg7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uRHVyYXRpb25TdHlsZShzcGVlZCkge1xcbiAgICByZXR1cm4gZ2V0Q1NTUHJlZml4KFRSQU5TSVRJT05EVVJBVElPTiwgMTgpICsgJ3RyYW5zaXRpb24tZHVyYXRpb246JyArIHNwZWVkIC8gMTAwMCArICdzOyc7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRBbmltYXRpb25EdXJhdGlvblN0eWxlKHNwZWVkKSB7XFxuICAgIHJldHVybiBnZXRDU1NQcmVmaXgoQU5JTUFUSU9ORFVSQVRJT04sIDE3KSArICdhbmltYXRpb24tZHVyYXRpb246JyArIHNwZWVkIC8gMTAwMCArICdzOyc7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbml0U3RydWN0dXJlKCkge1xcbiAgICB2YXIgY2xhc3NPdXRlciA9ICd0bnMtb3V0ZXInLFxcbiAgICAgICAgY2xhc3NJbm5lciA9ICd0bnMtaW5uZXInO1xcbiAgICAgICAgaGFzT3B0aW9uKCdndXR0ZXInKTtcXG4gICAgb3V0ZXJXcmFwcGVyLmNsYXNzTmFtZSA9IGNsYXNzT3V0ZXI7XFxuICAgIGlubmVyV3JhcHBlci5jbGFzc05hbWUgPSBjbGFzc0lubmVyO1xcbiAgICBvdXRlcldyYXBwZXIuaWQgPSBzbGlkZUlkICsgJy1vdyc7XFxuICAgIGlubmVyV3JhcHBlci5pZCA9IHNsaWRlSWQgKyAnLWl3JzsgLy8gc2V0IGNvbnRhaW5lciBwcm9wZXJ0aWVzXFxuXFxuICAgIGlmIChjb250YWluZXIuaWQgPT09ICcnKSB7XFxuICAgICAgY29udGFpbmVyLmlkID0gc2xpZGVJZDtcXG4gICAgfVxcblxcbiAgICBuZXdDb250YWluZXJDbGFzc2VzICs9IFBFUkNFTlRBR0VMQVlPVVQgfHwgYXV0b1dpZHRoID8gJyB0bnMtc3VicGl4ZWwnIDogJyB0bnMtbm8tc3VicGl4ZWwnO1xcbiAgICBuZXdDb250YWluZXJDbGFzc2VzICs9IENBTEMgPyAnIHRucy1jYWxjJyA6ICcgdG5zLW5vLWNhbGMnO1xcblxcbiAgICBpZiAoYXV0b1dpZHRoKSB7XFxuICAgICAgbmV3Q29udGFpbmVyQ2xhc3NlcyArPSAnIHRucy1hdXRvd2lkdGgnO1xcbiAgICB9XFxuXFxuICAgIG5ld0NvbnRhaW5lckNsYXNzZXMgKz0gJyB0bnMtJyArIG9wdGlvbnMuYXhpcztcXG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSArPSBuZXdDb250YWluZXJDbGFzc2VzOyAvLyBhZGQgY29uc3RyYWluIGxheWVyIGZvciBjYXJvdXNlbFxcblxcbiAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICBtaWRkbGVXcmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgICAgIG1pZGRsZVdyYXBwZXIuaWQgPSBzbGlkZUlkICsgJy1tdyc7XFxuICAgICAgbWlkZGxlV3JhcHBlci5jbGFzc05hbWUgPSAndG5zLW92aCc7XFxuICAgICAgb3V0ZXJXcmFwcGVyLmFwcGVuZENoaWxkKG1pZGRsZVdyYXBwZXIpO1xcbiAgICAgIG1pZGRsZVdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5uZXJXcmFwcGVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRlcldyYXBwZXIuYXBwZW5kQ2hpbGQoaW5uZXJXcmFwcGVyKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXV0b0hlaWdodCkge1xcbiAgICAgIHZhciB3cCA9IG1pZGRsZVdyYXBwZXIgPyBtaWRkbGVXcmFwcGVyIDogaW5uZXJXcmFwcGVyO1xcbiAgICAgIHdwLmNsYXNzTmFtZSArPSAnIHRucy1haCc7XFxuICAgIH1cXG5cXG4gICAgY29udGFpbmVyUGFyZW50Lmluc2VydEJlZm9yZShvdXRlcldyYXBwZXIsIGNvbnRhaW5lcik7XFxuICAgIGlubmVyV3JhcHBlci5hcHBlbmRDaGlsZChjb250YWluZXIpOyAvLyBhZGQgaWQsIGNsYXNzLCBhcmlhIGF0dHJpYnV0ZXNcXG4gICAgLy8gYmVmb3JlIGNsb25lIHNsaWRlc1xcblxcbiAgICBmb3JFYWNoKHNsaWRlSXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XFxuICAgICAgYWRkQ2xhc3MoaXRlbSwgJ3Rucy1pdGVtJyk7XFxuXFxuICAgICAgaWYgKCFpdGVtLmlkKSB7XFxuICAgICAgICBpdGVtLmlkID0gc2xpZGVJZCArICctaXRlbScgKyBpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWNhcm91c2VsICYmIGFuaW1hdGVOb3JtYWwpIHtcXG4gICAgICAgIGFkZENsYXNzKGl0ZW0sIGFuaW1hdGVOb3JtYWwpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZXRBdHRycyhpdGVtLCB7XFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXFxuICAgICAgICAndGFiaW5kZXgnOiAnLTEnXFxuICAgICAgfSk7XFxuICAgIH0pOyAvLyAjIyBjbG9uZSBzbGlkZXNcXG4gICAgLy8gY2Fyb3VzZWw6IG4gKyBzbGlkZXMgKyBuXFxuICAgIC8vIGdhbGxlcnk6ICAgICAgc2xpZGVzICsgblxcblxcbiAgICBpZiAoY2xvbmVDb3VudCkge1xcbiAgICAgIHZhciBmcmFnbWVudEJlZm9yZSA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuICAgICAgICAgIGZyYWdtZW50QWZ0ZXIgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xcblxcbiAgICAgIGZvciAodmFyIGogPSBjbG9uZUNvdW50OyBqLS07KSB7XFxuICAgICAgICB2YXIgbnVtID0gaiAlIHNsaWRlQ291bnQsXFxuICAgICAgICAgICAgY2xvbmVGaXJzdCA9IHNsaWRlSXRlbXNbbnVtXS5jbG9uZU5vZGUodHJ1ZSk7XFxuICAgICAgICBhZGRDbGFzcyhjbG9uZUZpcnN0LCBzbGlkZUNsb25lZENsYXNzKTtcXG4gICAgICAgIHJlbW92ZUF0dHJzKGNsb25lRmlyc3QsICdpZCcpO1xcbiAgICAgICAgZnJhZ21lbnRBZnRlci5pbnNlcnRCZWZvcmUoY2xvbmVGaXJzdCwgZnJhZ21lbnRBZnRlci5maXJzdENoaWxkKTtcXG5cXG4gICAgICAgIGlmIChjYXJvdXNlbCkge1xcbiAgICAgICAgICB2YXIgY2xvbmVMYXN0ID0gc2xpZGVJdGVtc1tzbGlkZUNvdW50IC0gMSAtIG51bV0uY2xvbmVOb2RlKHRydWUpO1xcbiAgICAgICAgICBhZGRDbGFzcyhjbG9uZUxhc3QsIHNsaWRlQ2xvbmVkQ2xhc3MpO1xcbiAgICAgICAgICByZW1vdmVBdHRycyhjbG9uZUxhc3QsICdpZCcpO1xcbiAgICAgICAgICBmcmFnbWVudEJlZm9yZS5hcHBlbmRDaGlsZChjbG9uZUxhc3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGZyYWdtZW50QmVmb3JlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XFxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50QWZ0ZXIpO1xcbiAgICAgIHNsaWRlSXRlbXMgPSBjb250YWluZXIuY2hpbGRyZW47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluaXRTbGlkZXJUcmFuc2Zvcm0oKSB7XFxuICAgIC8vICMjIGltYWdlcyBsb2FkZWQvZmFpbGVkXFxuICAgIGlmIChoYXNPcHRpb24oJ2F1dG9IZWlnaHQnKSB8fCBhdXRvV2lkdGggfHwgIWhvcml6b250YWwpIHtcXG4gICAgICB2YXIgaW1ncyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTsgLy8gYWRkIGltZyBsb2FkIGV2ZW50IGxpc3RlbmVyXFxuXFxuICAgICAgZm9yRWFjaChpbWdzLCBmdW5jdGlvbiAoaW1nKSB7XFxuICAgICAgICB2YXIgc3JjID0gaW1nLnNyYztcXG5cXG4gICAgICAgIGlmICghbGF6eWxvYWQpIHtcXG4gICAgICAgICAgLy8gbm90IGRhdGEgaW1nXFxuICAgICAgICAgIGlmIChzcmMgJiYgc3JjLmluZGV4T2YoJ2RhdGE6aW1hZ2UnKSA8IDApIHtcXG4gICAgICAgICAgICBpbWcuc3JjID0gJyc7XFxuICAgICAgICAgICAgYWRkRXZlbnRzKGltZywgaW1nRXZlbnRzKTtcXG4gICAgICAgICAgICBhZGRDbGFzcyhpbWcsICdsb2FkaW5nJyk7XFxuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYzsgLy8gZGF0YSBpbWdcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpbWdMb2FkZWQoaW1nKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pOyAvLyBzZXQgaW1nc0NvbXBsZXRlXFxuXFxuICAgICAgcmFmKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGltZ3NMb2FkZWRDaGVjayhhcnJheUZyb21Ob2RlTGlzdChpbWdzKSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpbWdzQ29tcGxldGUgPSB0cnVlO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7IC8vIHJlc2V0IGltZ3MgZm9yIGF1dG8gaGVpZ2h0OiBjaGVjayB2aXNpYmxlIGltZ3Mgb25seVxcblxcbiAgICAgIGlmIChoYXNPcHRpb24oJ2F1dG9IZWlnaHQnKSkge1xcbiAgICAgICAgaW1ncyA9IGdldEltYWdlQXJyYXkoaW5kZXgsIE1hdGgubWluKGluZGV4ICsgaXRlbXMgLSAxLCBzbGlkZUNvdW50TmV3IC0gMSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBsYXp5bG9hZCA/IGluaXRTbGlkZXJUcmFuc2Zvcm1TdHlsZUNoZWNrKCkgOiByYWYoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaW1nc0xvYWRlZENoZWNrKGFycmF5RnJvbU5vZGVMaXN0KGltZ3MpLCBpbml0U2xpZGVyVHJhbnNmb3JtU3R5bGVDaGVjayk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gc2V0IGNvbnRhaW5lciB0cmFuc2Zvcm0gcHJvcGVydHlcXG4gICAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICAgIGRvQ29udGFpbmVyVHJhbnNmb3JtU2lsZW50KCk7XFxuICAgICAgfSAvLyB1cGRhdGUgc2xpZGVyIHRvb2xzIGFuZCBldmVudHNcXG5cXG5cXG4gICAgICBpbml0VG9vbHMoKTtcXG4gICAgICBpbml0RXZlbnRzKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluaXRTbGlkZXJUcmFuc2Zvcm1TdHlsZUNoZWNrKCkge1xcbiAgICBpZiAoYXV0b1dpZHRoICYmIHNsaWRlQ291bnQgPiAxKSB7XFxuICAgICAgLy8gY2hlY2sgc3R5bGVzIGFwcGxpY2F0aW9uXFxuICAgICAgdmFyIG51bSA9IGxvb3AgPyBpbmRleCA6IHNsaWRlQ291bnQgLSAxO1xcblxcbiAgICAgIChmdW5jdGlvbiBzdHlsZXNBcHBsaWNhdGlvbkNoZWNrKCkge1xcbiAgICAgICAgdmFyIGxlZnQgPSBzbGlkZUl0ZW1zW251bV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcXG4gICAgICAgIHZhciByaWdodCA9IHNsaWRlSXRlbXNbbnVtIC0gMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XFxuICAgICAgICBNYXRoLmFicyhsZWZ0IC0gcmlnaHQpIDw9IDEgPyBpbml0U2xpZGVyVHJhbnNmb3JtQ29yZSgpIDogc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHN0eWxlc0FwcGxpY2F0aW9uQ2hlY2soKTtcXG4gICAgICAgIH0sIDE2KTtcXG4gICAgICB9KSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluaXRTbGlkZXJUcmFuc2Zvcm1Db3JlKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluaXRTbGlkZXJUcmFuc2Zvcm1Db3JlKCkge1xcbiAgICAvLyBydW4gRm4oKXMgd2hpY2ggYXJlIHJlbHkgb24gaW1hZ2UgbG9hZGluZ1xcbiAgICBpZiAoIWhvcml6b250YWwgfHwgYXV0b1dpZHRoKSB7XFxuICAgICAgc2V0U2xpZGVQb3NpdGlvbnMoKTtcXG5cXG4gICAgICBpZiAoYXV0b1dpZHRoKSB7XFxuICAgICAgICByaWdodEJvdW5kYXJ5ID0gZ2V0UmlnaHRCb3VuZGFyeSgpO1xcblxcbiAgICAgICAgaWYgKGZyZWV6YWJsZSkge1xcbiAgICAgICAgICBmcmVlemUgPSBnZXRGcmVlemUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGluZGV4TWF4ID0gZ2V0SW5kZXhNYXgoKTsgLy8gPD0gc2xpZGVQb3NpdGlvbnMsIHJpZ2h0Qm91bmRhcnkgPD1cXG5cXG4gICAgICAgIHJlc2V0VmFyaWJsZXNXaGVuRGlzYWJsZShkaXNhYmxlIHx8IGZyZWV6ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHVwZGF0ZUNvbnRlbnRXcmFwcGVySGVpZ2h0KCk7XFxuICAgICAgfVxcbiAgICB9IC8vIHNldCBjb250YWluZXIgdHJhbnNmb3JtIHByb3BlcnR5XFxuXFxuXFxuICAgIGlmIChjYXJvdXNlbCkge1xcbiAgICAgIGRvQ29udGFpbmVyVHJhbnNmb3JtU2lsZW50KCk7XFxuICAgIH0gLy8gdXBkYXRlIHNsaWRlciB0b29scyBhbmQgZXZlbnRzXFxuXFxuXFxuICAgIGluaXRUb29scygpO1xcbiAgICBpbml0RXZlbnRzKCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbml0U2hlZXQoKSB7XFxuICAgIC8vIGdhbGxlcnk6XFxuICAgIC8vIHNldCBhbmltYXRpb24gY2xhc3NlcyBhbmQgbGVmdCB2YWx1ZSBmb3IgZ2FsbGVyeSBzbGlkZXJcXG4gICAgaWYgKCFjYXJvdXNlbCkge1xcbiAgICAgIGZvciAodmFyIGkgPSBpbmRleCwgbCA9IGluZGV4ICsgTWF0aC5taW4oc2xpZGVDb3VudCwgaXRlbXMpOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICB2YXIgaXRlbSA9IHNsaWRlSXRlbXNbaV07XFxuICAgICAgICBpdGVtLnN0eWxlLmxlZnQgPSAoaSAtIGluZGV4KSAqIDEwMCAvIGl0ZW1zICsgJyUnO1xcbiAgICAgICAgYWRkQ2xhc3MoaXRlbSwgYW5pbWF0ZUluKTtcXG4gICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIGFuaW1hdGVOb3JtYWwpO1xcbiAgICAgIH1cXG4gICAgfSAvLyAjIyMjIExBWU9VVFxcbiAgICAvLyAjIyBJTkxJTkUtQkxPQ0sgVlMgRkxPQVRcXG4gICAgLy8gIyMgUGVyY2VudGFnZUxheW91dDpcXG4gICAgLy8gc2xpZGVzOiBpbmxpbmUtYmxvY2tcXG4gICAgLy8gcmVtb3ZlIGJsYW5rIHNwYWNlIGJldHdlZW4gc2xpZGVzIGJ5IHNldCBmb250LXNpemU6IDBcXG4gICAgLy8gIyMgTm9uIFBlcmNlbnRhZ2VMYXlvdXQ6XFxuICAgIC8vIHNsaWRlczogZmxvYXRcXG4gICAgLy8gICAgICAgICBtYXJnaW4tcmlnaHQ6IC0xMDAlXFxuICAgIC8vICAgICAgICAgbWFyZ2luLWxlZnQ6IH5cXG4gICAgLy8gUmVzb3VyY2U6IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzE0N3VwMjQ1d3dUWGVRWXZlM0JSU0FENG9WY3ZRbXVHc0Z0ZUpPZUE1eE5RL2VkaXQ/dXNwPXNoYXJpbmdcXG5cXG5cXG4gICAgaWYgKGhvcml6b250YWwpIHtcXG4gICAgICBpZiAoUEVSQ0VOVEFHRUxBWU9VVCB8fCBhdXRvV2lkdGgpIHtcXG4gICAgICAgIGFkZENTU1J1bGUoc2hlZXQsICcjJyArIHNsaWRlSWQgKyAnID4gLnRucy1pdGVtJywgJ2ZvbnQtc2l6ZTonICsgd2luLmdldENvbXB1dGVkU3R5bGUoc2xpZGVJdGVtc1swXSkuZm9udFNpemUgKyAnOycsIGdldENzc1J1bGVzTGVuZ3RoKHNoZWV0KSk7XFxuICAgICAgICBhZGRDU1NSdWxlKHNoZWV0LCAnIycgKyBzbGlkZUlkLCAnZm9udC1zaXplOjA7JywgZ2V0Q3NzUnVsZXNMZW5ndGgoc2hlZXQpKTtcXG4gICAgICB9IGVsc2UgaWYgKGNhcm91c2VsKSB7XFxuICAgICAgICBmb3JFYWNoKHNsaWRlSXRlbXMsIGZ1bmN0aW9uIChzbGlkZSwgaSkge1xcbiAgICAgICAgICBzbGlkZS5zdHlsZS5tYXJnaW5MZWZ0ID0gZ2V0U2xpZGVNYXJnaW5MZWZ0KGkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9IC8vICMjIEJBU0lDIFNUWUxFU1xcblxcblxcbiAgICBpZiAoQ1NTTVEpIHtcXG4gICAgICAvLyBtaWRkbGUgd3JhcHBlciBzdHlsZVxcbiAgICAgIGlmIChUUkFOU0lUSU9ORFVSQVRJT04pIHtcXG4gICAgICAgIHZhciBzdHIgPSBtaWRkbGVXcmFwcGVyICYmIG9wdGlvbnMuYXV0b0hlaWdodCA/IGdldFRyYW5zaXRpb25EdXJhdGlvblN0eWxlKG9wdGlvbnMuc3BlZWQpIDogJyc7XFxuICAgICAgICBhZGRDU1NSdWxlKHNoZWV0LCAnIycgKyBzbGlkZUlkICsgJy1tdycsIHN0ciwgZ2V0Q3NzUnVsZXNMZW5ndGgoc2hlZXQpKTtcXG4gICAgICB9IC8vIGlubmVyIHdyYXBwZXIgc3R5bGVzXFxuXFxuXFxuICAgICAgc3RyID0gZ2V0SW5uZXJXcmFwcGVyU3R5bGVzKG9wdGlvbnMuZWRnZVBhZGRpbmcsIG9wdGlvbnMuZ3V0dGVyLCBvcHRpb25zLmZpeGVkV2lkdGgsIG9wdGlvbnMuc3BlZWQsIG9wdGlvbnMuYXV0b0hlaWdodCk7XFxuICAgICAgYWRkQ1NTUnVsZShzaGVldCwgJyMnICsgc2xpZGVJZCArICctaXcnLCBzdHIsIGdldENzc1J1bGVzTGVuZ3RoKHNoZWV0KSk7IC8vIGNvbnRhaW5lciBzdHlsZXNcXG5cXG4gICAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICAgIHN0ciA9IGhvcml6b250YWwgJiYgIWF1dG9XaWR0aCA/ICd3aWR0aDonICsgZ2V0Q29udGFpbmVyV2lkdGgob3B0aW9ucy5maXhlZFdpZHRoLCBvcHRpb25zLmd1dHRlciwgb3B0aW9ucy5pdGVtcykgKyAnOycgOiAnJztcXG5cXG4gICAgICAgIGlmIChUUkFOU0lUSU9ORFVSQVRJT04pIHtcXG4gICAgICAgICAgc3RyICs9IGdldFRyYW5zaXRpb25EdXJhdGlvblN0eWxlKHNwZWVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFkZENTU1J1bGUoc2hlZXQsICcjJyArIHNsaWRlSWQsIHN0ciwgZ2V0Q3NzUnVsZXNMZW5ndGgoc2hlZXQpKTtcXG4gICAgICB9IC8vIHNsaWRlIHN0eWxlc1xcblxcblxcbiAgICAgIHN0ciA9IGhvcml6b250YWwgJiYgIWF1dG9XaWR0aCA/IGdldFNsaWRlV2lkdGhTdHlsZShvcHRpb25zLmZpeGVkV2lkdGgsIG9wdGlvbnMuZ3V0dGVyLCBvcHRpb25zLml0ZW1zKSA6ICcnO1xcblxcbiAgICAgIGlmIChvcHRpb25zLmd1dHRlcikge1xcbiAgICAgICAgc3RyICs9IGdldFNsaWRlR3V0dGVyU3R5bGUob3B0aW9ucy5ndXR0ZXIpO1xcbiAgICAgIH0gLy8gc2V0IGdhbGxlcnkgaXRlbXMgdHJhbnNpdGlvbi1kdXJhdGlvblxcblxcblxcbiAgICAgIGlmICghY2Fyb3VzZWwpIHtcXG4gICAgICAgIGlmIChUUkFOU0lUSU9ORFVSQVRJT04pIHtcXG4gICAgICAgICAgc3RyICs9IGdldFRyYW5zaXRpb25EdXJhdGlvblN0eWxlKHNwZWVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChBTklNQVRJT05EVVJBVElPTikge1xcbiAgICAgICAgICBzdHIgKz0gZ2V0QW5pbWF0aW9uRHVyYXRpb25TdHlsZShzcGVlZCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdHIpIHtcXG4gICAgICAgIGFkZENTU1J1bGUoc2hlZXQsICcjJyArIHNsaWRlSWQgKyAnID4gLnRucy1pdGVtJywgc3RyLCBnZXRDc3NSdWxlc0xlbmd0aChzaGVldCkpO1xcbiAgICAgIH0gLy8gbm9uIENTUyBtZWRpYXF1ZXJpZXM6IElFOFxcbiAgICAgIC8vICMjIHVwZGF0ZSBpbm5lciB3cmFwcGVyLCBjb250YWluZXIsIHNsaWRlcyBpZiBuZWVkZWRcXG4gICAgICAvLyBzZXQgaW5saW5lIHN0eWxlcyBmb3IgaW5uZXIgd3JhcHBlciAmIGNvbnRhaW5lclxcbiAgICAgIC8vIGluc2VydCBzdHlsZXNoZWV0IChvbmUgbGluZSkgZm9yIHNsaWRlcyBvbmx5IChzaW5jZSBzbGlkZXMgYXJlIG1hbnkpXFxuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWlkZGxlIHdyYXBwZXIgc3R5bGVzXFxuICAgICAgdXBkYXRlX2Nhcm91c2VsX3RyYW5zaXRpb25fZHVyYXRpb24oKTsgLy8gaW5uZXIgd3JhcHBlciBzdHlsZXNcXG5cXG4gICAgICBpbm5lcldyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IGdldElubmVyV3JhcHBlclN0eWxlcyhlZGdlUGFkZGluZywgZ3V0dGVyLCBmaXhlZFdpZHRoLCBhdXRvSGVpZ2h0KTsgLy8gY29udGFpbmVyIHN0eWxlc1xcblxcbiAgICAgIGlmIChjYXJvdXNlbCAmJiBob3Jpem9udGFsICYmICFhdXRvV2lkdGgpIHtcXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGdldENvbnRhaW5lcldpZHRoKGZpeGVkV2lkdGgsIGd1dHRlciwgaXRlbXMpO1xcbiAgICAgIH0gLy8gc2xpZGUgc3R5bGVzXFxuXFxuXFxuICAgICAgdmFyIHN0ciA9IGhvcml6b250YWwgJiYgIWF1dG9XaWR0aCA/IGdldFNsaWRlV2lkdGhTdHlsZShmaXhlZFdpZHRoLCBndXR0ZXIsIGl0ZW1zKSA6ICcnO1xcblxcbiAgICAgIGlmIChndXR0ZXIpIHtcXG4gICAgICAgIHN0ciArPSBnZXRTbGlkZUd1dHRlclN0eWxlKGd1dHRlcik7XFxuICAgICAgfSAvLyBhcHBlbmQgdG8gdGhlIGxhc3QgbGluZVxcblxcblxcbiAgICAgIGlmIChzdHIpIHtcXG4gICAgICAgIGFkZENTU1J1bGUoc2hlZXQsICcjJyArIHNsaWRlSWQgKyAnID4gLnRucy1pdGVtJywgc3RyLCBnZXRDc3NSdWxlc0xlbmd0aChzaGVldCkpO1xcbiAgICAgIH1cXG4gICAgfSAvLyAjIyBNRURJQVFVRVJJRVNcXG5cXG5cXG4gICAgaWYgKHJlc3BvbnNpdmUgJiYgQ1NTTVEpIHtcXG4gICAgICBmb3IgKHZhciBicCBpbiByZXNwb25zaXZlKSB7XFxuICAgICAgICAvLyBicDogY29udmVydCBzdHJpbmcgdG8gbnVtYmVyXFxuICAgICAgICBicCA9IHBhcnNlSW50KGJwKTtcXG4gICAgICAgIHZhciBvcHRzID0gcmVzcG9uc2l2ZVticF0sXFxuICAgICAgICAgICAgc3RyID0gJycsXFxuICAgICAgICAgICAgbWlkZGxlV3JhcHBlclN0ciA9ICcnLFxcbiAgICAgICAgICAgIGlubmVyV3JhcHBlclN0ciA9ICcnLFxcbiAgICAgICAgICAgIGNvbnRhaW5lclN0ciA9ICcnLFxcbiAgICAgICAgICAgIHNsaWRlU3RyID0gJycsXFxuICAgICAgICAgICAgaXRlbXNCUCA9ICFhdXRvV2lkdGggPyBnZXRPcHRpb24oJ2l0ZW1zJywgYnApIDogbnVsbCxcXG4gICAgICAgICAgICBmaXhlZFdpZHRoQlAgPSBnZXRPcHRpb24oJ2ZpeGVkV2lkdGgnLCBicCksXFxuICAgICAgICAgICAgc3BlZWRCUCA9IGdldE9wdGlvbignc3BlZWQnLCBicCksXFxuICAgICAgICAgICAgZWRnZVBhZGRpbmdCUCA9IGdldE9wdGlvbignZWRnZVBhZGRpbmcnLCBicCksXFxuICAgICAgICAgICAgYXV0b0hlaWdodEJQID0gZ2V0T3B0aW9uKCdhdXRvSGVpZ2h0JywgYnApLFxcbiAgICAgICAgICAgIGd1dHRlckJQID0gZ2V0T3B0aW9uKCdndXR0ZXInLCBicCk7IC8vIG1pZGRsZSB3cmFwcGVyIHN0cmluZ1xcblxcbiAgICAgICAgaWYgKFRSQU5TSVRJT05EVVJBVElPTiAmJiBtaWRkbGVXcmFwcGVyICYmIGdldE9wdGlvbignYXV0b0hlaWdodCcsIGJwKSAmJiAnc3BlZWQnIGluIG9wdHMpIHtcXG4gICAgICAgICAgbWlkZGxlV3JhcHBlclN0ciA9ICcjJyArIHNsaWRlSWQgKyAnLW13eycgKyBnZXRUcmFuc2l0aW9uRHVyYXRpb25TdHlsZShzcGVlZEJQKSArICd9JztcXG4gICAgICAgIH0gLy8gaW5uZXIgd3JhcHBlciBzdHJpbmdcXG5cXG5cXG4gICAgICAgIGlmICgnZWRnZVBhZGRpbmcnIGluIG9wdHMgfHwgJ2d1dHRlcicgaW4gb3B0cykge1xcbiAgICAgICAgICBpbm5lcldyYXBwZXJTdHIgPSAnIycgKyBzbGlkZUlkICsgJy1pd3snICsgZ2V0SW5uZXJXcmFwcGVyU3R5bGVzKGVkZ2VQYWRkaW5nQlAsIGd1dHRlckJQLCBmaXhlZFdpZHRoQlAsIHNwZWVkQlAsIGF1dG9IZWlnaHRCUCkgKyAnfSc7XFxuICAgICAgICB9IC8vIGNvbnRhaW5lciBzdHJpbmdcXG5cXG5cXG4gICAgICAgIGlmIChjYXJvdXNlbCAmJiBob3Jpem9udGFsICYmICFhdXRvV2lkdGggJiYgKCdmaXhlZFdpZHRoJyBpbiBvcHRzIHx8ICdpdGVtcycgaW4gb3B0cyB8fCBmaXhlZFdpZHRoICYmICdndXR0ZXInIGluIG9wdHMpKSB7XFxuICAgICAgICAgIGNvbnRhaW5lclN0ciA9ICd3aWR0aDonICsgZ2V0Q29udGFpbmVyV2lkdGgoZml4ZWRXaWR0aEJQLCBndXR0ZXJCUCwgaXRlbXNCUCkgKyAnOyc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoVFJBTlNJVElPTkRVUkFUSU9OICYmICdzcGVlZCcgaW4gb3B0cykge1xcbiAgICAgICAgICBjb250YWluZXJTdHIgKz0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUoc3BlZWRCUCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGFpbmVyU3RyKSB7XFxuICAgICAgICAgIGNvbnRhaW5lclN0ciA9ICcjJyArIHNsaWRlSWQgKyAneycgKyBjb250YWluZXJTdHIgKyAnfSc7XFxuICAgICAgICB9IC8vIHNsaWRlIHN0cmluZ1xcblxcblxcbiAgICAgICAgaWYgKCdmaXhlZFdpZHRoJyBpbiBvcHRzIHx8IGZpeGVkV2lkdGggJiYgJ2d1dHRlcicgaW4gb3B0cyB8fCAhY2Fyb3VzZWwgJiYgJ2l0ZW1zJyBpbiBvcHRzKSB7XFxuICAgICAgICAgIHNsaWRlU3RyICs9IGdldFNsaWRlV2lkdGhTdHlsZShmaXhlZFdpZHRoQlAsIGd1dHRlckJQLCBpdGVtc0JQKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICgnZ3V0dGVyJyBpbiBvcHRzKSB7XFxuICAgICAgICAgIHNsaWRlU3RyICs9IGdldFNsaWRlR3V0dGVyU3R5bGUoZ3V0dGVyQlApO1xcbiAgICAgICAgfSAvLyBzZXQgZ2FsbGVyeSBpdGVtcyB0cmFuc2l0aW9uLWR1cmF0aW9uXFxuXFxuXFxuICAgICAgICBpZiAoIWNhcm91c2VsICYmICdzcGVlZCcgaW4gb3B0cykge1xcbiAgICAgICAgICBpZiAoVFJBTlNJVElPTkRVUkFUSU9OKSB7XFxuICAgICAgICAgICAgc2xpZGVTdHIgKz0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUoc3BlZWRCUCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKEFOSU1BVElPTkRVUkFUSU9OKSB7XFxuICAgICAgICAgICAgc2xpZGVTdHIgKz0gZ2V0QW5pbWF0aW9uRHVyYXRpb25TdHlsZShzcGVlZEJQKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHNsaWRlU3RyKSB7XFxuICAgICAgICAgIHNsaWRlU3RyID0gJyMnICsgc2xpZGVJZCArICcgPiAudG5zLWl0ZW17JyArIHNsaWRlU3RyICsgJ30nO1xcbiAgICAgICAgfSAvLyBhZGQgdXBcXG5cXG5cXG4gICAgICAgIHN0ciA9IG1pZGRsZVdyYXBwZXJTdHIgKyBpbm5lcldyYXBwZXJTdHIgKyBjb250YWluZXJTdHIgKyBzbGlkZVN0cjtcXG5cXG4gICAgICAgIGlmIChzdHIpIHtcXG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZSgnQG1lZGlhIChtaW4td2lkdGg6ICcgKyBicCAvIDE2ICsgJ2VtKSB7JyArIHN0ciArICd9Jywgc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluaXRUb29scygpIHtcXG4gICAgLy8gPT0gc2xpZGVzID09XFxuICAgIHVwZGF0ZVNsaWRlU3RhdHVzKCk7IC8vID09IGxpdmUgcmVnaW9uID09XFxuXFxuICAgIG91dGVyV3JhcHBlci5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCAnPGRpdiBjbGFzcz1cXFwidG5zLWxpdmVyZWdpb24gdG5zLXZpc3VhbGx5LWhpZGRlblxcXCIgYXJpYS1saXZlPVxcXCJwb2xpdGVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIj5zbGlkZSA8c3BhbiBjbGFzcz1cXFwiY3VycmVudFxcXCI+JyArIGdldExpdmVSZWdpb25TdHIoKSArICc8L3NwYW4+ICBvZiAnICsgc2xpZGVDb3VudCArICc8L2Rpdj4nKTtcXG4gICAgbGl2ZXJlZ2lvbkN1cnJlbnQgPSBvdXRlcldyYXBwZXIucXVlcnlTZWxlY3RvcignLnRucy1saXZlcmVnaW9uIC5jdXJyZW50Jyk7IC8vID09IGF1dG9wbGF5SW5pdCA9PVxcblxcbiAgICBpZiAoaGFzQXV0b3BsYXkpIHtcXG4gICAgICB2YXIgdHh0ID0gYXV0b3BsYXkgPyAnc3RvcCcgOiAnc3RhcnQnO1xcblxcbiAgICAgIGlmIChhdXRvcGxheUJ1dHRvbikge1xcbiAgICAgICAgc2V0QXR0cnMoYXV0b3BsYXlCdXR0b24sIHtcXG4gICAgICAgICAgJ2RhdGEtYWN0aW9uJzogdHh0XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXV0b3BsYXlCdXR0b25PdXRwdXQpIHtcXG4gICAgICAgIG91dGVyV3JhcHBlci5pbnNlcnRBZGphY2VudEhUTUwoZ2V0SW5zZXJ0UG9zaXRpb24ob3B0aW9ucy5hdXRvcGxheVBvc2l0aW9uKSwgJzxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBkYXRhLWFjdGlvbj1cXFwiJyArIHR4dCArICdcXFwiPicgKyBhdXRvcGxheUh0bWxTdHJpbmdzWzBdICsgdHh0ICsgYXV0b3BsYXlIdG1sU3RyaW5nc1sxXSArIGF1dG9wbGF5VGV4dFswXSArICc8L2J1dHRvbj4nKTtcXG4gICAgICAgIGF1dG9wbGF5QnV0dG9uID0gb3V0ZXJXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFjdGlvbl0nKTtcXG4gICAgICB9IC8vIGFkZCBldmVudFxcblxcblxcbiAgICAgIGlmIChhdXRvcGxheUJ1dHRvbikge1xcbiAgICAgICAgYWRkRXZlbnRzKGF1dG9wbGF5QnV0dG9uLCB7XFxuICAgICAgICAgICdjbGljayc6IHRvZ2dsZUF1dG9wbGF5XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGF1dG9wbGF5KSB7XFxuICAgICAgICBzdGFydEF1dG9wbGF5KCk7XFxuXFxuICAgICAgICBpZiAoYXV0b3BsYXlIb3ZlclBhdXNlKSB7XFxuICAgICAgICAgIGFkZEV2ZW50cyhjb250YWluZXIsIGhvdmVyRXZlbnRzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhdXRvcGxheVJlc2V0T25WaXNpYmlsaXR5KSB7XFxuICAgICAgICAgIGFkZEV2ZW50cyhjb250YWluZXIsIHZpc2liaWxpdHlFdmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vID09IG5hdkluaXQgPT1cXG5cXG5cXG4gICAgaWYgKGhhc05hdikge1xcbiAgICAgIC8vIHdpbGwgbm90IGhpZGUgdGhlIG5hdnMgaW4gY2FzZSB0aGV5J3JlIHRodW1ibmFpbHNcXG5cXG4gICAgICBpZiAobmF2Q29udGFpbmVyKSB7XFxuICAgICAgICBzZXRBdHRycyhuYXZDb250YWluZXIsIHtcXG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiAnQ2Fyb3VzZWwgUGFnaW5hdGlvbidcXG4gICAgICAgIH0pO1xcbiAgICAgICAgbmF2SXRlbXMgPSBuYXZDb250YWluZXIuY2hpbGRyZW47XFxuICAgICAgICBmb3JFYWNoKG5hdkl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xcbiAgICAgICAgICBzZXRBdHRycyhpdGVtLCB7XFxuICAgICAgICAgICAgJ2RhdGEtbmF2JzogaSxcXG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnLFxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogbmF2U3RyICsgKGkgKyAxKSxcXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHNsaWRlSWRcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTsgLy8gZ2VuZXJhdGVkIG5hdlxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgbmF2SHRtbCA9ICcnLFxcbiAgICAgICAgICAgIGhpZGRlblN0ciA9IG5hdkFzVGh1bWJuYWlscyA/ICcnIDogJ3N0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiJztcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVDb3VudDsgaSsrKSB7XFxuICAgICAgICAgIC8vIGhpZGUgbmF2IGl0ZW1zIGJ5IGRlZmF1bHRcXG4gICAgICAgICAgbmF2SHRtbCArPSAnPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtbmF2PVxcXCInICsgaSArICdcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgYXJpYS1jb250cm9scz1cXFwiJyArIHNsaWRlSWQgKyAnXFxcIiAnICsgaGlkZGVuU3RyICsgJyBhcmlhLWxhYmVsPVxcXCInICsgbmF2U3RyICsgKGkgKyAxKSArICdcXFwiPjwvYnV0dG9uPic7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBuYXZIdG1sID0gJzxkaXYgY2xhc3M9XFxcInRucy1uYXZcXFwiIGFyaWEtbGFiZWw9XFxcIkNhcm91c2VsIFBhZ2luYXRpb25cXFwiPicgKyBuYXZIdG1sICsgJzwvZGl2Pic7XFxuICAgICAgICBvdXRlcldyYXBwZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKGdldEluc2VydFBvc2l0aW9uKG9wdGlvbnMubmF2UG9zaXRpb24pLCBuYXZIdG1sKTtcXG4gICAgICAgIG5hdkNvbnRhaW5lciA9IG91dGVyV3JhcHBlci5xdWVyeVNlbGVjdG9yKCcudG5zLW5hdicpO1xcbiAgICAgICAgbmF2SXRlbXMgPSBuYXZDb250YWluZXIuY2hpbGRyZW47XFxuICAgICAgfVxcblxcbiAgICAgIHVwZGF0ZU5hdlZpc2liaWxpdHkoKTsgLy8gYWRkIHRyYW5zaXRpb25cXG5cXG4gICAgICBpZiAoVFJBTlNJVElPTkRVUkFUSU9OKSB7XFxuICAgICAgICB2YXIgcHJlZml4ID0gVFJBTlNJVElPTkRVUkFUSU9OLnN1YnN0cmluZygwLCBUUkFOU0lUSU9ORFVSQVRJT04ubGVuZ3RoIC0gMTgpLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgc3RyID0gJ3RyYW5zaXRpb246IGFsbCAnICsgc3BlZWQgLyAxMDAwICsgJ3MnO1xcblxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcbiAgICAgICAgICBzdHIgPSAnLScgKyBwcmVmaXggKyAnLScgKyBzdHI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhZGRDU1NSdWxlKHNoZWV0LCAnW2FyaWEtY29udHJvbHNePScgKyBzbGlkZUlkICsgJy1pdGVtXScsIHN0ciwgZ2V0Q3NzUnVsZXNMZW5ndGgoc2hlZXQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgc2V0QXR0cnMobmF2SXRlbXNbbmF2Q3VycmVudEluZGV4XSwge1xcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiBuYXZTdHIgKyAobmF2Q3VycmVudEluZGV4ICsgMSkgKyBuYXZTdHJDdXJyZW50XFxuICAgICAgfSk7XFxuICAgICAgcmVtb3ZlQXR0cnMobmF2SXRlbXNbbmF2Q3VycmVudEluZGV4XSwgJ3RhYmluZGV4Jyk7XFxuICAgICAgYWRkQ2xhc3MobmF2SXRlbXNbbmF2Q3VycmVudEluZGV4XSwgbmF2QWN0aXZlQ2xhc3MpOyAvLyBhZGQgZXZlbnRzXFxuXFxuICAgICAgYWRkRXZlbnRzKG5hdkNvbnRhaW5lciwgbmF2RXZlbnRzKTtcXG4gICAgfSAvLyA9PSBjb250cm9sc0luaXQgPT1cXG5cXG5cXG4gICAgaWYgKGhhc0NvbnRyb2xzKSB7XFxuICAgICAgaWYgKCFjb250cm9sc0NvbnRhaW5lciAmJiAoIXByZXZCdXR0b24gfHwgIW5leHRCdXR0b24pKSB7XFxuICAgICAgICBvdXRlcldyYXBwZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKGdldEluc2VydFBvc2l0aW9uKG9wdGlvbnMuY29udHJvbHNQb3NpdGlvbiksICc8ZGl2IGNsYXNzPVxcXCJ0bnMtY29udHJvbHNcXFwiIGFyaWEtbGFiZWw9XFxcIkNhcm91c2VsIE5hdmlnYXRpb25cXFwiIHRhYmluZGV4PVxcXCIwXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS1jb250cm9scz1cXFwicHJldlxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCInICsgc2xpZGVJZCArICdcXFwiPicgKyBjb250cm9sc1RleHRbMF0gKyAnPC9idXR0b24+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtY29udHJvbHM9XFxcIm5leHRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgYXJpYS1jb250cm9scz1cXFwiJyArIHNsaWRlSWQgKyAnXFxcIj4nICsgY29udHJvbHNUZXh0WzFdICsgJzwvYnV0dG9uPjwvZGl2PicpO1xcbiAgICAgICAgY29udHJvbHNDb250YWluZXIgPSBvdXRlcldyYXBwZXIucXVlcnlTZWxlY3RvcignLnRucy1jb250cm9scycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXByZXZCdXR0b24gfHwgIW5leHRCdXR0b24pIHtcXG4gICAgICAgIHByZXZCdXR0b24gPSBjb250cm9sc0NvbnRhaW5lci5jaGlsZHJlblswXTtcXG4gICAgICAgIG5leHRCdXR0b24gPSBjb250cm9sc0NvbnRhaW5lci5jaGlsZHJlblsxXTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuY29udHJvbHNDb250YWluZXIpIHtcXG4gICAgICAgIHNldEF0dHJzKGNvbnRyb2xzQ29udGFpbmVyLCB7XFxuICAgICAgICAgICdhcmlhLWxhYmVsJzogJ0Nhcm91c2VsIE5hdmlnYXRpb24nLFxcbiAgICAgICAgICAndGFiaW5kZXgnOiAnMCdcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5jb250cm9sc0NvbnRhaW5lciB8fCBvcHRpb25zLnByZXZCdXR0b24gJiYgb3B0aW9ucy5uZXh0QnV0dG9uKSB7XFxuICAgICAgICBzZXRBdHRycyhbcHJldkJ1dHRvbiwgbmV4dEJ1dHRvbl0sIHtcXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzbGlkZUlkLFxcbiAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuY29udHJvbHNDb250YWluZXIgfHwgb3B0aW9ucy5wcmV2QnV0dG9uICYmIG9wdGlvbnMubmV4dEJ1dHRvbikge1xcbiAgICAgICAgc2V0QXR0cnMocHJldkJ1dHRvbiwge1xcbiAgICAgICAgICAnZGF0YS1jb250cm9scyc6ICdwcmV2J1xcbiAgICAgICAgfSk7XFxuICAgICAgICBzZXRBdHRycyhuZXh0QnV0dG9uLCB7XFxuICAgICAgICAgICdkYXRhLWNvbnRyb2xzJzogJ25leHQnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcHJldklzQnV0dG9uID0gaXNCdXR0b24ocHJldkJ1dHRvbik7XFxuICAgICAgbmV4dElzQnV0dG9uID0gaXNCdXR0b24obmV4dEJ1dHRvbik7XFxuICAgICAgdXBkYXRlQ29udHJvbHNTdGF0dXMoKTsgLy8gYWRkIGV2ZW50c1xcblxcbiAgICAgIGlmIChjb250cm9sc0NvbnRhaW5lcikge1xcbiAgICAgICAgYWRkRXZlbnRzKGNvbnRyb2xzQ29udGFpbmVyLCBjb250cm9sc0V2ZW50cyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGFkZEV2ZW50cyhwcmV2QnV0dG9uLCBjb250cm9sc0V2ZW50cyk7XFxuICAgICAgICBhZGRFdmVudHMobmV4dEJ1dHRvbiwgY29udHJvbHNFdmVudHMpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBoaWRlIHRvb2xzIGlmIG5lZWRlZFxcblxcblxcbiAgICBkaXNhYmxlVUkoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMoKSB7XFxuICAgIC8vIGFkZCBldmVudHNcXG4gICAgaWYgKGNhcm91c2VsICYmIFRSQU5TSVRJT05FTkQpIHtcXG4gICAgICB2YXIgZXZlID0ge307XFxuICAgICAgZXZlW1RSQU5TSVRJT05FTkRdID0gb25UcmFuc2l0aW9uRW5kO1xcbiAgICAgIGFkZEV2ZW50cyhjb250YWluZXIsIGV2ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRvdWNoKSB7XFxuICAgICAgYWRkRXZlbnRzKGNvbnRhaW5lciwgdG91Y2hFdmVudHMsIG9wdGlvbnMucHJldmVudFNjcm9sbE9uVG91Y2gpO1xcbiAgICB9XFxuXFxuICAgIGlmIChtb3VzZURyYWcpIHtcXG4gICAgICBhZGRFdmVudHMoY29udGFpbmVyLCBkcmFnRXZlbnRzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXJyb3dLZXlzKSB7XFxuICAgICAgYWRkRXZlbnRzKGRvYywgZG9jbWVudEtleWRvd25FdmVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKG5lc3RlZCA9PT0gJ2lubmVyJykge1xcbiAgICAgIGV2ZW50cy5vbignb3V0ZXJSZXNpemVkJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmVzaXplVGFza3MoKTtcXG4gICAgICAgIGV2ZW50cy5lbWl0KCdpbm5lckxvYWRlZCcsIGluZm8oKSk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSBpZiAocmVzcG9uc2l2ZSB8fCBmaXhlZFdpZHRoIHx8IGF1dG9XaWR0aCB8fCBhdXRvSGVpZ2h0IHx8ICFob3Jpem9udGFsKSB7XFxuICAgICAgYWRkRXZlbnRzKHdpbiwge1xcbiAgICAgICAgJ3Jlc2l6ZSc6IG9uUmVzaXplXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGF1dG9IZWlnaHQpIHtcXG4gICAgICBpZiAobmVzdGVkID09PSAnb3V0ZXInKSB7XFxuICAgICAgICBldmVudHMub24oJ2lubmVyTG9hZGVkJywgZG9BdXRvSGVpZ2h0KTtcXG4gICAgICB9IGVsc2UgaWYgKCFkaXNhYmxlKSB7XFxuICAgICAgICBkb0F1dG9IZWlnaHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZG9MYXp5TG9hZCgpO1xcblxcbiAgICBpZiAoZGlzYWJsZSkge1xcbiAgICAgIGRpc2FibGVTbGlkZXIoKTtcXG4gICAgfSBlbHNlIGlmIChmcmVlemUpIHtcXG4gICAgICBmcmVlemVTbGlkZXIoKTtcXG4gICAgfVxcblxcbiAgICBldmVudHMub24oJ2luZGV4Q2hhbmdlZCcsIGFkZGl0aW9uYWxVcGRhdGVzKTtcXG5cXG4gICAgaWYgKG5lc3RlZCA9PT0gJ2lubmVyJykge1xcbiAgICAgIGV2ZW50cy5lbWl0KCdpbm5lckxvYWRlZCcsIGluZm8oKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvbkluaXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBvbkluaXQoaW5mbygpKTtcXG4gICAgfVxcblxcbiAgICBpc09uID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgIC8vIHNoZWV0XFxuICAgIHNoZWV0LmRpc2FibGVkID0gdHJ1ZTtcXG5cXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSkge1xcbiAgICAgIHNoZWV0Lm93bmVyTm9kZS5yZW1vdmUoKTtcXG4gICAgfSAvLyByZW1vdmUgd2luIGV2ZW50IGxpc3RlbmVyc1xcblxcblxcbiAgICByZW1vdmVFdmVudHMod2luLCB7XFxuICAgICAgJ3Jlc2l6ZSc6IG9uUmVzaXplXFxuICAgIH0pOyAvLyBhcnJvd0tleXMsIGNvbnRyb2xzLCBuYXZcXG5cXG4gICAgaWYgKGFycm93S2V5cykge1xcbiAgICAgIHJlbW92ZUV2ZW50cyhkb2MsIGRvY21lbnRLZXlkb3duRXZlbnQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb250cm9sc0NvbnRhaW5lcikge1xcbiAgICAgIHJlbW92ZUV2ZW50cyhjb250cm9sc0NvbnRhaW5lciwgY29udHJvbHNFdmVudHMpO1xcbiAgICB9XFxuXFxuICAgIGlmIChuYXZDb250YWluZXIpIHtcXG4gICAgICByZW1vdmVFdmVudHMobmF2Q29udGFpbmVyLCBuYXZFdmVudHMpO1xcbiAgICB9IC8vIGF1dG9wbGF5XFxuXFxuXFxuICAgIHJlbW92ZUV2ZW50cyhjb250YWluZXIsIGhvdmVyRXZlbnRzKTtcXG4gICAgcmVtb3ZlRXZlbnRzKGNvbnRhaW5lciwgdmlzaWJpbGl0eUV2ZW50KTtcXG5cXG4gICAgaWYgKGF1dG9wbGF5QnV0dG9uKSB7XFxuICAgICAgcmVtb3ZlRXZlbnRzKGF1dG9wbGF5QnV0dG9uLCB7XFxuICAgICAgICAnY2xpY2snOiB0b2dnbGVBdXRvcGxheVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChhdXRvcGxheSkge1xcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b3BsYXlUaW1lcik7XFxuICAgIH0gLy8gY29udGFpbmVyXFxuXFxuXFxuICAgIGlmIChjYXJvdXNlbCAmJiBUUkFOU0lUSU9ORU5EKSB7XFxuICAgICAgdmFyIGV2ZSA9IHt9O1xcbiAgICAgIGV2ZVtUUkFOU0lUSU9ORU5EXSA9IG9uVHJhbnNpdGlvbkVuZDtcXG4gICAgICByZW1vdmVFdmVudHMoY29udGFpbmVyLCBldmUpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0b3VjaCkge1xcbiAgICAgIHJlbW92ZUV2ZW50cyhjb250YWluZXIsIHRvdWNoRXZlbnRzKTtcXG4gICAgfVxcblxcbiAgICBpZiAobW91c2VEcmFnKSB7XFxuICAgICAgcmVtb3ZlRXZlbnRzKGNvbnRhaW5lciwgZHJhZ0V2ZW50cyk7XFxuICAgIH0gLy8gY2FjaGUgT2JqZWN0IHZhbHVlcyBpbiBvcHRpb25zICYmIHJlc2V0IEhUTUxcXG5cXG5cXG4gICAgdmFyIGh0bWxMaXN0ID0gW2NvbnRhaW5lckhUTUwsIGNvbnRyb2xzQ29udGFpbmVySFRNTCwgcHJldkJ1dHRvbkhUTUwsIG5leHRCdXR0b25IVE1MLCBuYXZDb250YWluZXJIVE1MLCBhdXRvcGxheUJ1dHRvbkhUTUxdO1xcbiAgICB0bnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcXG4gICAgICB2YXIgZWwgPSBpdGVtID09PSAnY29udGFpbmVyJyA/IG91dGVyV3JhcHBlciA6IG9wdGlvbnNbaXRlbV07XFxuXFxuICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgZWwpIHtcXG4gICAgICAgIHZhciBwcmV2RWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID8gZWwucHJldmlvdXNFbGVtZW50U2libGluZyA6IGZhbHNlLFxcbiAgICAgICAgICAgIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcXG4gICAgICAgIGVsLm91dGVySFRNTCA9IGh0bWxMaXN0W2ldO1xcbiAgICAgICAgb3B0aW9uc1tpdGVtXSA9IHByZXZFbCA/IHByZXZFbC5uZXh0RWxlbWVudFNpYmxpbmcgOiBwYXJlbnRFbC5maXJzdEVsZW1lbnRDaGlsZDtcXG4gICAgICB9XFxuICAgIH0pOyAvLyByZXNldCB2YXJpYWJsZXNcXG5cXG4gICAgdG5zTGlzdCA9IGFuaW1hdGVJbiA9IGFuaW1hdGVPdXQgPSBhbmltYXRlRGVsYXkgPSBhbmltYXRlTm9ybWFsID0gaG9yaXpvbnRhbCA9IG91dGVyV3JhcHBlciA9IGlubmVyV3JhcHBlciA9IGNvbnRhaW5lciA9IGNvbnRhaW5lclBhcmVudCA9IGNvbnRhaW5lckhUTUwgPSBzbGlkZUl0ZW1zID0gc2xpZGVDb3VudCA9IGJyZWFrcG9pbnRab25lID0gd2luZG93V2lkdGggPSBhdXRvV2lkdGggPSBmaXhlZFdpZHRoID0gZWRnZVBhZGRpbmcgPSBndXR0ZXIgPSB2aWV3cG9ydCA9IGl0ZW1zID0gc2xpZGVCeSA9IHZpZXdwb3J0TWF4ID0gYXJyb3dLZXlzID0gc3BlZWQgPSByZXdpbmQgPSBsb29wID0gYXV0b0hlaWdodCA9IHNoZWV0ID0gbGF6eWxvYWQgPSBzbGlkZVBvc2l0aW9ucyA9IHNsaWRlSXRlbXNPdXQgPSBjbG9uZUNvdW50ID0gc2xpZGVDb3VudE5ldyA9IGhhc1JpZ2h0RGVhZFpvbmUgPSByaWdodEJvdW5kYXJ5ID0gdXBkYXRlSW5kZXhCZWZvcmVUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtUHJlZml4ID0gdHJhbnNmb3JtUG9zdGZpeCA9IGdldEluZGV4TWF4ID0gaW5kZXggPSBpbmRleENhY2hlZCA9IGluZGV4TWluID0gaW5kZXhNYXggPSBzd2lwZUFuZ2xlID0gbW92ZURpcmVjdGlvbkV4cGVjdGVkID0gcnVubmluZyA9IG9uSW5pdCA9IGV2ZW50cyA9IG5ld0NvbnRhaW5lckNsYXNzZXMgPSBzbGlkZUlkID0gZGlzYWJsZSA9IGRpc2FibGVkID0gZnJlZXphYmxlID0gZnJlZXplID0gZnJvemVuID0gY29udHJvbHNFdmVudHMgPSBuYXZFdmVudHMgPSBob3ZlckV2ZW50cyA9IHZpc2liaWxpdHlFdmVudCA9IGRvY21lbnRLZXlkb3duRXZlbnQgPSB0b3VjaEV2ZW50cyA9IGRyYWdFdmVudHMgPSBoYXNDb250cm9scyA9IGhhc05hdiA9IG5hdkFzVGh1bWJuYWlscyA9IGhhc0F1dG9wbGF5ID0gaGFzVG91Y2ggPSBoYXNNb3VzZURyYWcgPSBzbGlkZUFjdGl2ZUNsYXNzID0gaW1nQ29tcGxldGVDbGFzcyA9IGltZ0V2ZW50cyA9IGltZ3NDb21wbGV0ZSA9IGNvbnRyb2xzID0gY29udHJvbHNUZXh0ID0gY29udHJvbHNDb250YWluZXIgPSBjb250cm9sc0NvbnRhaW5lckhUTUwgPSBwcmV2QnV0dG9uID0gbmV4dEJ1dHRvbiA9IHByZXZJc0J1dHRvbiA9IG5leHRJc0J1dHRvbiA9IG5hdiA9IG5hdkNvbnRhaW5lciA9IG5hdkNvbnRhaW5lckhUTUwgPSBuYXZJdGVtcyA9IHBhZ2VzID0gcGFnZXNDYWNoZWQgPSBuYXZDbGlja2VkID0gbmF2Q3VycmVudEluZGV4ID0gbmF2Q3VycmVudEluZGV4Q2FjaGVkID0gbmF2QWN0aXZlQ2xhc3MgPSBuYXZTdHIgPSBuYXZTdHJDdXJyZW50ID0gYXV0b3BsYXkgPSBhdXRvcGxheVRpbWVvdXQgPSBhdXRvcGxheURpcmVjdGlvbiA9IGF1dG9wbGF5VGV4dCA9IGF1dG9wbGF5SG92ZXJQYXVzZSA9IGF1dG9wbGF5QnV0dG9uID0gYXV0b3BsYXlCdXR0b25IVE1MID0gYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eSA9IGF1dG9wbGF5SHRtbFN0cmluZ3MgPSBhdXRvcGxheVRpbWVyID0gYW5pbWF0aW5nID0gYXV0b3BsYXlIb3ZlclBhdXNlZCA9IGF1dG9wbGF5VXNlclBhdXNlZCA9IGF1dG9wbGF5VmlzaWJpbGl0eVBhdXNlZCA9IGluaXRQb3NpdGlvbiA9IGxhc3RQb3NpdGlvbiA9IHRyYW5zbGF0ZUluaXQgPSBwYW5TdGFydCA9IHJhZkluZGV4ID0gZ2V0RGlzdCA9IHRvdWNoID0gbW91c2VEcmFnID0gbnVsbDsgLy8gY2hlY2sgdmFyaWFibGVzXFxuICAgIC8vIFthbmltYXRlSW4sIGFuaW1hdGVPdXQsIGFuaW1hdGVEZWxheSwgYW5pbWF0ZU5vcm1hbCwgaG9yaXpvbnRhbCwgb3V0ZXJXcmFwcGVyLCBpbm5lcldyYXBwZXIsIGNvbnRhaW5lciwgY29udGFpbmVyUGFyZW50LCBjb250YWluZXJIVE1MLCBzbGlkZUl0ZW1zLCBzbGlkZUNvdW50LCBicmVha3BvaW50Wm9uZSwgd2luZG93V2lkdGgsIGF1dG9XaWR0aCwgZml4ZWRXaWR0aCwgZWRnZVBhZGRpbmcsIGd1dHRlciwgdmlld3BvcnQsIGl0ZW1zLCBzbGlkZUJ5LCB2aWV3cG9ydE1heCwgYXJyb3dLZXlzLCBzcGVlZCwgcmV3aW5kLCBsb29wLCBhdXRvSGVpZ2h0LCBzaGVldCwgbGF6eWxvYWQsIHNsaWRlUG9zaXRpb25zLCBzbGlkZUl0ZW1zT3V0LCBjbG9uZUNvdW50LCBzbGlkZUNvdW50TmV3LCBoYXNSaWdodERlYWRab25lLCByaWdodEJvdW5kYXJ5LCB1cGRhdGVJbmRleEJlZm9yZVRyYW5zZm9ybSwgdHJhbnNmb3JtQXR0ciwgdHJhbnNmb3JtUHJlZml4LCB0cmFuc2Zvcm1Qb3N0Zml4LCBnZXRJbmRleE1heCwgaW5kZXgsIGluZGV4Q2FjaGVkLCBpbmRleE1pbiwgaW5kZXhNYXgsIHJlc2l6ZVRpbWVyLCBzd2lwZUFuZ2xlLCBtb3ZlRGlyZWN0aW9uRXhwZWN0ZWQsIHJ1bm5pbmcsIG9uSW5pdCwgZXZlbnRzLCBuZXdDb250YWluZXJDbGFzc2VzLCBzbGlkZUlkLCBkaXNhYmxlLCBkaXNhYmxlZCwgZnJlZXphYmxlLCBmcmVlemUsIGZyb3plbiwgY29udHJvbHNFdmVudHMsIG5hdkV2ZW50cywgaG92ZXJFdmVudHMsIHZpc2liaWxpdHlFdmVudCwgZG9jbWVudEtleWRvd25FdmVudCwgdG91Y2hFdmVudHMsIGRyYWdFdmVudHMsIGhhc0NvbnRyb2xzLCBoYXNOYXYsIG5hdkFzVGh1bWJuYWlscywgaGFzQXV0b3BsYXksIGhhc1RvdWNoLCBoYXNNb3VzZURyYWcsIHNsaWRlQWN0aXZlQ2xhc3MsIGltZ0NvbXBsZXRlQ2xhc3MsIGltZ0V2ZW50cywgaW1nc0NvbXBsZXRlLCBjb250cm9scywgY29udHJvbHNUZXh0LCBjb250cm9sc0NvbnRhaW5lciwgY29udHJvbHNDb250YWluZXJIVE1MLCBwcmV2QnV0dG9uLCBuZXh0QnV0dG9uLCBwcmV2SXNCdXR0b24sIG5leHRJc0J1dHRvbiwgbmF2LCBuYXZDb250YWluZXIsIG5hdkNvbnRhaW5lckhUTUwsIG5hdkl0ZW1zLCBwYWdlcywgcGFnZXNDYWNoZWQsIG5hdkNsaWNrZWQsIG5hdkN1cnJlbnRJbmRleCwgbmF2Q3VycmVudEluZGV4Q2FjaGVkLCBuYXZBY3RpdmVDbGFzcywgbmF2U3RyLCBuYXZTdHJDdXJyZW50LCBhdXRvcGxheSwgYXV0b3BsYXlUaW1lb3V0LCBhdXRvcGxheURpcmVjdGlvbiwgYXV0b3BsYXlUZXh0LCBhdXRvcGxheUhvdmVyUGF1c2UsIGF1dG9wbGF5QnV0dG9uLCBhdXRvcGxheUJ1dHRvbkhUTUwsIGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHksIGF1dG9wbGF5SHRtbFN0cmluZ3MsIGF1dG9wbGF5VGltZXIsIGFuaW1hdGluZywgYXV0b3BsYXlIb3ZlclBhdXNlZCwgYXV0b3BsYXlVc2VyUGF1c2VkLCBhdXRvcGxheVZpc2liaWxpdHlQYXVzZWQsIGluaXRQb3NpdGlvbiwgbGFzdFBvc2l0aW9uLCB0cmFuc2xhdGVJbml0LCBkaXNYLCBkaXNZLCBwYW5TdGFydCwgcmFmSW5kZXgsIGdldERpc3QsIHRvdWNoLCBtb3VzZURyYWcgXS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHsgaWYgKGl0ZW0gIT09IG51bGwpIHsgY29uc29sZS5sb2coaXRlbSk7IH0gfSk7XFxuXFxuICAgIGZvciAodmFyIGEgaW4gdGhpcykge1xcbiAgICAgIGlmIChhICE9PSAncmVidWlsZCcpIHtcXG4gICAgICAgIHRoaXNbYV0gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpc09uID0gZmFsc2U7XFxuICB9IC8vID09PSBPTiBSRVNJWkUgPT09XFxuICAvLyByZXNwb25zaXZlIHx8IGZpeGVkV2lkdGggfHwgYXV0b1dpZHRoIHx8ICFob3Jpem9udGFsXFxuXFxuXFxuICBmdW5jdGlvbiBvblJlc2l6ZShlKSB7XFxuICAgIHJhZihmdW5jdGlvbiAoKSB7XFxuICAgICAgcmVzaXplVGFza3MoZ2V0RXZlbnQoZSkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlc2l6ZVRhc2tzKGUpIHtcXG4gICAgaWYgKCFpc09uKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChuZXN0ZWQgPT09ICdvdXRlcicpIHtcXG4gICAgICBldmVudHMuZW1pdCgnb3V0ZXJSZXNpemVkJywgaW5mbyhlKSk7XFxuICAgIH1cXG5cXG4gICAgd2luZG93V2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xcbiAgICB2YXIgYnBDaGFuZ2VkLFxcbiAgICAgICAgYnJlYWtwb2ludFpvbmVUZW0gPSBicmVha3BvaW50Wm9uZSxcXG4gICAgICAgIG5lZWRDb250YWluZXJUcmFuc2Zvcm0gPSBmYWxzZTtcXG5cXG4gICAgaWYgKHJlc3BvbnNpdmUpIHtcXG4gICAgICBzZXRCcmVha3BvaW50Wm9uZSgpO1xcbiAgICAgIGJwQ2hhbmdlZCA9IGJyZWFrcG9pbnRab25lVGVtICE9PSBicmVha3BvaW50Wm9uZTsgLy8gaWYgKGhhc1JpZ2h0RGVhZFpvbmUpIHsgbmVlZENvbnRhaW5lclRyYW5zZm9ybSA9IHRydWU7IH0gLy8gKj9cXG5cXG4gICAgICBpZiAoYnBDaGFuZ2VkKSB7XFxuICAgICAgICBldmVudHMuZW1pdCgnbmV3QnJlYWtwb2ludFN0YXJ0JywgaW5mbyhlKSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBpbmRDaGFuZ2VkLFxcbiAgICAgICAgaXRlbXNDaGFuZ2VkLFxcbiAgICAgICAgaXRlbXNUZW0gPSBpdGVtcyxcXG4gICAgICAgIGRpc2FibGVUZW0gPSBkaXNhYmxlLFxcbiAgICAgICAgZnJlZXplVGVtID0gZnJlZXplLFxcbiAgICAgICAgYXJyb3dLZXlzVGVtID0gYXJyb3dLZXlzLFxcbiAgICAgICAgY29udHJvbHNUZW0gPSBjb250cm9scyxcXG4gICAgICAgIG5hdlRlbSA9IG5hdixcXG4gICAgICAgIHRvdWNoVGVtID0gdG91Y2gsXFxuICAgICAgICBtb3VzZURyYWdUZW0gPSBtb3VzZURyYWcsXFxuICAgICAgICBhdXRvcGxheVRlbSA9IGF1dG9wbGF5LFxcbiAgICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlVGVtID0gYXV0b3BsYXlIb3ZlclBhdXNlLFxcbiAgICAgICAgYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eVRlbSA9IGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHksXFxuICAgICAgICBpbmRleFRlbSA9IGluZGV4O1xcblxcbiAgICBpZiAoYnBDaGFuZ2VkKSB7XFxuICAgICAgdmFyIGZpeGVkV2lkdGhUZW0gPSBmaXhlZFdpZHRoLFxcbiAgICAgICAgICBhdXRvSGVpZ2h0VGVtID0gYXV0b0hlaWdodCxcXG4gICAgICAgICAgY29udHJvbHNUZXh0VGVtID0gY29udHJvbHNUZXh0LFxcbiAgICAgICAgICBjZW50ZXJUZW0gPSBjZW50ZXIsXFxuICAgICAgICAgIGF1dG9wbGF5VGV4dFRlbSA9IGF1dG9wbGF5VGV4dDtcXG5cXG4gICAgICBpZiAoIUNTU01RKSB7XFxuICAgICAgICB2YXIgZ3V0dGVyVGVtID0gZ3V0dGVyLFxcbiAgICAgICAgICAgIGVkZ2VQYWRkaW5nVGVtID0gZWRnZVBhZGRpbmc7XFxuICAgICAgfVxcbiAgICB9IC8vIGdldCBvcHRpb246XFxuICAgIC8vIGZpeGVkIHdpZHRoOiB2aWV3cG9ydCwgZml4ZWRXaWR0aCwgZ3V0dGVyID0+IGl0ZW1zXFxuICAgIC8vIG90aGVyczogd2luZG93IHdpZHRoID0+IGFsbCB2YXJpYWJsZXNcXG4gICAgLy8gYWxsOiBpdGVtcyA9PiBzbGlkZUJ5XFxuXFxuXFxuICAgIGFycm93S2V5cyA9IGdldE9wdGlvbignYXJyb3dLZXlzJyk7XFxuICAgIGNvbnRyb2xzID0gZ2V0T3B0aW9uKCdjb250cm9scycpO1xcbiAgICBuYXYgPSBnZXRPcHRpb24oJ25hdicpO1xcbiAgICB0b3VjaCA9IGdldE9wdGlvbigndG91Y2gnKTtcXG4gICAgY2VudGVyID0gZ2V0T3B0aW9uKCdjZW50ZXInKTtcXG4gICAgbW91c2VEcmFnID0gZ2V0T3B0aW9uKCdtb3VzZURyYWcnKTtcXG4gICAgYXV0b3BsYXkgPSBnZXRPcHRpb24oJ2F1dG9wbGF5Jyk7XFxuICAgIGF1dG9wbGF5SG92ZXJQYXVzZSA9IGdldE9wdGlvbignYXV0b3BsYXlIb3ZlclBhdXNlJyk7XFxuICAgIGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHkgPSBnZXRPcHRpb24oJ2F1dG9wbGF5UmVzZXRPblZpc2liaWxpdHknKTtcXG5cXG4gICAgaWYgKGJwQ2hhbmdlZCkge1xcbiAgICAgIGRpc2FibGUgPSBnZXRPcHRpb24oJ2Rpc2FibGUnKTtcXG4gICAgICBmaXhlZFdpZHRoID0gZ2V0T3B0aW9uKCdmaXhlZFdpZHRoJyk7XFxuICAgICAgc3BlZWQgPSBnZXRPcHRpb24oJ3NwZWVkJyk7XFxuICAgICAgYXV0b0hlaWdodCA9IGdldE9wdGlvbignYXV0b0hlaWdodCcpO1xcbiAgICAgIGNvbnRyb2xzVGV4dCA9IGdldE9wdGlvbignY29udHJvbHNUZXh0Jyk7XFxuICAgICAgYXV0b3BsYXlUZXh0ID0gZ2V0T3B0aW9uKCdhdXRvcGxheVRleHQnKTtcXG4gICAgICBhdXRvcGxheVRpbWVvdXQgPSBnZXRPcHRpb24oJ2F1dG9wbGF5VGltZW91dCcpO1xcblxcbiAgICAgIGlmICghQ1NTTVEpIHtcXG4gICAgICAgIGVkZ2VQYWRkaW5nID0gZ2V0T3B0aW9uKCdlZGdlUGFkZGluZycpO1xcbiAgICAgICAgZ3V0dGVyID0gZ2V0T3B0aW9uKCdndXR0ZXInKTtcXG4gICAgICB9XFxuICAgIH0gLy8gdXBkYXRlIG9wdGlvbnNcXG5cXG5cXG4gICAgcmVzZXRWYXJpYmxlc1doZW5EaXNhYmxlKGRpc2FibGUpO1xcbiAgICB2aWV3cG9ydCA9IGdldFZpZXdwb3J0V2lkdGgoKTsgLy8gPD0gZWRnZVBhZGRpbmcsIGd1dHRlclxcblxcbiAgICBpZiAoKCFob3Jpem9udGFsIHx8IGF1dG9XaWR0aCkgJiYgIWRpc2FibGUpIHtcXG4gICAgICBzZXRTbGlkZVBvc2l0aW9ucygpO1xcblxcbiAgICAgIGlmICghaG9yaXpvbnRhbCkge1xcbiAgICAgICAgdXBkYXRlQ29udGVudFdyYXBwZXJIZWlnaHQoKTsgLy8gPD0gc2V0U2xpZGVQb3NpdGlvbnNcXG5cXG4gICAgICAgIG5lZWRDb250YWluZXJUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoZml4ZWRXaWR0aCB8fCBhdXRvV2lkdGgpIHtcXG4gICAgICByaWdodEJvdW5kYXJ5ID0gZ2V0UmlnaHRCb3VuZGFyeSgpOyAvLyBhdXRvV2lkdGg6IDw9IHZpZXdwb3J0LCBzbGlkZVBvc2l0aW9ucywgZ3V0dGVyXFxuICAgICAgLy8gZml4ZWRXaWR0aDogPD0gdmlld3BvcnQsIGZpeGVkV2lkdGgsIGd1dHRlclxcblxcbiAgICAgIGluZGV4TWF4ID0gZ2V0SW5kZXhNYXgoKTsgLy8gYXV0b1dpZHRoOiA8PSByaWdodEJvdW5kYXJ5LCBzbGlkZVBvc2l0aW9uc1xcbiAgICAgIC8vIGZpeGVkV2lkdGg6IDw9IHJpZ2h0Qm91bmRhcnksIGZpeGVkV2lkdGgsIGd1dHRlclxcbiAgICB9XFxuXFxuICAgIGlmIChicENoYW5nZWQgfHwgZml4ZWRXaWR0aCkge1xcbiAgICAgIGl0ZW1zID0gZ2V0T3B0aW9uKCdpdGVtcycpO1xcbiAgICAgIHNsaWRlQnkgPSBnZXRPcHRpb24oJ3NsaWRlQnknKTtcXG4gICAgICBpdGVtc0NoYW5nZWQgPSBpdGVtcyAhPT0gaXRlbXNUZW07XFxuXFxuICAgICAgaWYgKGl0ZW1zQ2hhbmdlZCkge1xcbiAgICAgICAgaWYgKCFmaXhlZFdpZHRoICYmICFhdXRvV2lkdGgpIHtcXG4gICAgICAgICAgaW5kZXhNYXggPSBnZXRJbmRleE1heCgpO1xcbiAgICAgICAgfSAvLyA8PSBpdGVtc1xcbiAgICAgICAgLy8gY2hlY2sgaW5kZXggYmVmb3JlIHRyYW5zZm9ybSBpbiBjYXNlXFxuICAgICAgICAvLyBzbGlkZXIgcmVhY2ggdGhlIHJpZ2h0IGVkZ2UgdGhlbiBpdGVtcyBiZWNvbWUgYmlnZ2VyXFxuXFxuXFxuICAgICAgICB1cGRhdGVJbmRleCgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoYnBDaGFuZ2VkKSB7XFxuICAgICAgaWYgKGRpc2FibGUgIT09IGRpc2FibGVUZW0pIHtcXG4gICAgICAgIGlmIChkaXNhYmxlKSB7XFxuICAgICAgICAgIGRpc2FibGVTbGlkZXIoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVuYWJsZVNsaWRlcigpOyAvLyA8PSBzbGlkZVBvc2l0aW9ucywgcmlnaHRCb3VuZGFyeSwgaW5kZXhNYXhcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGZyZWV6YWJsZSAmJiAoYnBDaGFuZ2VkIHx8IGZpeGVkV2lkdGggfHwgYXV0b1dpZHRoKSkge1xcbiAgICAgIGZyZWV6ZSA9IGdldEZyZWV6ZSgpOyAvLyA8PSBhdXRvV2lkdGg6IHNsaWRlUG9zaXRpb25zLCBndXR0ZXIsIHZpZXdwb3J0LCByaWdodEJvdW5kYXJ5XFxuICAgICAgLy8gPD0gZml4ZWRXaWR0aDogZml4ZWRXaWR0aCwgZ3V0dGVyLCByaWdodEJvdW5kYXJ5XFxuICAgICAgLy8gPD0gb3RoZXJzOiBpdGVtc1xcblxcbiAgICAgIGlmIChmcmVlemUgIT09IGZyZWV6ZVRlbSkge1xcbiAgICAgICAgaWYgKGZyZWV6ZSkge1xcbiAgICAgICAgICBkb0NvbnRhaW5lclRyYW5zZm9ybShnZXRDb250YWluZXJUcmFuc2Zvcm1WYWx1ZShnZXRTdGFydEluZGV4KDApKSk7XFxuICAgICAgICAgIGZyZWV6ZVNsaWRlcigpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdW5mcmVlemVTbGlkZXIoKTtcXG4gICAgICAgICAgbmVlZENvbnRhaW5lclRyYW5zZm9ybSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJlc2V0VmFyaWJsZXNXaGVuRGlzYWJsZShkaXNhYmxlIHx8IGZyZWV6ZSk7IC8vIGNvbnRyb2xzLCBuYXYsIHRvdWNoLCBtb3VzZURyYWcsIGFycm93S2V5cywgYXV0b3BsYXksIGF1dG9wbGF5SG92ZXJQYXVzZSwgYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eVxcblxcbiAgICBpZiAoIWF1dG9wbGF5KSB7XFxuICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlID0gYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eSA9IGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChhcnJvd0tleXMgIT09IGFycm93S2V5c1RlbSkge1xcbiAgICAgIGFycm93S2V5cyA/IGFkZEV2ZW50cyhkb2MsIGRvY21lbnRLZXlkb3duRXZlbnQpIDogcmVtb3ZlRXZlbnRzKGRvYywgZG9jbWVudEtleWRvd25FdmVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGNvbnRyb2xzICE9PSBjb250cm9sc1RlbSkge1xcbiAgICAgIGlmIChjb250cm9scykge1xcbiAgICAgICAgaWYgKGNvbnRyb2xzQ29udGFpbmVyKSB7XFxuICAgICAgICAgIHNob3dFbGVtZW50KGNvbnRyb2xzQ29udGFpbmVyKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChwcmV2QnV0dG9uKSB7XFxuICAgICAgICAgICAgc2hvd0VsZW1lbnQocHJldkJ1dHRvbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKG5leHRCdXR0b24pIHtcXG4gICAgICAgICAgICBzaG93RWxlbWVudChuZXh0QnV0dG9uKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoY29udHJvbHNDb250YWluZXIpIHtcXG4gICAgICAgICAgaGlkZUVsZW1lbnQoY29udHJvbHNDb250YWluZXIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKHByZXZCdXR0b24pIHtcXG4gICAgICAgICAgICBoaWRlRWxlbWVudChwcmV2QnV0dG9uKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobmV4dEJ1dHRvbikge1xcbiAgICAgICAgICAgIGhpZGVFbGVtZW50KG5leHRCdXR0b24pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChuYXYgIT09IG5hdlRlbSkge1xcbiAgICAgIGlmIChuYXYpIHtcXG4gICAgICAgIHNob3dFbGVtZW50KG5hdkNvbnRhaW5lcik7XFxuICAgICAgICB1cGRhdGVOYXZWaXNpYmlsaXR5KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGhpZGVFbGVtZW50KG5hdkNvbnRhaW5lcik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh0b3VjaCAhPT0gdG91Y2hUZW0pIHtcXG4gICAgICB0b3VjaCA/IGFkZEV2ZW50cyhjb250YWluZXIsIHRvdWNoRXZlbnRzLCBvcHRpb25zLnByZXZlbnRTY3JvbGxPblRvdWNoKSA6IHJlbW92ZUV2ZW50cyhjb250YWluZXIsIHRvdWNoRXZlbnRzKTtcXG4gICAgfVxcblxcbiAgICBpZiAobW91c2VEcmFnICE9PSBtb3VzZURyYWdUZW0pIHtcXG4gICAgICBtb3VzZURyYWcgPyBhZGRFdmVudHMoY29udGFpbmVyLCBkcmFnRXZlbnRzKSA6IHJlbW92ZUV2ZW50cyhjb250YWluZXIsIGRyYWdFdmVudHMpO1xcbiAgICB9XFxuXFxuICAgIGlmIChhdXRvcGxheSAhPT0gYXV0b3BsYXlUZW0pIHtcXG4gICAgICBpZiAoYXV0b3BsYXkpIHtcXG4gICAgICAgIGlmIChhdXRvcGxheUJ1dHRvbikge1xcbiAgICAgICAgICBzaG93RWxlbWVudChhdXRvcGxheUJ1dHRvbik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWFuaW1hdGluZyAmJiAhYXV0b3BsYXlVc2VyUGF1c2VkKSB7XFxuICAgICAgICAgIHN0YXJ0QXV0b3BsYXkoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGF1dG9wbGF5QnV0dG9uKSB7XFxuICAgICAgICAgIGhpZGVFbGVtZW50KGF1dG9wbGF5QnV0dG9uKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhbmltYXRpbmcpIHtcXG4gICAgICAgICAgc3RvcEF1dG9wbGF5KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChhdXRvcGxheUhvdmVyUGF1c2UgIT09IGF1dG9wbGF5SG92ZXJQYXVzZVRlbSkge1xcbiAgICAgIGF1dG9wbGF5SG92ZXJQYXVzZSA/IGFkZEV2ZW50cyhjb250YWluZXIsIGhvdmVyRXZlbnRzKSA6IHJlbW92ZUV2ZW50cyhjb250YWluZXIsIGhvdmVyRXZlbnRzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eSAhPT0gYXV0b3BsYXlSZXNldE9uVmlzaWJpbGl0eVRlbSkge1xcbiAgICAgIGF1dG9wbGF5UmVzZXRPblZpc2liaWxpdHkgPyBhZGRFdmVudHMoZG9jLCB2aXNpYmlsaXR5RXZlbnQpIDogcmVtb3ZlRXZlbnRzKGRvYywgdmlzaWJpbGl0eUV2ZW50KTtcXG4gICAgfVxcblxcbiAgICBpZiAoYnBDaGFuZ2VkKSB7XFxuICAgICAgaWYgKGZpeGVkV2lkdGggIT09IGZpeGVkV2lkdGhUZW0gfHwgY2VudGVyICE9PSBjZW50ZXJUZW0pIHtcXG4gICAgICAgIG5lZWRDb250YWluZXJUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYXV0b0hlaWdodCAhPT0gYXV0b0hlaWdodFRlbSkge1xcbiAgICAgICAgaWYgKCFhdXRvSGVpZ2h0KSB7XFxuICAgICAgICAgIGlubmVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSAnJztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbnRyb2xzICYmIGNvbnRyb2xzVGV4dCAhPT0gY29udHJvbHNUZXh0VGVtKSB7XFxuICAgICAgICBwcmV2QnV0dG9uLmlubmVySFRNTCA9IGNvbnRyb2xzVGV4dFswXTtcXG4gICAgICAgIG5leHRCdXR0b24uaW5uZXJIVE1MID0gY29udHJvbHNUZXh0WzFdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYXV0b3BsYXlCdXR0b24gJiYgYXV0b3BsYXlUZXh0ICE9PSBhdXRvcGxheVRleHRUZW0pIHtcXG4gICAgICAgIHZhciBpID0gYXV0b3BsYXkgPyAxIDogMCxcXG4gICAgICAgICAgICBodG1sID0gYXV0b3BsYXlCdXR0b24uaW5uZXJIVE1MLFxcbiAgICAgICAgICAgIGxlbiA9IGh0bWwubGVuZ3RoIC0gYXV0b3BsYXlUZXh0VGVtW2ldLmxlbmd0aDtcXG5cXG4gICAgICAgIGlmIChodG1sLnN1YnN0cmluZyhsZW4pID09PSBhdXRvcGxheVRleHRUZW1baV0pIHtcXG4gICAgICAgICAgYXV0b3BsYXlCdXR0b24uaW5uZXJIVE1MID0gaHRtbC5zdWJzdHJpbmcoMCwgbGVuKSArIGF1dG9wbGF5VGV4dFtpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGNlbnRlciAmJiAoZml4ZWRXaWR0aCB8fCBhdXRvV2lkdGgpKSB7XFxuICAgICAgICBuZWVkQ29udGFpbmVyVHJhbnNmb3JtID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGl0ZW1zQ2hhbmdlZCB8fCBmaXhlZFdpZHRoICYmICFhdXRvV2lkdGgpIHtcXG4gICAgICBwYWdlcyA9IGdldFBhZ2VzKCk7XFxuICAgICAgdXBkYXRlTmF2VmlzaWJpbGl0eSgpO1xcbiAgICB9XFxuXFxuICAgIGluZENoYW5nZWQgPSBpbmRleCAhPT0gaW5kZXhUZW07XFxuXFxuICAgIGlmIChpbmRDaGFuZ2VkKSB7XFxuICAgICAgZXZlbnRzLmVtaXQoJ2luZGV4Q2hhbmdlZCcsIGluZm8oKSk7XFxuICAgICAgbmVlZENvbnRhaW5lclRyYW5zZm9ybSA9IHRydWU7XFxuICAgIH0gZWxzZSBpZiAoaXRlbXNDaGFuZ2VkKSB7XFxuICAgICAgaWYgKCFpbmRDaGFuZ2VkKSB7XFxuICAgICAgICBhZGRpdGlvbmFsVXBkYXRlcygpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChmaXhlZFdpZHRoIHx8IGF1dG9XaWR0aCkge1xcbiAgICAgIGRvTGF6eUxvYWQoKTtcXG4gICAgICB1cGRhdGVTbGlkZVN0YXR1cygpO1xcbiAgICAgIHVwZGF0ZUxpdmVSZWdpb24oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXRlbXNDaGFuZ2VkICYmICFjYXJvdXNlbCkge1xcbiAgICAgIHVwZGF0ZUdhbGxlcnlTbGlkZVBvc2l0aW9ucygpO1xcbiAgICB9XFxuXFxuICAgIGlmICghZGlzYWJsZSAmJiAhZnJlZXplKSB7XFxuICAgICAgLy8gbm9uLW1lZGlhcXVlcmllczogSUU4XFxuICAgICAgaWYgKGJwQ2hhbmdlZCAmJiAhQ1NTTVEpIHtcXG4gICAgICAgIC8vIG1pZGRsZSB3cmFwcGVyIHN0eWxlc1xcbiAgICAgICAgLy8gaW5uZXIgd3JhcHBlciBzdHlsZXNcXG4gICAgICAgIGlmIChlZGdlUGFkZGluZyAhPT0gZWRnZVBhZGRpbmdUZW0gfHwgZ3V0dGVyICE9PSBndXR0ZXJUZW0pIHtcXG4gICAgICAgICAgaW5uZXJXcmFwcGVyLnN0eWxlLmNzc1RleHQgPSBnZXRJbm5lcldyYXBwZXJTdHlsZXMoZWRnZVBhZGRpbmcsIGd1dHRlciwgZml4ZWRXaWR0aCwgc3BlZWQsIGF1dG9IZWlnaHQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGhvcml6b250YWwpIHtcXG4gICAgICAgICAgLy8gY29udGFpbmVyIHN0eWxlc1xcbiAgICAgICAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBnZXRDb250YWluZXJXaWR0aChmaXhlZFdpZHRoLCBndXR0ZXIsIGl0ZW1zKTtcXG4gICAgICAgICAgfSAvLyBzbGlkZSBzdHlsZXNcXG5cXG5cXG4gICAgICAgICAgdmFyIHN0ciA9IGdldFNsaWRlV2lkdGhTdHlsZShmaXhlZFdpZHRoLCBndXR0ZXIsIGl0ZW1zKSArIGdldFNsaWRlR3V0dGVyU3R5bGUoZ3V0dGVyKTsgLy8gcmVtb3ZlIHRoZSBsYXN0IGxpbmUgYW5kXFxuICAgICAgICAgIC8vIGFkZCBuZXcgc3R5bGVzXFxuXFxuICAgICAgICAgIHJlbW92ZUNTU1J1bGUoc2hlZXQsIGdldENzc1J1bGVzTGVuZ3RoKHNoZWV0KSAtIDEpO1xcbiAgICAgICAgICBhZGRDU1NSdWxlKHNoZWV0LCAnIycgKyBzbGlkZUlkICsgJyA+IC50bnMtaXRlbScsIHN0ciwgZ2V0Q3NzUnVsZXNMZW5ndGgoc2hlZXQpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIGF1dG8gaGVpZ2h0XFxuXFxuXFxuICAgICAgaWYgKGF1dG9IZWlnaHQpIHtcXG4gICAgICAgIGRvQXV0b0hlaWdodCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobmVlZENvbnRhaW5lclRyYW5zZm9ybSkge1xcbiAgICAgICAgZG9Db250YWluZXJUcmFuc2Zvcm1TaWxlbnQoKTtcXG4gICAgICAgIGluZGV4Q2FjaGVkID0gaW5kZXg7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChicENoYW5nZWQpIHtcXG4gICAgICBldmVudHMuZW1pdCgnbmV3QnJlYWtwb2ludEVuZCcsIGluZm8oZSkpO1xcbiAgICB9XFxuICB9IC8vID09PSBJTklUSUFMSVpBVElPTiBGVU5DVElPTlMgPT09IC8vXFxuXFxuXFxuICBmdW5jdGlvbiBnZXRGcmVlemUoKSB7XFxuICAgIGlmICghZml4ZWRXaWR0aCAmJiAhYXV0b1dpZHRoKSB7XFxuICAgICAgdmFyIGEgPSBjZW50ZXIgPyBpdGVtcyAtIChpdGVtcyAtIDEpIC8gMiA6IGl0ZW1zO1xcbiAgICAgIHJldHVybiBzbGlkZUNvdW50IDw9IGE7XFxuICAgIH1cXG5cXG4gICAgdmFyIHdpZHRoID0gZml4ZWRXaWR0aCA/IChmaXhlZFdpZHRoICsgZ3V0dGVyKSAqIHNsaWRlQ291bnQgOiBzbGlkZVBvc2l0aW9uc1tzbGlkZUNvdW50XSxcXG4gICAgICAgIHZwID0gZWRnZVBhZGRpbmcgPyB2aWV3cG9ydCArIGVkZ2VQYWRkaW5nICogMiA6IHZpZXdwb3J0ICsgZ3V0dGVyO1xcblxcbiAgICBpZiAoY2VudGVyKSB7XFxuICAgICAgdnAgLT0gZml4ZWRXaWR0aCA/ICh2aWV3cG9ydCAtIGZpeGVkV2lkdGgpIC8gMiA6ICh2aWV3cG9ydCAtIChzbGlkZVBvc2l0aW9uc1tpbmRleCArIDFdIC0gc2xpZGVQb3NpdGlvbnNbaW5kZXhdIC0gZ3V0dGVyKSkgLyAyO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB3aWR0aCA8PSB2cDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldEJyZWFrcG9pbnRab25lKCkge1xcbiAgICBicmVha3BvaW50Wm9uZSA9IDA7XFxuXFxuICAgIGZvciAodmFyIGJwIGluIHJlc3BvbnNpdmUpIHtcXG4gICAgICBicCA9IHBhcnNlSW50KGJwKTsgLy8gY29udmVydCBzdHJpbmcgdG8gbnVtYmVyXFxuXFxuICAgICAgaWYgKHdpbmRvd1dpZHRoID49IGJwKSB7XFxuICAgICAgICBicmVha3BvaW50Wm9uZSA9IGJwO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSAvLyAoc2xpZGVCeSwgaW5kZXhNaW4sIGluZGV4TWF4KSA9PiBpbmRleFxcblxcblxcbiAgdmFyIHVwZGF0ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbG9vcCA/IGNhcm91c2VsID8gLy8gbG9vcCArIGNhcm91c2VsXFxuICAgIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbGVmdEVkZ2UgPSBpbmRleE1pbixcXG4gICAgICAgICAgcmlnaHRFZGdlID0gaW5kZXhNYXg7XFxuICAgICAgbGVmdEVkZ2UgKz0gc2xpZGVCeTtcXG4gICAgICByaWdodEVkZ2UgLT0gc2xpZGVCeTsgLy8gYWRqdXN0IGVkZ2VzIHdoZW4gaGFzIGVkZ2UgcGFkZGluZ3NcXG4gICAgICAvLyBvciBmaXhlZC13aWR0aCBzbGlkZXIgd2l0aCBleHRyYSBzcGFjZSBvbiB0aGUgcmlnaHQgc2lkZVxcblxcbiAgICAgIGlmIChlZGdlUGFkZGluZykge1xcbiAgICAgICAgbGVmdEVkZ2UgKz0gMTtcXG4gICAgICAgIHJpZ2h0RWRnZSAtPSAxO1xcbiAgICAgIH0gZWxzZSBpZiAoZml4ZWRXaWR0aCkge1xcbiAgICAgICAgaWYgKCh2aWV3cG9ydCArIGd1dHRlcikgJSAoZml4ZWRXaWR0aCArIGd1dHRlcikpIHtcXG4gICAgICAgICAgcmlnaHRFZGdlIC09IDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjbG9uZUNvdW50KSB7XFxuICAgICAgICBpZiAoaW5kZXggPiByaWdodEVkZ2UpIHtcXG4gICAgICAgICAgaW5kZXggLT0gc2xpZGVDb3VudDtcXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCBsZWZ0RWRnZSkge1xcbiAgICAgICAgICBpbmRleCArPSBzbGlkZUNvdW50O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSA6IC8vIGxvb3AgKyBnYWxsZXJ5XFxuICAgIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoaW5kZXggPiBpbmRleE1heCkge1xcbiAgICAgICAgd2hpbGUgKGluZGV4ID49IGluZGV4TWluICsgc2xpZGVDb3VudCkge1xcbiAgICAgICAgICBpbmRleCAtPSBzbGlkZUNvdW50O1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCBpbmRleE1pbikge1xcbiAgICAgICAgd2hpbGUgKGluZGV4IDw9IGluZGV4TWF4IC0gc2xpZGVDb3VudCkge1xcbiAgICAgICAgICBpbmRleCArPSBzbGlkZUNvdW50O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSA6IC8vIG5vbi1sb29wXFxuICAgIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpbmRleCA9IE1hdGgubWF4KGluZGV4TWluLCBNYXRoLm1pbihpbmRleE1heCwgaW5kZXgpKTtcXG4gICAgfTtcXG4gIH0oKTtcXG5cXG4gIGZ1bmN0aW9uIGRpc2FibGVVSSgpIHtcXG4gICAgaWYgKCFhdXRvcGxheSAmJiBhdXRvcGxheUJ1dHRvbikge1xcbiAgICAgIGhpZGVFbGVtZW50KGF1dG9wbGF5QnV0dG9uKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIW5hdiAmJiBuYXZDb250YWluZXIpIHtcXG4gICAgICBoaWRlRWxlbWVudChuYXZDb250YWluZXIpO1xcbiAgICB9XFxuXFxuICAgIGlmICghY29udHJvbHMpIHtcXG4gICAgICBpZiAoY29udHJvbHNDb250YWluZXIpIHtcXG4gICAgICAgIGhpZGVFbGVtZW50KGNvbnRyb2xzQ29udGFpbmVyKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHByZXZCdXR0b24pIHtcXG4gICAgICAgICAgaGlkZUVsZW1lbnQocHJldkJ1dHRvbik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobmV4dEJ1dHRvbikge1xcbiAgICAgICAgICBoaWRlRWxlbWVudChuZXh0QnV0dG9uKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVuYWJsZVVJKCkge1xcbiAgICBpZiAoYXV0b3BsYXkgJiYgYXV0b3BsYXlCdXR0b24pIHtcXG4gICAgICBzaG93RWxlbWVudChhdXRvcGxheUJ1dHRvbik7XFxuICAgIH1cXG5cXG4gICAgaWYgKG5hdiAmJiBuYXZDb250YWluZXIpIHtcXG4gICAgICBzaG93RWxlbWVudChuYXZDb250YWluZXIpO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb250cm9scykge1xcbiAgICAgIGlmIChjb250cm9sc0NvbnRhaW5lcikge1xcbiAgICAgICAgc2hvd0VsZW1lbnQoY29udHJvbHNDb250YWluZXIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAocHJldkJ1dHRvbikge1xcbiAgICAgICAgICBzaG93RWxlbWVudChwcmV2QnV0dG9uKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChuZXh0QnV0dG9uKSB7XFxuICAgICAgICAgIHNob3dFbGVtZW50KG5leHRCdXR0b24pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZnJlZXplU2xpZGVyKCkge1xcbiAgICBpZiAoZnJvemVuKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIHJlbW92ZSBlZGdlIHBhZGRpbmcgZnJvbSBpbm5lciB3cmFwcGVyXFxuXFxuXFxuICAgIGlmIChlZGdlUGFkZGluZykge1xcbiAgICAgIGlubmVyV3JhcHBlci5zdHlsZS5tYXJnaW4gPSAnMHB4JztcXG4gICAgfSAvLyBhZGQgY2xhc3MgdG5zLXRyYW5zcGFyZW50IHRvIGNsb25lZCBzbGlkZXNcXG5cXG5cXG4gICAgaWYgKGNsb25lQ291bnQpIHtcXG4gICAgICB2YXIgc3RyID0gJ3Rucy10cmFuc3BhcmVudCc7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IGNsb25lQ291bnQ7IGktLTspIHtcXG4gICAgICAgIGlmIChjYXJvdXNlbCkge1xcbiAgICAgICAgICBhZGRDbGFzcyhzbGlkZUl0ZW1zW2ldLCBzdHIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVJdGVtc1tzbGlkZUNvdW50TmV3IC0gaSAtIDFdLCBzdHIpO1xcbiAgICAgIH1cXG4gICAgfSAvLyB1cGRhdGUgdG9vbHNcXG5cXG5cXG4gICAgZGlzYWJsZVVJKCk7XFxuICAgIGZyb3plbiA9IHRydWU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1bmZyZWV6ZVNsaWRlcigpIHtcXG4gICAgaWYgKCFmcm96ZW4pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH0gLy8gcmVzdG9yZSBlZGdlIHBhZGRpbmcgZm9yIGlubmVyIHdyYXBwZXJcXG4gICAgLy8gZm9yIG1vcmRlcm4gYnJvd3NlcnNcXG5cXG5cXG4gICAgaWYgKGVkZ2VQYWRkaW5nICYmIENTU01RKSB7XFxuICAgICAgaW5uZXJXcmFwcGVyLnN0eWxlLm1hcmdpbiA9ICcnO1xcbiAgICB9IC8vIHJlbW92ZSBjbGFzcyB0bnMtdHJhbnNwYXJlbnQgdG8gY2xvbmVkIHNsaWRlc1xcblxcblxcbiAgICBpZiAoY2xvbmVDb3VudCkge1xcbiAgICAgIHZhciBzdHIgPSAndG5zLXRyYW5zcGFyZW50JztcXG5cXG4gICAgICBmb3IgKHZhciBpID0gY2xvbmVDb3VudDsgaS0tOykge1xcbiAgICAgICAgaWYgKGNhcm91c2VsKSB7XFxuICAgICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlSXRlbXNbaV0sIHN0cik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZW1vdmVDbGFzcyhzbGlkZUl0ZW1zW3NsaWRlQ291bnROZXcgLSBpIC0gMV0sIHN0cik7XFxuICAgICAgfVxcbiAgICB9IC8vIHVwZGF0ZSB0b29sc1xcblxcblxcbiAgICBlbmFibGVVSSgpO1xcbiAgICBmcm96ZW4gPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRpc2FibGVTbGlkZXIoKSB7XFxuICAgIGlmIChkaXNhYmxlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBzaGVldC5kaXNhYmxlZCA9IHRydWU7XFxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBjb250YWluZXIuY2xhc3NOYW1lLnJlcGxhY2UobmV3Q29udGFpbmVyQ2xhc3Nlcy5zdWJzdHJpbmcoMSksICcnKTtcXG4gICAgcmVtb3ZlQXR0cnMoY29udGFpbmVyLCBbJ3N0eWxlJ10pO1xcblxcbiAgICBpZiAobG9vcCkge1xcbiAgICAgIGZvciAodmFyIGogPSBjbG9uZUNvdW50OyBqLS07KSB7XFxuICAgICAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICAgICAgaGlkZUVsZW1lbnQoc2xpZGVJdGVtc1tqXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoaWRlRWxlbWVudChzbGlkZUl0ZW1zW3NsaWRlQ291bnROZXcgLSBqIC0gMV0pO1xcbiAgICAgIH1cXG4gICAgfSAvLyB2ZXJ0aWNhbCBzbGlkZXJcXG5cXG5cXG4gICAgaWYgKCFob3Jpem9udGFsIHx8ICFjYXJvdXNlbCkge1xcbiAgICAgIHJlbW92ZUF0dHJzKGlubmVyV3JhcHBlciwgWydzdHlsZSddKTtcXG4gICAgfSAvLyBnYWxsZXJ5XFxuXFxuXFxuICAgIGlmICghY2Fyb3VzZWwpIHtcXG4gICAgICBmb3IgKHZhciBpID0gaW5kZXgsIGwgPSBpbmRleCArIHNsaWRlQ291bnQ7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIHZhciBpdGVtID0gc2xpZGVJdGVtc1tpXTtcXG4gICAgICAgIHJlbW92ZUF0dHJzKGl0ZW0sIFsnc3R5bGUnXSk7XFxuICAgICAgICByZW1vdmVDbGFzcyhpdGVtLCBhbmltYXRlSW4pO1xcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaXRlbSwgYW5pbWF0ZU5vcm1hbCk7XFxuICAgICAgfVxcbiAgICB9IC8vIHVwZGF0ZSB0b29sc1xcblxcblxcbiAgICBkaXNhYmxlVUkoKTtcXG4gICAgZGlzYWJsZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZW5hYmxlU2xpZGVyKCkge1xcbiAgICBpZiAoIWRpc2FibGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHNoZWV0LmRpc2FibGVkID0gZmFsc2U7XFxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgKz0gbmV3Q29udGFpbmVyQ2xhc3NlcztcXG4gICAgZG9Db250YWluZXJUcmFuc2Zvcm1TaWxlbnQoKTtcXG5cXG4gICAgaWYgKGxvb3ApIHtcXG4gICAgICBmb3IgKHZhciBqID0gY2xvbmVDb3VudDsgai0tOykge1xcbiAgICAgICAgaWYgKGNhcm91c2VsKSB7XFxuICAgICAgICAgIHNob3dFbGVtZW50KHNsaWRlSXRlbXNbal0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2hvd0VsZW1lbnQoc2xpZGVJdGVtc1tzbGlkZUNvdW50TmV3IC0gaiAtIDFdKTtcXG4gICAgICB9XFxuICAgIH0gLy8gZ2FsbGVyeVxcblxcblxcbiAgICBpZiAoIWNhcm91c2VsKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IGluZGV4LCBsID0gaW5kZXggKyBzbGlkZUNvdW50OyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICB2YXIgaXRlbSA9IHNsaWRlSXRlbXNbaV0sXFxuICAgICAgICAgICAgY2xhc3NOID0gaSA8IGluZGV4ICsgaXRlbXMgPyBhbmltYXRlSW4gOiBhbmltYXRlTm9ybWFsO1xcbiAgICAgICAgaXRlbS5zdHlsZS5sZWZ0ID0gKGkgLSBpbmRleCkgKiAxMDAgLyBpdGVtcyArICclJztcXG4gICAgICAgIGFkZENsYXNzKGl0ZW0sIGNsYXNzTik7XFxuICAgICAgfVxcbiAgICB9IC8vIHVwZGF0ZSB0b29sc1xcblxcblxcbiAgICBlbmFibGVVSSgpO1xcbiAgICBkaXNhYmxlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlTGl2ZVJlZ2lvbigpIHtcXG4gICAgdmFyIHN0ciA9IGdldExpdmVSZWdpb25TdHIoKTtcXG5cXG4gICAgaWYgKGxpdmVyZWdpb25DdXJyZW50LmlubmVySFRNTCAhPT0gc3RyKSB7XFxuICAgICAgbGl2ZXJlZ2lvbkN1cnJlbnQuaW5uZXJIVE1MID0gc3RyO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRMaXZlUmVnaW9uU3RyKCkge1xcbiAgICB2YXIgYXJyID0gZ2V0VmlzaWJsZVNsaWRlUmFuZ2UoKSxcXG4gICAgICAgIHN0YXJ0ID0gYXJyWzBdICsgMSxcXG4gICAgICAgIGVuZCA9IGFyclsxXSArIDE7XFxuICAgIHJldHVybiBzdGFydCA9PT0gZW5kID8gc3RhcnQgKyAnJyA6IHN0YXJ0ICsgJyB0byAnICsgZW5kO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0VmlzaWJsZVNsaWRlUmFuZ2UodmFsKSB7XFxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xcbiAgICAgIHZhbCA9IGdldENvbnRhaW5lclRyYW5zZm9ybVZhbHVlKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHN0YXJ0ID0gaW5kZXgsXFxuICAgICAgICBlbmQsXFxuICAgICAgICByYW5nZXN0YXJ0LFxcbiAgICAgICAgcmFuZ2VlbmQ7IC8vIGdldCByYW5nZSBzdGFydCwgcmFuZ2UgZW5kIGZvciBhdXRvV2lkdGggYW5kIGZpeGVkV2lkdGhcXG5cXG4gICAgaWYgKGNlbnRlciB8fCBlZGdlUGFkZGluZykge1xcbiAgICAgIGlmIChhdXRvV2lkdGggfHwgZml4ZWRXaWR0aCkge1xcbiAgICAgICAgcmFuZ2VzdGFydCA9IC0ocGFyc2VGbG9hdCh2YWwpICsgZWRnZVBhZGRpbmcpO1xcbiAgICAgICAgcmFuZ2VlbmQgPSByYW5nZXN0YXJ0ICsgdmlld3BvcnQgKyBlZGdlUGFkZGluZyAqIDI7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChhdXRvV2lkdGgpIHtcXG4gICAgICAgIHJhbmdlc3RhcnQgPSBzbGlkZVBvc2l0aW9uc1tpbmRleF07XFxuICAgICAgICByYW5nZWVuZCA9IHJhbmdlc3RhcnQgKyB2aWV3cG9ydDtcXG4gICAgICB9XFxuICAgIH0gLy8gZ2V0IHN0YXJ0LCBlbmRcXG4gICAgLy8gLSBjaGVjayBhdXRvIHdpZHRoXFxuXFxuXFxuICAgIGlmIChhdXRvV2lkdGgpIHtcXG4gICAgICBzbGlkZVBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCwgaSkge1xcbiAgICAgICAgaWYgKGkgPCBzbGlkZUNvdW50TmV3KSB7XFxuICAgICAgICAgIGlmICgoY2VudGVyIHx8IGVkZ2VQYWRkaW5nKSAmJiBwb2ludCA8PSByYW5nZXN0YXJ0ICsgMC41KSB7XFxuICAgICAgICAgICAgc3RhcnQgPSBpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChyYW5nZWVuZCAtIHBvaW50ID49IDAuNSkge1xcbiAgICAgICAgICAgIGVuZCA9IGk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gLSBjaGVjayBwZXJjZW50YWdlIHdpZHRoLCBmaXhlZCB3aWR0aFxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChmaXhlZFdpZHRoKSB7XFxuICAgICAgICB2YXIgY2VsbCA9IGZpeGVkV2lkdGggKyBndXR0ZXI7XFxuXFxuICAgICAgICBpZiAoY2VudGVyIHx8IGVkZ2VQYWRkaW5nKSB7XFxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihyYW5nZXN0YXJ0IC8gY2VsbCk7XFxuICAgICAgICAgIGVuZCA9IE1hdGguY2VpbChyYW5nZWVuZCAvIGNlbGwgLSAxKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgTWF0aC5jZWlsKHZpZXdwb3J0IC8gY2VsbCkgLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoY2VudGVyIHx8IGVkZ2VQYWRkaW5nKSB7XFxuICAgICAgICAgIHZhciBhID0gaXRlbXMgLSAxO1xcblxcbiAgICAgICAgICBpZiAoY2VudGVyKSB7XFxuICAgICAgICAgICAgc3RhcnQgLT0gYSAvIDI7XFxuICAgICAgICAgICAgZW5kID0gaW5kZXggKyBhIC8gMjtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBlbmQgPSBpbmRleCArIGE7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGVkZ2VQYWRkaW5nKSB7XFxuICAgICAgICAgICAgdmFyIGIgPSBlZGdlUGFkZGluZyAqIGl0ZW1zIC8gdmlld3BvcnQ7XFxuICAgICAgICAgICAgc3RhcnQgLT0gYjtcXG4gICAgICAgICAgICBlbmQgKz0gYjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xcbiAgICAgICAgICBlbmQgPSBNYXRoLmNlaWwoZW5kKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgaXRlbXMgLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcXG4gICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHNsaWRlQ291bnROZXcgLSAxKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZG9MYXp5TG9hZCgpIHtcXG4gICAgaWYgKGxhenlsb2FkICYmICFkaXNhYmxlKSB7XFxuICAgICAgdmFyIGFyZyA9IGdldFZpc2libGVTbGlkZVJhbmdlKCk7XFxuICAgICAgYXJnLnB1c2gobGF6eWxvYWRTZWxlY3Rvcik7XFxuICAgICAgZ2V0SW1hZ2VBcnJheS5hcHBseShudWxsLCBhcmcpLmZvckVhY2goZnVuY3Rpb24gKGltZykge1xcbiAgICAgICAgaWYgKCFoYXNDbGFzcyhpbWcsIGltZ0NvbXBsZXRlQ2xhc3MpKSB7XFxuICAgICAgICAgIC8vIHN0b3AgcHJvcGFnYXRpb24gdHJhbnNpdGlvbmVuZCBldmVudCB0byBjb250YWluZXJcXG4gICAgICAgICAgdmFyIGV2ZSA9IHt9O1xcblxcbiAgICAgICAgICBldmVbVFJBTlNJVElPTkVORF0gPSBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGFkZEV2ZW50cyhpbWcsIGV2ZSk7XFxuICAgICAgICAgIGFkZEV2ZW50cyhpbWcsIGltZ0V2ZW50cyk7IC8vIHVwZGF0ZSBzcmNcXG5cXG4gICAgICAgICAgaW1nLnNyYyA9IGdldEF0dHIoaW1nLCAnZGF0YS1zcmMnKTsgLy8gdXBkYXRlIHNyY3NldFxcblxcbiAgICAgICAgICB2YXIgc3Jjc2V0ID0gZ2V0QXR0cihpbWcsICdkYXRhLXNyY3NldCcpO1xcblxcbiAgICAgICAgICBpZiAoc3Jjc2V0KSB7XFxuICAgICAgICAgICAgaW1nLnNyY3NldCA9IHNyY3NldDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRDbGFzcyhpbWcsICdsb2FkaW5nJyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uSW1nTG9hZGVkKGUpIHtcXG4gICAgaW1nTG9hZGVkKGdldFRhcmdldChlKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbkltZ0ZhaWxlZChlKSB7XFxuICAgIGltZ0ZhaWxlZChnZXRUYXJnZXQoZSkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaW1nTG9hZGVkKGltZykge1xcbiAgICBhZGRDbGFzcyhpbWcsICdsb2FkZWQnKTtcXG4gICAgaW1nQ29tcGxldGVkKGltZyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbWdGYWlsZWQoaW1nKSB7XFxuICAgIGFkZENsYXNzKGltZywgJ2ZhaWxlZCcpO1xcbiAgICBpbWdDb21wbGV0ZWQoaW1nKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGltZ0NvbXBsZXRlZChpbWcpIHtcXG4gICAgYWRkQ2xhc3MoaW1nLCBpbWdDb21wbGV0ZUNsYXNzKTtcXG4gICAgcmVtb3ZlQ2xhc3MoaW1nLCAnbG9hZGluZycpO1xcbiAgICByZW1vdmVFdmVudHMoaW1nLCBpbWdFdmVudHMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0SW1hZ2VBcnJheShzdGFydCwgZW5kLCBpbWdTZWxlY3Rvcikge1xcbiAgICB2YXIgaW1ncyA9IFtdO1xcblxcbiAgICBpZiAoIWltZ1NlbGVjdG9yKSB7XFxuICAgICAgaW1nU2VsZWN0b3IgPSAnaW1nJztcXG4gICAgfVxcblxcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XFxuICAgICAgZm9yRWFjaChzbGlkZUl0ZW1zW3N0YXJ0XS5xdWVyeVNlbGVjdG9yQWxsKGltZ1NlbGVjdG9yKSwgZnVuY3Rpb24gKGltZykge1xcbiAgICAgICAgaW1ncy5wdXNoKGltZyk7XFxuICAgICAgfSk7XFxuICAgICAgc3RhcnQrKztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaW1ncztcXG4gIH0gLy8gY2hlY2sgaWYgYWxsIHZpc2libGUgaW1hZ2VzIGFyZSBsb2FkZWRcXG4gIC8vIGFuZCB1cGRhdGUgY29udGFpbmVyIGhlaWdodCBpZiBpdCdzIGRvbmVcXG5cXG5cXG4gIGZ1bmN0aW9uIGRvQXV0b0hlaWdodCgpIHtcXG4gICAgdmFyIGltZ3MgPSBnZXRJbWFnZUFycmF5LmFwcGx5KG51bGwsIGdldFZpc2libGVTbGlkZVJhbmdlKCkpO1xcbiAgICByYWYoZnVuY3Rpb24gKCkge1xcbiAgICAgIGltZ3NMb2FkZWRDaGVjayhpbWdzLCB1cGRhdGVJbm5lcldyYXBwZXJIZWlnaHQpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGltZ3NMb2FkZWRDaGVjayhpbWdzLCBjYikge1xcbiAgICAvLyBleGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIGFsbCBpbWFnZXMgYXJlIGNvbXBsZXRlXFxuICAgIGlmIChpbWdzQ29tcGxldGUpIHtcXG4gICAgICByZXR1cm4gY2IoKTtcXG4gICAgfSAvLyBjaGVjayBpbWFnZSBjbGFzc2VzXFxuXFxuXFxuICAgIGltZ3MuZm9yRWFjaChmdW5jdGlvbiAoaW1nLCBpbmRleCkge1xcbiAgICAgIGlmICghbGF6eWxvYWQgJiYgaW1nLmNvbXBsZXRlKSB7XFxuICAgICAgICBpbWdDb21wbGV0ZWQoaW1nKTtcXG4gICAgICB9IC8vIENoZWNrIGltYWdlLmNvbXBsZXRlXFxuXFxuXFxuICAgICAgaWYgKGhhc0NsYXNzKGltZywgaW1nQ29tcGxldGVDbGFzcykpIHtcXG4gICAgICAgIGltZ3Muc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyBleGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHNlbGVjdGVkIGltYWdlcyBhcmUgYWxsIGNvbXBsZXRlXFxuXFxuICAgIGlmICghaW1ncy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gY2IoKTtcXG4gICAgfSAvLyBvdGhlcndpc2UgZXhlY3V0ZSB0aGlzIGZ1bmN0aW9uYSBhZ2FpblxcblxcblxcbiAgICByYWYoZnVuY3Rpb24gKCkge1xcbiAgICAgIGltZ3NMb2FkZWRDaGVjayhpbWdzLCBjYik7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkaXRpb25hbFVwZGF0ZXMoKSB7XFxuICAgIGRvTGF6eUxvYWQoKTtcXG4gICAgdXBkYXRlU2xpZGVTdGF0dXMoKTtcXG4gICAgdXBkYXRlTGl2ZVJlZ2lvbigpO1xcbiAgICB1cGRhdGVDb250cm9sc1N0YXR1cygpO1xcbiAgICB1cGRhdGVOYXZTdGF0dXMoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZV9jYXJvdXNlbF90cmFuc2l0aW9uX2R1cmF0aW9uKCkge1xcbiAgICBpZiAoY2Fyb3VzZWwgJiYgYXV0b0hlaWdodCkge1xcbiAgICAgIG1pZGRsZVdyYXBwZXIuc3R5bGVbVFJBTlNJVElPTkRVUkFUSU9OXSA9IHNwZWVkIC8gMTAwMCArICdzJztcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0TWF4U2xpZGVIZWlnaHQoc2xpZGVTdGFydCwgc2xpZGVSYW5nZSkge1xcbiAgICB2YXIgaGVpZ2h0cyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBpID0gc2xpZGVTdGFydCwgbCA9IE1hdGgubWluKHNsaWRlU3RhcnQgKyBzbGlkZVJhbmdlLCBzbGlkZUNvdW50TmV3KTsgaSA8IGw7IGkrKykge1xcbiAgICAgIGhlaWdodHMucHVzaChzbGlkZUl0ZW1zW2ldLm9mZnNldEhlaWdodCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xcbiAgfSAvLyB1cGRhdGUgaW5uZXIgd3JhcHBlciBoZWlnaHRcXG4gIC8vIDEuIGdldCB0aGUgbWF4LWhlaWdodCBvZiB0aGUgdmlzaWJsZSBzbGlkZXNcXG4gIC8vIDIuIHNldCB0cmFuc2l0aW9uRHVyYXRpb24gdG8gc3BlZWRcXG4gIC8vIDMuIHVwZGF0ZSBpbm5lciB3cmFwcGVyIGhlaWdodCB0byBtYXgtaGVpZ2h0XFxuICAvLyA0LiBzZXQgdHJhbnNpdGlvbkR1cmF0aW9uIHRvIDBzIGFmdGVyIHRyYW5zaXRpb24gZG9uZVxcblxcblxcbiAgZnVuY3Rpb24gdXBkYXRlSW5uZXJXcmFwcGVySGVpZ2h0KCkge1xcbiAgICB2YXIgbWF4SGVpZ2h0ID0gYXV0b0hlaWdodCA/IGdldE1heFNsaWRlSGVpZ2h0KGluZGV4LCBpdGVtcykgOiBnZXRNYXhTbGlkZUhlaWdodChjbG9uZUNvdW50LCBzbGlkZUNvdW50KSxcXG4gICAgICAgIHdwID0gbWlkZGxlV3JhcHBlciA/IG1pZGRsZVdyYXBwZXIgOiBpbm5lcldyYXBwZXI7XFxuXFxuICAgIGlmICh3cC5zdHlsZS5oZWlnaHQgIT09IG1heEhlaWdodCkge1xcbiAgICAgIHdwLnN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XFxuICAgIH1cXG4gIH0gLy8gZ2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGUgZmlyc3Qgc2xpZGUgdG8gZWFjaCBzbGlkZVxcbiAgLy8gKGluaXQpID0+IHNsaWRlUG9zaXRpb25zXFxuXFxuXFxuICBmdW5jdGlvbiBzZXRTbGlkZVBvc2l0aW9ucygpIHtcXG4gICAgc2xpZGVQb3NpdGlvbnMgPSBbMF07XFxuICAgIHZhciBhdHRyID0gaG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnLFxcbiAgICAgICAgYXR0cjIgPSBob3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nLFxcbiAgICAgICAgYmFzZSA9IHNsaWRlSXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0cl07XFxuICAgIGZvckVhY2goc2xpZGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcXG4gICAgICAvLyBza2lwIHRoZSBmaXJzdCBzbGlkZVxcbiAgICAgIGlmIChpKSB7XFxuICAgICAgICBzbGlkZVBvc2l0aW9ucy5wdXNoKGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0cl0gLSBiYXNlKTtcXG4gICAgICB9IC8vIGFkZCB0aGUgZW5kIGVkZ2VcXG5cXG5cXG4gICAgICBpZiAoaSA9PT0gc2xpZGVDb3VudE5ldyAtIDEpIHtcXG4gICAgICAgIHNsaWRlUG9zaXRpb25zLnB1c2goaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVthdHRyMl0gLSBiYXNlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSAvLyB1cGRhdGUgc2xpZGVcXG5cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsaWRlU3RhdHVzKCkge1xcbiAgICB2YXIgcmFuZ2UgPSBnZXRWaXNpYmxlU2xpZGVSYW5nZSgpLFxcbiAgICAgICAgc3RhcnQgPSByYW5nZVswXSxcXG4gICAgICAgIGVuZCA9IHJhbmdlWzFdO1xcbiAgICBmb3JFYWNoKHNsaWRlSXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XFxuICAgICAgLy8gc2hvdyBzbGlkZXNcXG4gICAgICBpZiAoaSA+PSBzdGFydCAmJiBpIDw9IGVuZCkge1xcbiAgICAgICAgaWYgKGhhc0F0dHIoaXRlbSwgJ2FyaWEtaGlkZGVuJykpIHtcXG4gICAgICAgICAgcmVtb3ZlQXR0cnMoaXRlbSwgWydhcmlhLWhpZGRlbicsICd0YWJpbmRleCddKTtcXG4gICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgc2xpZGVBY3RpdmVDbGFzcyk7XFxuICAgICAgICB9IC8vIGhpZGUgc2xpZGVzXFxuXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICghaGFzQXR0cihpdGVtLCAnYXJpYS1oaWRkZW4nKSkge1xcbiAgICAgICAgICBzZXRBdHRycyhpdGVtLCB7XFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIHNsaWRlQWN0aXZlQ2xhc3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9IC8vIGdhbGxlcnk6IHVwZGF0ZSBzbGlkZSBwb3NpdGlvblxcblxcblxcbiAgZnVuY3Rpb24gdXBkYXRlR2FsbGVyeVNsaWRlUG9zaXRpb25zKCkge1xcbiAgICB2YXIgbCA9IGluZGV4ICsgTWF0aC5taW4oc2xpZGVDb3VudCwgaXRlbXMpO1xcblxcbiAgICBmb3IgKHZhciBpID0gc2xpZGVDb3VudE5ldzsgaS0tOykge1xcbiAgICAgIHZhciBpdGVtID0gc2xpZGVJdGVtc1tpXTtcXG5cXG4gICAgICBpZiAoaSA+PSBpbmRleCAmJiBpIDwgbCkge1xcbiAgICAgICAgLy8gYWRkIHRyYW5zaXRpb25zIHRvIHZpc2libGUgc2xpZGVzIHdoZW4gYWRqdXN0aW5nIHRoZWlyIHBvc2l0aW9uc1xcbiAgICAgICAgYWRkQ2xhc3MoaXRlbSwgJ3Rucy1tb3ZpbmcnKTtcXG4gICAgICAgIGl0ZW0uc3R5bGUubGVmdCA9IChpIC0gaW5kZXgpICogMTAwIC8gaXRlbXMgKyAnJSc7XFxuICAgICAgICBhZGRDbGFzcyhpdGVtLCBhbmltYXRlSW4pO1xcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaXRlbSwgYW5pbWF0ZU5vcm1hbCk7XFxuICAgICAgfSBlbHNlIGlmIChpdGVtLnN0eWxlLmxlZnQpIHtcXG4gICAgICAgIGl0ZW0uc3R5bGUubGVmdCA9ICcnO1xcbiAgICAgICAgYWRkQ2xhc3MoaXRlbSwgYW5pbWF0ZU5vcm1hbCk7XFxuICAgICAgICByZW1vdmVDbGFzcyhpdGVtLCBhbmltYXRlSW4pO1xcbiAgICAgIH0gLy8gcmVtb3ZlIG91dGxldCBhbmltYXRpb25cXG5cXG5cXG4gICAgICByZW1vdmVDbGFzcyhpdGVtLCBhbmltYXRlT3V0KTtcXG4gICAgfSAvLyByZW1vdmluZyAnLnRucy1tb3ZpbmcnXFxuXFxuXFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGZvckVhY2goc2xpZGVJdGVtcywgZnVuY3Rpb24gKGVsKSB7XFxuICAgICAgICByZW1vdmVDbGFzcyhlbCwgJ3Rucy1tb3ZpbmcnKTtcXG4gICAgICB9KTtcXG4gICAgfSwgMzAwKTtcXG4gIH0gLy8gc2V0IHRhYmluZGV4IG9uIE5hdlxcblxcblxcbiAgZnVuY3Rpb24gdXBkYXRlTmF2U3RhdHVzKCkge1xcbiAgICAvLyBnZXQgY3VycmVudCBuYXZcXG4gICAgaWYgKG5hdikge1xcbiAgICAgIG5hdkN1cnJlbnRJbmRleCA9IG5hdkNsaWNrZWQgPj0gMCA/IG5hdkNsaWNrZWQgOiBnZXRDdXJyZW50TmF2SW5kZXgoKTtcXG4gICAgICBuYXZDbGlja2VkID0gLTE7XFxuXFxuICAgICAgaWYgKG5hdkN1cnJlbnRJbmRleCAhPT0gbmF2Q3VycmVudEluZGV4Q2FjaGVkKSB7XFxuICAgICAgICB2YXIgbmF2UHJldiA9IG5hdkl0ZW1zW25hdkN1cnJlbnRJbmRleENhY2hlZF0sXFxuICAgICAgICAgICAgbmF2Q3VycmVudCA9IG5hdkl0ZW1zW25hdkN1cnJlbnRJbmRleF07XFxuICAgICAgICBzZXRBdHRycyhuYXZQcmV2LCB7XFxuICAgICAgICAgICd0YWJpbmRleCc6ICctMScsXFxuICAgICAgICAgICdhcmlhLWxhYmVsJzogbmF2U3RyICsgKG5hdkN1cnJlbnRJbmRleENhY2hlZCArIDEpXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJlbW92ZUNsYXNzKG5hdlByZXYsIG5hdkFjdGl2ZUNsYXNzKTtcXG4gICAgICAgIHNldEF0dHJzKG5hdkN1cnJlbnQsIHtcXG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiBuYXZTdHIgKyAobmF2Q3VycmVudEluZGV4ICsgMSkgKyBuYXZTdHJDdXJyZW50XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJlbW92ZUF0dHJzKG5hdkN1cnJlbnQsICd0YWJpbmRleCcpO1xcbiAgICAgICAgYWRkQ2xhc3MobmF2Q3VycmVudCwgbmF2QWN0aXZlQ2xhc3MpO1xcbiAgICAgICAgbmF2Q3VycmVudEluZGV4Q2FjaGVkID0gbmF2Q3VycmVudEluZGV4O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0TG93ZXJDYXNlTm9kZU5hbWUoZWwpIHtcXG4gICAgcmV0dXJuIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc0J1dHRvbihlbCkge1xcbiAgICByZXR1cm4gZ2V0TG93ZXJDYXNlTm9kZU5hbWUoZWwpID09PSAnYnV0dG9uJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzQXJpYURpc2FibGVkKGVsKSB7XFxuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZGlzRW5hYmxlRWxlbWVudChpc0J1dHRvbiwgZWwsIHZhbCkge1xcbiAgICBpZiAoaXNCdXR0b24pIHtcXG4gICAgICBlbC5kaXNhYmxlZCA9IHZhbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCB2YWwudG9TdHJpbmcoKSk7XFxuICAgIH1cXG4gIH0gLy8gc2V0ICdkaXNhYmxlZCcgdG8gdHJ1ZSBvbiBjb250cm9scyB3aGVuIHJlYWNoIHRoZSBlZGdlc1xcblxcblxcbiAgZnVuY3Rpb24gdXBkYXRlQ29udHJvbHNTdGF0dXMoKSB7XFxuICAgIGlmICghY29udHJvbHMgfHwgcmV3aW5kIHx8IGxvb3ApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZEaXNhYmxlZCA9IHByZXZJc0J1dHRvbiA/IHByZXZCdXR0b24uZGlzYWJsZWQgOiBpc0FyaWFEaXNhYmxlZChwcmV2QnV0dG9uKSxcXG4gICAgICAgIG5leHREaXNhYmxlZCA9IG5leHRJc0J1dHRvbiA/IG5leHRCdXR0b24uZGlzYWJsZWQgOiBpc0FyaWFEaXNhYmxlZChuZXh0QnV0dG9uKSxcXG4gICAgICAgIGRpc2FibGVQcmV2ID0gaW5kZXggPD0gaW5kZXhNaW4gPyB0cnVlIDogZmFsc2UsXFxuICAgICAgICBkaXNhYmxlTmV4dCA9ICFyZXdpbmQgJiYgaW5kZXggPj0gaW5kZXhNYXggPyB0cnVlIDogZmFsc2U7XFxuXFxuICAgIGlmIChkaXNhYmxlUHJldiAmJiAhcHJldkRpc2FibGVkKSB7XFxuICAgICAgZGlzRW5hYmxlRWxlbWVudChwcmV2SXNCdXR0b24sIHByZXZCdXR0b24sIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIGlmICghZGlzYWJsZVByZXYgJiYgcHJldkRpc2FibGVkKSB7XFxuICAgICAgZGlzRW5hYmxlRWxlbWVudChwcmV2SXNCdXR0b24sIHByZXZCdXR0b24sIGZhbHNlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGlzYWJsZU5leHQgJiYgIW5leHREaXNhYmxlZCkge1xcbiAgICAgIGRpc0VuYWJsZUVsZW1lbnQobmV4dElzQnV0dG9uLCBuZXh0QnV0dG9uLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIWRpc2FibGVOZXh0ICYmIG5leHREaXNhYmxlZCkge1xcbiAgICAgIGRpc0VuYWJsZUVsZW1lbnQobmV4dElzQnV0dG9uLCBuZXh0QnV0dG9uLCBmYWxzZSk7XFxuICAgIH1cXG4gIH0gLy8gc2V0IGR1cmF0aW9uXFxuXFxuXFxuICBmdW5jdGlvbiByZXNldER1cmF0aW9uKGVsLCBzdHIpIHtcXG4gICAgaWYgKFRSQU5TSVRJT05EVVJBVElPTikge1xcbiAgICAgIGVsLnN0eWxlW1RSQU5TSVRJT05EVVJBVElPTl0gPSBzdHI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFNsaWRlcldpZHRoKCkge1xcbiAgICByZXR1cm4gZml4ZWRXaWR0aCA/IChmaXhlZFdpZHRoICsgZ3V0dGVyKSAqIHNsaWRlQ291bnROZXcgOiBzbGlkZVBvc2l0aW9uc1tzbGlkZUNvdW50TmV3XTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldENlbnRlckdhcChudW0pIHtcXG4gICAgaWYgKG51bSA9PSBudWxsKSB7XFxuICAgICAgbnVtID0gaW5kZXg7XFxuICAgIH1cXG5cXG4gICAgdmFyIGdhcCA9IGVkZ2VQYWRkaW5nID8gZ3V0dGVyIDogMDtcXG4gICAgcmV0dXJuIGF1dG9XaWR0aCA/ICh2aWV3cG9ydCAtIGdhcCAtIChzbGlkZVBvc2l0aW9uc1tudW0gKyAxXSAtIHNsaWRlUG9zaXRpb25zW251bV0gLSBndXR0ZXIpKSAvIDIgOiBmaXhlZFdpZHRoID8gKHZpZXdwb3J0IC0gZml4ZWRXaWR0aCkgLyAyIDogKGl0ZW1zIC0gMSkgLyAyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0UmlnaHRCb3VuZGFyeSgpIHtcXG4gICAgdmFyIGdhcCA9IGVkZ2VQYWRkaW5nID8gZ3V0dGVyIDogMCxcXG4gICAgICAgIHJlc3VsdCA9IHZpZXdwb3J0ICsgZ2FwIC0gZ2V0U2xpZGVyV2lkdGgoKTtcXG5cXG4gICAgaWYgKGNlbnRlciAmJiAhbG9vcCkge1xcbiAgICAgIHJlc3VsdCA9IGZpeGVkV2lkdGggPyAtKGZpeGVkV2lkdGggKyBndXR0ZXIpICogKHNsaWRlQ291bnROZXcgLSAxKSAtIGdldENlbnRlckdhcCgpIDogZ2V0Q2VudGVyR2FwKHNsaWRlQ291bnROZXcgLSAxKSAtIHNsaWRlUG9zaXRpb25zW3NsaWRlQ291bnROZXcgLSAxXTtcXG4gICAgfVxcblxcbiAgICBpZiAocmVzdWx0ID4gMCkge1xcbiAgICAgIHJlc3VsdCA9IDA7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldENvbnRhaW5lclRyYW5zZm9ybVZhbHVlKG51bSkge1xcbiAgICBpZiAobnVtID09IG51bGwpIHtcXG4gICAgICBudW0gPSBpbmRleDtcXG4gICAgfVxcblxcbiAgICB2YXIgdmFsO1xcblxcbiAgICBpZiAoaG9yaXpvbnRhbCAmJiAhYXV0b1dpZHRoKSB7XFxuICAgICAgaWYgKGZpeGVkV2lkdGgpIHtcXG4gICAgICAgIHZhbCA9IC0oZml4ZWRXaWR0aCArIGd1dHRlcikgKiBudW07XFxuXFxuICAgICAgICBpZiAoY2VudGVyKSB7XFxuICAgICAgICAgIHZhbCArPSBnZXRDZW50ZXJHYXAoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gVFJBTlNGT1JNID8gc2xpZGVDb3VudE5ldyA6IGl0ZW1zO1xcblxcbiAgICAgICAgaWYgKGNlbnRlcikge1xcbiAgICAgICAgICBudW0gLT0gZ2V0Q2VudGVyR2FwKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YWwgPSAtbnVtICogMTAwIC8gZGVub21pbmF0b3I7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhbCA9IC1zbGlkZVBvc2l0aW9uc1tudW1dO1xcblxcbiAgICAgIGlmIChjZW50ZXIgJiYgYXV0b1dpZHRoKSB7XFxuICAgICAgICB2YWwgKz0gZ2V0Q2VudGVyR2FwKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChoYXNSaWdodERlYWRab25lKSB7XFxuICAgICAgdmFsID0gTWF0aC5tYXgodmFsLCByaWdodEJvdW5kYXJ5KTtcXG4gICAgfVxcblxcbiAgICB2YWwgKz0gaG9yaXpvbnRhbCAmJiAhYXV0b1dpZHRoICYmICFmaXhlZFdpZHRoID8gJyUnIDogJ3B4JztcXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRvQ29udGFpbmVyVHJhbnNmb3JtU2lsZW50KHZhbCkge1xcbiAgICByZXNldER1cmF0aW9uKGNvbnRhaW5lciwgJzBzJyk7XFxuICAgIGRvQ29udGFpbmVyVHJhbnNmb3JtKHZhbCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb0NvbnRhaW5lclRyYW5zZm9ybSh2YWwpIHtcXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XFxuICAgICAgdmFsID0gZ2V0Q29udGFpbmVyVHJhbnNmb3JtVmFsdWUoKTtcXG4gICAgfVxcblxcbiAgICBjb250YWluZXIuc3R5bGVbdHJhbnNmb3JtQXR0cl0gPSB0cmFuc2Zvcm1QcmVmaXggKyB2YWwgKyB0cmFuc2Zvcm1Qb3N0Zml4O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYW5pbWF0ZVNsaWRlKG51bWJlciwgY2xhc3NPdXQsIGNsYXNzSW4sIGlzT3V0KSB7XFxuICAgIHZhciBsID0gbnVtYmVyICsgaXRlbXM7XFxuXFxuICAgIGlmICghbG9vcCkge1xcbiAgICAgIGwgPSBNYXRoLm1pbihsLCBzbGlkZUNvdW50TmV3KTtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBpID0gbnVtYmVyOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgdmFyIGl0ZW0gPSBzbGlkZUl0ZW1zW2ldOyAvLyBzZXQgaXRlbSBwb3NpdGlvbnNcXG5cXG4gICAgICBpZiAoIWlzT3V0KSB7XFxuICAgICAgICBpdGVtLnN0eWxlLmxlZnQgPSAoaSAtIGluZGV4KSAqIDEwMCAvIGl0ZW1zICsgJyUnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYW5pbWF0ZURlbGF5ICYmIFRSQU5TSVRJT05ERUxBWSkge1xcbiAgICAgICAgaXRlbS5zdHlsZVtUUkFOU0lUSU9OREVMQVldID0gaXRlbS5zdHlsZVtBTklNQVRJT05ERUxBWV0gPSBhbmltYXRlRGVsYXkgKiAoaSAtIG51bWJlcikgLyAxMDAwICsgJ3MnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZW1vdmVDbGFzcyhpdGVtLCBjbGFzc091dCk7XFxuICAgICAgYWRkQ2xhc3MoaXRlbSwgY2xhc3NJbik7XFxuXFxuICAgICAgaWYgKGlzT3V0KSB7XFxuICAgICAgICBzbGlkZUl0ZW1zT3V0LnB1c2goaXRlbSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IC8vIG1ha2UgdHJhbnNmZXIgYWZ0ZXIgY2xpY2svZHJhZzpcXG4gIC8vIDEuIGNoYW5nZSAndHJhbnNmb3JtJyBwcm9wZXJ0eSBmb3IgbW9yZGVybiBicm93c2Vyc1xcbiAgLy8gMi4gY2hhbmdlICdsZWZ0JyBwcm9wZXJ0eSBmb3IgbGVnYWN5IGJyb3dzZXJzXFxuXFxuXFxuICB2YXIgdHJhbnNmb3JtQ29yZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIGNhcm91c2VsID8gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJlc2V0RHVyYXRpb24oY29udGFpbmVyLCAnJyk7XFxuXFxuICAgICAgaWYgKFRSQU5TSVRJT05EVVJBVElPTiB8fCAhc3BlZWQpIHtcXG4gICAgICAgIC8vIGZvciBtb3JkZW4gYnJvd3NlcnMgd2l0aCBub24temVybyBkdXJhdGlvbiBvclxcbiAgICAgICAgLy8gemVybyBkdXJhdGlvbiBmb3IgYWxsIGJyb3dzZXJzXFxuICAgICAgICBkb0NvbnRhaW5lclRyYW5zZm9ybSgpOyAvLyBydW4gZmFsbGJhY2sgZnVuY3Rpb24gbWFudWFsbHlcXG4gICAgICAgIC8vIHdoZW4gZHVyYXRpb24gaXMgMCAvIGNvbnRhaW5lciBpcyBoaWRkZW5cXG5cXG4gICAgICAgIGlmICghc3BlZWQgfHwgIWlzVmlzaWJsZShjb250YWluZXIpKSB7XFxuICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBmb3Igb2xkIGJyb3dzZXIgd2l0aCBub24temVybyBkdXJhdGlvblxcbiAgICAgICAganNUcmFuc2Zvcm0oY29udGFpbmVyLCB0cmFuc2Zvcm1BdHRyLCB0cmFuc2Zvcm1QcmVmaXgsIHRyYW5zZm9ybVBvc3RmaXgsIGdldENvbnRhaW5lclRyYW5zZm9ybVZhbHVlKCksIHNwZWVkLCBvblRyYW5zaXRpb25FbmQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWhvcml6b250YWwpIHtcXG4gICAgICAgIHVwZGF0ZUNvbnRlbnRXcmFwcGVySGVpZ2h0KCk7XFxuICAgICAgfVxcbiAgICB9IDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHNsaWRlSXRlbXNPdXQgPSBbXTtcXG4gICAgICB2YXIgZXZlID0ge307XFxuICAgICAgZXZlW1RSQU5TSVRJT05FTkRdID0gZXZlW0FOSU1BVElPTkVORF0gPSBvblRyYW5zaXRpb25FbmQ7XFxuICAgICAgcmVtb3ZlRXZlbnRzKHNsaWRlSXRlbXNbaW5kZXhDYWNoZWRdLCBldmUpO1xcbiAgICAgIGFkZEV2ZW50cyhzbGlkZUl0ZW1zW2luZGV4XSwgZXZlKTtcXG4gICAgICBhbmltYXRlU2xpZGUoaW5kZXhDYWNoZWQsIGFuaW1hdGVJbiwgYW5pbWF0ZU91dCwgdHJ1ZSk7XFxuICAgICAgYW5pbWF0ZVNsaWRlKGluZGV4LCBhbmltYXRlTm9ybWFsLCBhbmltYXRlSW4pOyAvLyBydW4gZmFsbGJhY2sgZnVuY3Rpb24gbWFudWFsbHlcXG4gICAgICAvLyB3aGVuIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uIG5vdCBzdXBwb3J0ZWQgLyBkdXJhdGlvbiBpcyAwXFxuXFxuICAgICAgaWYgKCFUUkFOU0lUSU9ORU5EIHx8ICFBTklNQVRJT05FTkQgfHwgIXNwZWVkIHx8ICFpc1Zpc2libGUoY29udGFpbmVyKSkge1xcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kKCk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfSgpO1xcblxcbiAgZnVuY3Rpb24gcmVuZGVyKGUsIHNsaWRlck1vdmVkKSB7XFxuICAgIGlmICh1cGRhdGVJbmRleEJlZm9yZVRyYW5zZm9ybSkge1xcbiAgICAgIHVwZGF0ZUluZGV4KCk7XFxuICAgIH0gLy8gcmVuZGVyIHdoZW4gc2xpZGVyIHdhcyBtb3ZlZCAodG91Y2ggb3IgZHJhZykgZXZlbiB0aG91Z2ggaW5kZXggbWF5IG5vdCBjaGFuZ2VcXG5cXG5cXG4gICAgaWYgKGluZGV4ICE9PSBpbmRleENhY2hlZCB8fCBzbGlkZXJNb3ZlZCkge1xcbiAgICAgIC8vIGV2ZW50c1xcbiAgICAgIGV2ZW50cy5lbWl0KCdpbmRleENoYW5nZWQnLCBpbmZvKCkpO1xcbiAgICAgIGV2ZW50cy5lbWl0KCd0cmFuc2l0aW9uU3RhcnQnLCBpbmZvKCkpO1xcblxcbiAgICAgIGlmIChhdXRvSGVpZ2h0KSB7XFxuICAgICAgICBkb0F1dG9IZWlnaHQoKTtcXG4gICAgICB9IC8vIHBhdXNlIGF1dG9wbGF5IHdoZW4gY2xpY2sgb3Iga2V5ZG93biBmcm9tIHVzZXJcXG5cXG5cXG4gICAgICBpZiAoYW5pbWF0aW5nICYmIGUgJiYgWydjbGljaycsICdrZXlkb3duJ10uaW5kZXhPZihlLnR5cGUpID49IDApIHtcXG4gICAgICAgIHN0b3BBdXRvcGxheSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBydW5uaW5nID0gdHJ1ZTtcXG4gICAgICB0cmFuc2Zvcm1Db3JlKCk7XFxuICAgIH1cXG4gIH1cXG4gIC8qXFxuICAgKiBUcmFuc2ZlciBwcmVmaXhlZCBwcm9wZXJ0aWVzIHRvIHRoZSBzYW1lIGZvcm1hdFxcbiAgICogQ1NTOiAtV2Via2l0LVRyYW5zZm9ybSA9PiB3ZWJraXR0cmFuc2Zvcm1cXG4gICAqIEpTOiBXZWJraXRUcmFuc2Zvcm0gPT4gd2Via2l0dHJhbnNmb3JtXFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gcHJvcGVydHlcXG4gICAqXFxuICAgKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIHN0clRyYW5zKHN0cikge1xcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnJyk7XFxuICB9IC8vIEFGVEVSIFRSQU5TRk9STVxcbiAgLy8gVGhpbmdzIG5lZWQgdG8gYmUgZG9uZSBhZnRlciBhIHRyYW5zZmVyOlxcbiAgLy8gMS4gY2hlY2sgaW5kZXhcXG4gIC8vIDIuIGFkZCBjbGFzc2VzIHRvIHZpc2libGUgc2xpZGVcXG4gIC8vIDMuIGRpc2FibGUgY29udHJvbHMgYnV0dG9ucyB3aGVuIHJlYWNoIHRoZSBmaXJzdC9sYXN0IHNsaWRlIGluIG5vbi1sb29wIHNsaWRlclxcbiAgLy8gNC4gdXBkYXRlIG5hdiBzdGF0dXNcXG4gIC8vIDUuIGxhenlsb2FkIGltYWdlc1xcbiAgLy8gNi4gdXBkYXRlIGNvbnRhaW5lciBoZWlnaHRcXG5cXG5cXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xcbiAgICAvLyBjaGVjayBydW5uaW5nIG9uIGdhbGxlcnkgbW9kZVxcbiAgICAvLyBtYWtlIHN1cmUgdHJhbnRpb25lbmQvYW5pbWF0aW9uZW5kIGV2ZW50cyBydW4gb25seSBvbmNlXFxuICAgIGlmIChjYXJvdXNlbCB8fCBydW5uaW5nKSB7XFxuICAgICAgZXZlbnRzLmVtaXQoJ3RyYW5zaXRpb25FbmQnLCBpbmZvKGV2ZW50KSk7XFxuXFxuICAgICAgaWYgKCFjYXJvdXNlbCAmJiBzbGlkZUl0ZW1zT3V0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVJdGVtc091dC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgaXRlbSA9IHNsaWRlSXRlbXNPdXRbaV07IC8vIHNldCBpdGVtIHBvc2l0aW9uc1xcblxcbiAgICAgICAgICBpdGVtLnN0eWxlLmxlZnQgPSAnJztcXG5cXG4gICAgICAgICAgaWYgKEFOSU1BVElPTkRFTEFZICYmIFRSQU5TSVRJT05ERUxBWSkge1xcbiAgICAgICAgICAgIGl0ZW0uc3R5bGVbQU5JTUFUSU9OREVMQVldID0gJyc7XFxuICAgICAgICAgICAgaXRlbS5zdHlsZVtUUkFOU0lUSU9OREVMQVldID0gJyc7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaXRlbSwgYW5pbWF0ZU91dCk7XFxuICAgICAgICAgIGFkZENsYXNzKGl0ZW0sIGFuaW1hdGVOb3JtYWwpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKiB1cGRhdGUgc2xpZGVzLCBuYXYsIGNvbnRyb2xzIGFmdGVyIGNoZWNraW5nIC4uLlxcbiAgICAgICAqID0+IGxlZ2FjeSBicm93c2VycyB3aG8gZG9uJ3Qgc3VwcG9ydCAnZXZlbnQnXFxuICAgICAgICogICAgaGF2ZSB0byBjaGVjayBldmVudCBmaXJzdCwgb3RoZXJ3aXNlIGV2ZW50LnRhcmdldCB3aWxsIGNhdXNlIGFuIGVycm9yXFxuICAgICAgICogPT4gb3IgJ2dhbGxlcnknIG1vZGU6XFxuICAgICAgICogICArIGV2ZW50IHRhcmdldCBpcyBzbGlkZSBpdGVtXFxuICAgICAgICogPT4gb3IgJ2Nhcm91c2VsJyBtb2RlOlxcbiAgICAgICAqICAgKyBldmVudCB0YXJnZXQgaXMgY29udGFpbmVyLFxcbiAgICAgICAqICAgKyBldmVudC5wcm9wZXJ0eSBpcyB0aGUgc2FtZSB3aXRoIHRyYW5zZm9ybSBhdHRyaWJ1dGVcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICBpZiAoIWV2ZW50IHx8ICFjYXJvdXNlbCAmJiBldmVudC50YXJnZXQucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyIHx8IGV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyICYmIHN0clRyYW5zKGV2ZW50LnByb3BlcnR5TmFtZSkgPT09IHN0clRyYW5zKHRyYW5zZm9ybUF0dHIpKSB7XFxuICAgICAgICBpZiAoIXVwZGF0ZUluZGV4QmVmb3JlVHJhbnNmb3JtKSB7XFxuICAgICAgICAgIHZhciBpbmRleFRlbSA9IGluZGV4O1xcbiAgICAgICAgICB1cGRhdGVJbmRleCgpO1xcblxcbiAgICAgICAgICBpZiAoaW5kZXggIT09IGluZGV4VGVtKSB7XFxuICAgICAgICAgICAgZXZlbnRzLmVtaXQoJ2luZGV4Q2hhbmdlZCcsIGluZm8oKSk7XFxuICAgICAgICAgICAgZG9Db250YWluZXJUcmFuc2Zvcm1TaWxlbnQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG5lc3RlZCA9PT0gJ2lubmVyJykge1xcbiAgICAgICAgICBldmVudHMuZW1pdCgnaW5uZXJMb2FkZWQnLCBpbmZvKCkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xcbiAgICAgICAgaW5kZXhDYWNoZWQgPSBpbmRleDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gLy8gIyBBQ1RJT05TXFxuXFxuXFxuICBmdW5jdGlvbiBnb1RvKHRhcmdldEluZGV4LCBlKSB7XFxuICAgIGlmIChmcmVlemUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH0gLy8gcHJldiBzbGlkZUJ5XFxuXFxuXFxuICAgIGlmICh0YXJnZXRJbmRleCA9PT0gJ3ByZXYnKSB7XFxuICAgICAgb25Db250cm9sc0NsaWNrKGUsIC0xKTsgLy8gbmV4dCBzbGlkZUJ5XFxuICAgIH0gZWxzZSBpZiAodGFyZ2V0SW5kZXggPT09ICduZXh0Jykge1xcbiAgICAgIG9uQ29udHJvbHNDbGljayhlLCAxKTsgLy8gZ28gdG8gZXhhY3Qgc2xpZGVcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAocnVubmluZykge1xcbiAgICAgICAgaWYgKHByZXZlbnRBY3Rpb25XaGVuUnVubmluZykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvblRyYW5zaXRpb25FbmQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGFic0luZGV4ID0gZ2V0QWJzSW5kZXgoKSxcXG4gICAgICAgICAgaW5kZXhHYXAgPSAwO1xcblxcbiAgICAgIGlmICh0YXJnZXRJbmRleCA9PT0gJ2ZpcnN0Jykge1xcbiAgICAgICAgaW5kZXhHYXAgPSAtYWJzSW5kZXg7XFxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRJbmRleCA9PT0gJ2xhc3QnKSB7XFxuICAgICAgICBpbmRleEdhcCA9IGNhcm91c2VsID8gc2xpZGVDb3VudCAtIGl0ZW1zIC0gYWJzSW5kZXggOiBzbGlkZUNvdW50IC0gMSAtIGFic0luZGV4O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldEluZGV4ICE9PSAnbnVtYmVyJykge1xcbiAgICAgICAgICB0YXJnZXRJbmRleCA9IHBhcnNlSW50KHRhcmdldEluZGV4KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghaXNOYU4odGFyZ2V0SW5kZXgpKSB7XFxuICAgICAgICAgIC8vIGZyb20gZGlyZWN0bHkgY2FsbGVkIGdvVG8gZnVuY3Rpb25cXG4gICAgICAgICAgaWYgKCFlKSB7XFxuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzbGlkZUNvdW50IC0gMSwgdGFyZ2V0SW5kZXgpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbmRleEdhcCA9IHRhcmdldEluZGV4IC0gYWJzSW5kZXg7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBnYWxsZXJ5OiBtYWtlIHN1cmUgbmV3IHBhZ2Ugd29uJ3Qgb3ZlcmxhcCB3aXRoIGN1cnJlbnQgcGFnZVxcblxcblxcbiAgICAgIGlmICghY2Fyb3VzZWwgJiYgaW5kZXhHYXAgJiYgTWF0aC5hYnMoaW5kZXhHYXApIDwgaXRlbXMpIHtcXG4gICAgICAgIHZhciBmYWN0b3IgPSBpbmRleEdhcCA+IDAgPyAxIDogLTE7XFxuICAgICAgICBpbmRleEdhcCArPSBpbmRleCArIGluZGV4R2FwIC0gc2xpZGVDb3VudCA+PSBpbmRleE1pbiA/IHNsaWRlQ291bnQgKiBmYWN0b3IgOiBzbGlkZUNvdW50ICogMiAqIGZhY3RvciAqIC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbmRleCArPSBpbmRleEdhcDsgLy8gbWFrZSBzdXJlIGluZGV4IGlzIGluIHJhbmdlXFxuXFxuICAgICAgaWYgKGNhcm91c2VsICYmIGxvb3ApIHtcXG4gICAgICAgIGlmIChpbmRleCA8IGluZGV4TWluKSB7XFxuICAgICAgICAgIGluZGV4ICs9IHNsaWRlQ291bnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaW5kZXggPiBpbmRleE1heCkge1xcbiAgICAgICAgICBpbmRleCAtPSBzbGlkZUNvdW50O1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gaWYgaW5kZXggaXMgY2hhbmdlZCwgc3RhcnQgcmVuZGVyaW5nXFxuXFxuXFxuICAgICAgaWYgKGdldEFic0luZGV4KGluZGV4KSAhPT0gZ2V0QWJzSW5kZXgoaW5kZXhDYWNoZWQpKSB7XFxuICAgICAgICByZW5kZXIoZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IC8vIG9uIGNvbnRyb2xzIGNsaWNrXFxuXFxuXFxuICBmdW5jdGlvbiBvbkNvbnRyb2xzQ2xpY2soZSwgZGlyKSB7XFxuICAgIGlmIChydW5uaW5nKSB7XFxuICAgICAgaWYgKHByZXZlbnRBY3Rpb25XaGVuUnVubmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvblRyYW5zaXRpb25FbmQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHBhc3NFdmVudE9iamVjdDtcXG5cXG4gICAgaWYgKCFkaXIpIHtcXG4gICAgICBlID0gZ2V0RXZlbnQoZSk7XFxuICAgICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChlKTtcXG5cXG4gICAgICB3aGlsZSAodGFyZ2V0ICE9PSBjb250cm9sc0NvbnRhaW5lciAmJiBbcHJldkJ1dHRvbiwgbmV4dEJ1dHRvbl0uaW5kZXhPZih0YXJnZXQpIDwgMCkge1xcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0YXJnZXRJbiA9IFtwcmV2QnV0dG9uLCBuZXh0QnV0dG9uXS5pbmRleE9mKHRhcmdldCk7XFxuXFxuICAgICAgaWYgKHRhcmdldEluID49IDApIHtcXG4gICAgICAgIHBhc3NFdmVudE9iamVjdCA9IHRydWU7XFxuICAgICAgICBkaXIgPSB0YXJnZXRJbiA9PT0gMCA/IC0xIDogMTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHJld2luZCkge1xcbiAgICAgIGlmIChpbmRleCA9PT0gaW5kZXhNaW4gJiYgZGlyID09PSAtMSkge1xcbiAgICAgICAgZ29UbygnbGFzdCcsIGUpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGluZGV4TWF4ICYmIGRpciA9PT0gMSkge1xcbiAgICAgICAgZ29UbygnZmlyc3QnLCBlKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGRpcikge1xcbiAgICAgIGluZGV4ICs9IHNsaWRlQnkgKiBkaXI7XFxuXFxuICAgICAgaWYgKGF1dG9XaWR0aCkge1xcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcXG4gICAgICB9IC8vIHBhc3MgZSB3aGVuIGNsaWNrIGNvbnRyb2wgYnV0dG9ucyBvciBrZXlkb3duXFxuXFxuXFxuICAgICAgcmVuZGVyKHBhc3NFdmVudE9iamVjdCB8fCBlICYmIGUudHlwZSA9PT0gJ2tleWRvd24nID8gZSA6IG51bGwpO1xcbiAgICB9XFxuICB9IC8vIG9uIG5hdiBjbGlja1xcblxcblxcbiAgZnVuY3Rpb24gb25OYXZDbGljayhlKSB7XFxuICAgIGlmIChydW5uaW5nKSB7XFxuICAgICAgaWYgKHByZXZlbnRBY3Rpb25XaGVuUnVubmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvblRyYW5zaXRpb25FbmQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZSA9IGdldEV2ZW50KGUpO1xcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGUpLFxcbiAgICAgICAgbmF2SW5kZXg7IC8vIGZpbmQgdGhlIGNsaWNrZWQgbmF2IGl0ZW1cXG5cXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gbmF2Q29udGFpbmVyICYmICFoYXNBdHRyKHRhcmdldCwgJ2RhdGEtbmF2JykpIHtcXG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcXG4gICAgfVxcblxcbiAgICBpZiAoaGFzQXR0cih0YXJnZXQsICdkYXRhLW5hdicpKSB7XFxuICAgICAgdmFyIG5hdkluZGV4ID0gbmF2Q2xpY2tlZCA9IE51bWJlcihnZXRBdHRyKHRhcmdldCwgJ2RhdGEtbmF2JykpLFxcbiAgICAgICAgICB0YXJnZXRJbmRleEJhc2UgPSBmaXhlZFdpZHRoIHx8IGF1dG9XaWR0aCA/IG5hdkluZGV4ICogc2xpZGVDb3VudCAvIHBhZ2VzIDogbmF2SW5kZXggKiBpdGVtcyxcXG4gICAgICAgICAgdGFyZ2V0SW5kZXggPSBuYXZBc1RodW1ibmFpbHMgPyBuYXZJbmRleCA6IE1hdGgubWluKE1hdGguY2VpbCh0YXJnZXRJbmRleEJhc2UpLCBzbGlkZUNvdW50IC0gMSk7XFxuICAgICAgZ29Ubyh0YXJnZXRJbmRleCwgZSk7XFxuXFxuICAgICAgaWYgKG5hdkN1cnJlbnRJbmRleCA9PT0gbmF2SW5kZXgpIHtcXG4gICAgICAgIGlmIChhbmltYXRpbmcpIHtcXG4gICAgICAgICAgc3RvcEF1dG9wbGF5KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBuYXZDbGlja2VkID0gLTE7IC8vIHJlc2V0IG5hdkNsaWNrZWRcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gLy8gYXV0b3BsYXkgZnVuY3Rpb25zXFxuXFxuXFxuICBmdW5jdGlvbiBzZXRBdXRvcGxheVRpbWVyKCkge1xcbiAgICBhdXRvcGxheVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xcbiAgICAgIG9uQ29udHJvbHNDbGljayhudWxsLCBhdXRvcGxheURpcmVjdGlvbik7XFxuICAgIH0sIGF1dG9wbGF5VGltZW91dCk7XFxuICAgIGFuaW1hdGluZyA9IHRydWU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdG9wQXV0b3BsYXlUaW1lcigpIHtcXG4gICAgY2xlYXJJbnRlcnZhbChhdXRvcGxheVRpbWVyKTtcXG4gICAgYW5pbWF0aW5nID0gZmFsc2U7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVBdXRvcGxheUJ1dHRvbihhY3Rpb24sIHR4dCkge1xcbiAgICBzZXRBdHRycyhhdXRvcGxheUJ1dHRvbiwge1xcbiAgICAgICdkYXRhLWFjdGlvbic6IGFjdGlvblxcbiAgICB9KTtcXG4gICAgYXV0b3BsYXlCdXR0b24uaW5uZXJIVE1MID0gYXV0b3BsYXlIdG1sU3RyaW5nc1swXSArIGFjdGlvbiArIGF1dG9wbGF5SHRtbFN0cmluZ3NbMV0gKyB0eHQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdGFydEF1dG9wbGF5KCkge1xcbiAgICBzZXRBdXRvcGxheVRpbWVyKCk7XFxuXFxuICAgIGlmIChhdXRvcGxheUJ1dHRvbikge1xcbiAgICAgIHVwZGF0ZUF1dG9wbGF5QnV0dG9uKCdzdG9wJywgYXV0b3BsYXlUZXh0WzFdKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RvcEF1dG9wbGF5KCkge1xcbiAgICBzdG9wQXV0b3BsYXlUaW1lcigpO1xcblxcbiAgICBpZiAoYXV0b3BsYXlCdXR0b24pIHtcXG4gICAgICB1cGRhdGVBdXRvcGxheUJ1dHRvbignc3RhcnQnLCBhdXRvcGxheVRleHRbMF0pO1xcbiAgICB9XFxuICB9IC8vIHByb2dyYW1haXRjYWxseSBwbGF5L3BhdXNlIHRoZSBzbGlkZXJcXG5cXG5cXG4gIGZ1bmN0aW9uIHBsYXkoKSB7XFxuICAgIGlmIChhdXRvcGxheSAmJiAhYW5pbWF0aW5nKSB7XFxuICAgICAgc3RhcnRBdXRvcGxheSgpO1xcbiAgICAgIGF1dG9wbGF5VXNlclBhdXNlZCA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwYXVzZSgpIHtcXG4gICAgaWYgKGFuaW1hdGluZykge1xcbiAgICAgIHN0b3BBdXRvcGxheSgpO1xcbiAgICAgIGF1dG9wbGF5VXNlclBhdXNlZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHRvZ2dsZUF1dG9wbGF5KCkge1xcbiAgICBpZiAoYW5pbWF0aW5nKSB7XFxuICAgICAgc3RvcEF1dG9wbGF5KCk7XFxuICAgICAgYXV0b3BsYXlVc2VyUGF1c2VkID0gdHJ1ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGFydEF1dG9wbGF5KCk7XFxuICAgICAgYXV0b3BsYXlVc2VyUGF1c2VkID0gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcXG4gICAgaWYgKGRvYy5oaWRkZW4pIHtcXG4gICAgICBpZiAoYW5pbWF0aW5nKSB7XFxuICAgICAgICBzdG9wQXV0b3BsYXlUaW1lcigpO1xcbiAgICAgICAgYXV0b3BsYXlWaXNpYmlsaXR5UGF1c2VkID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoYXV0b3BsYXlWaXNpYmlsaXR5UGF1c2VkKSB7XFxuICAgICAgc2V0QXV0b3BsYXlUaW1lcigpO1xcbiAgICAgIGF1dG9wbGF5VmlzaWJpbGl0eVBhdXNlZCA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtb3VzZW92ZXJQYXVzZSgpIHtcXG4gICAgaWYgKGFuaW1hdGluZykge1xcbiAgICAgIHN0b3BBdXRvcGxheVRpbWVyKCk7XFxuICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1vdXNlb3V0UmVzdGFydCgpIHtcXG4gICAgaWYgKGF1dG9wbGF5SG92ZXJQYXVzZWQpIHtcXG4gICAgICBzZXRBdXRvcGxheVRpbWVyKCk7XFxuICAgICAgYXV0b3BsYXlIb3ZlclBhdXNlZCA9IGZhbHNlO1xcbiAgICB9XFxuICB9IC8vIGtleWRvd24gZXZlbnRzIG9uIGRvY3VtZW50XFxuXFxuXFxuICBmdW5jdGlvbiBvbkRvY3VtZW50S2V5ZG93bihlKSB7XFxuICAgIGUgPSBnZXRFdmVudChlKTtcXG4gICAgdmFyIGtleUluZGV4ID0gW0tFWVMuTEVGVCwgS0VZUy5SSUdIVF0uaW5kZXhPZihlLmtleUNvZGUpO1xcblxcbiAgICBpZiAoa2V5SW5kZXggPj0gMCkge1xcbiAgICAgIG9uQ29udHJvbHNDbGljayhlLCBrZXlJbmRleCA9PT0gMCA/IC0xIDogMSk7XFxuICAgIH1cXG4gIH0gLy8gb24ga2V5IGNvbnRyb2xcXG5cXG5cXG4gIGZ1bmN0aW9uIG9uQ29udHJvbHNLZXlkb3duKGUpIHtcXG4gICAgZSA9IGdldEV2ZW50KGUpO1xcbiAgICB2YXIga2V5SW5kZXggPSBbS0VZUy5MRUZULCBLRVlTLlJJR0hUXS5pbmRleE9mKGUua2V5Q29kZSk7XFxuXFxuICAgIGlmIChrZXlJbmRleCA+PSAwKSB7XFxuICAgICAgaWYgKGtleUluZGV4ID09PSAwKSB7XFxuICAgICAgICBpZiAoIXByZXZCdXR0b24uZGlzYWJsZWQpIHtcXG4gICAgICAgICAgb25Db250cm9sc0NsaWNrKGUsIC0xKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKCFuZXh0QnV0dG9uLmRpc2FibGVkKSB7XFxuICAgICAgICBvbkNvbnRyb2xzQ2xpY2soZSwgMSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IC8vIHNldCBmb2N1c1xcblxcblxcbiAgZnVuY3Rpb24gc2V0Rm9jdXMoZWwpIHtcXG4gICAgZWwuZm9jdXMoKTtcXG4gIH0gLy8gb24ga2V5IG5hdlxcblxcblxcbiAgZnVuY3Rpb24gb25OYXZLZXlkb3duKGUpIHtcXG4gICAgZSA9IGdldEV2ZW50KGUpO1xcbiAgICB2YXIgY3VyRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xcblxcbiAgICBpZiAoIWhhc0F0dHIoY3VyRWxlbWVudCwgJ2RhdGEtbmF2JykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH0gLy8gdmFyIGNvZGUgPSBlLmtleUNvZGUsXFxuXFxuXFxuICAgIHZhciBrZXlJbmRleCA9IFtLRVlTLkxFRlQsIEtFWVMuUklHSFQsIEtFWVMuRU5URVIsIEtFWVMuU1BBQ0VdLmluZGV4T2YoZS5rZXlDb2RlKSxcXG4gICAgICAgIG5hdkluZGV4ID0gTnVtYmVyKGdldEF0dHIoY3VyRWxlbWVudCwgJ2RhdGEtbmF2JykpO1xcblxcbiAgICBpZiAoa2V5SW5kZXggPj0gMCkge1xcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gMCkge1xcbiAgICAgICAgaWYgKG5hdkluZGV4ID4gMCkge1xcbiAgICAgICAgICBzZXRGb2N1cyhuYXZJdGVtc1tuYXZJbmRleCAtIDFdKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGtleUluZGV4ID09PSAxKSB7XFxuICAgICAgICBpZiAobmF2SW5kZXggPCBwYWdlcyAtIDEpIHtcXG4gICAgICAgICAgc2V0Rm9jdXMobmF2SXRlbXNbbmF2SW5kZXggKyAxXSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5hdkNsaWNrZWQgPSBuYXZJbmRleDtcXG4gICAgICAgIGdvVG8obmF2SW5kZXgsIGUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0RXZlbnQoZSkge1xcbiAgICBlID0gZSB8fCB3aW4uZXZlbnQ7XFxuICAgIHJldHVybiBpc1RvdWNoRXZlbnQoZSkgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFRhcmdldChlKSB7XFxuICAgIHJldHVybiBlLnRhcmdldCB8fCB3aW4uZXZlbnQuc3JjRWxlbWVudDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzVG91Y2hFdmVudChlKSB7XFxuICAgIHJldHVybiBlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcHJldmVudERlZmF1bHRCZWhhdmlvcihlKSB7XFxuICAgIGUucHJldmVudERlZmF1bHQgPyBlLnByZXZlbnREZWZhdWx0KCkgOiBlLnJldHVyblZhbHVlID0gZmFsc2U7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRNb3ZlRGlyZWN0aW9uRXhwZWN0ZWQoKSB7XFxuICAgIHJldHVybiBnZXRUb3VjaERpcmVjdGlvbih0b0RlZ3JlZShsYXN0UG9zaXRpb24ueSAtIGluaXRQb3NpdGlvbi55LCBsYXN0UG9zaXRpb24ueCAtIGluaXRQb3NpdGlvbi54KSwgc3dpcGVBbmdsZSkgPT09IG9wdGlvbnMuYXhpcztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uUGFuU3RhcnQoZSkge1xcbiAgICBpZiAocnVubmluZykge1xcbiAgICAgIGlmIChwcmV2ZW50QWN0aW9uV2hlblJ1bm5pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChhdXRvcGxheSAmJiBhbmltYXRpbmcpIHtcXG4gICAgICBzdG9wQXV0b3BsYXlUaW1lcigpO1xcbiAgICB9XFxuXFxuICAgIHBhblN0YXJ0ID0gdHJ1ZTtcXG5cXG4gICAgaWYgKHJhZkluZGV4KSB7XFxuICAgICAgY2FmKHJhZkluZGV4KTtcXG4gICAgICByYWZJbmRleCA9IG51bGw7XFxuICAgIH1cXG5cXG4gICAgdmFyICQgPSBnZXRFdmVudChlKTtcXG4gICAgZXZlbnRzLmVtaXQoaXNUb3VjaEV2ZW50KGUpID8gJ3RvdWNoU3RhcnQnIDogJ2RyYWdTdGFydCcsIGluZm8oZSkpO1xcblxcbiAgICBpZiAoIWlzVG91Y2hFdmVudChlKSAmJiBbJ2ltZycsICdhJ10uaW5kZXhPZihnZXRMb3dlckNhc2VOb2RlTmFtZShnZXRUYXJnZXQoZSkpKSA+PSAwKSB7XFxuICAgICAgcHJldmVudERlZmF1bHRCZWhhdmlvcihlKTtcXG4gICAgfVxcblxcbiAgICBsYXN0UG9zaXRpb24ueCA9IGluaXRQb3NpdGlvbi54ID0gJC5jbGllbnRYO1xcbiAgICBsYXN0UG9zaXRpb24ueSA9IGluaXRQb3NpdGlvbi55ID0gJC5jbGllbnRZO1xcblxcbiAgICBpZiAoY2Fyb3VzZWwpIHtcXG4gICAgICB0cmFuc2xhdGVJbml0ID0gcGFyc2VGbG9hdChjb250YWluZXIuc3R5bGVbdHJhbnNmb3JtQXR0cl0ucmVwbGFjZSh0cmFuc2Zvcm1QcmVmaXgsICcnKSk7XFxuICAgICAgcmVzZXREdXJhdGlvbihjb250YWluZXIsICcwcycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvblBhbk1vdmUoZSkge1xcbiAgICBpZiAocGFuU3RhcnQpIHtcXG4gICAgICB2YXIgJCA9IGdldEV2ZW50KGUpO1xcbiAgICAgIGxhc3RQb3NpdGlvbi54ID0gJC5jbGllbnRYO1xcbiAgICAgIGxhc3RQb3NpdGlvbi55ID0gJC5jbGllbnRZO1xcblxcbiAgICAgIGlmIChjYXJvdXNlbCkge1xcbiAgICAgICAgaWYgKCFyYWZJbmRleCkge1xcbiAgICAgICAgICByYWZJbmRleCA9IHJhZihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcGFuVXBkYXRlKGUpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKG1vdmVEaXJlY3Rpb25FeHBlY3RlZCA9PT0gJz8nKSB7XFxuICAgICAgICAgIG1vdmVEaXJlY3Rpb25FeHBlY3RlZCA9IGdldE1vdmVEaXJlY3Rpb25FeHBlY3RlZCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG1vdmVEaXJlY3Rpb25FeHBlY3RlZCkge1xcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCh0eXBlb2YgZS5jYW5jZWxhYmxlICE9PSAnYm9vbGVhbicgfHwgZS5jYW5jZWxhYmxlKSAmJiBwcmV2ZW50U2Nyb2xsKSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwYW5VcGRhdGUoZSkge1xcbiAgICBpZiAoIW1vdmVEaXJlY3Rpb25FeHBlY3RlZCkge1xcbiAgICAgIHBhblN0YXJ0ID0gZmFsc2U7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNhZihyYWZJbmRleCk7XFxuXFxuICAgIGlmIChwYW5TdGFydCkge1xcbiAgICAgIHJhZkluZGV4ID0gcmFmKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHBhblVwZGF0ZShlKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBpZiAobW92ZURpcmVjdGlvbkV4cGVjdGVkID09PSAnPycpIHtcXG4gICAgICBtb3ZlRGlyZWN0aW9uRXhwZWN0ZWQgPSBnZXRNb3ZlRGlyZWN0aW9uRXhwZWN0ZWQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAobW92ZURpcmVjdGlvbkV4cGVjdGVkKSB7XFxuICAgICAgaWYgKCFwcmV2ZW50U2Nyb2xsICYmIGlzVG91Y2hFdmVudChlKSkge1xcbiAgICAgICAgcHJldmVudFNjcm9sbCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBpZiAoZS50eXBlKSB7XFxuICAgICAgICAgIGV2ZW50cy5lbWl0KGlzVG91Y2hFdmVudChlKSA/ICd0b3VjaE1vdmUnIDogJ2RyYWdNb3ZlJywgaW5mbyhlKSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxcblxcbiAgICAgIHZhciB4ID0gdHJhbnNsYXRlSW5pdCxcXG4gICAgICAgICAgZGlzdCA9IGdldERpc3QobGFzdFBvc2l0aW9uLCBpbml0UG9zaXRpb24pO1xcblxcbiAgICAgIGlmICghaG9yaXpvbnRhbCB8fCBmaXhlZFdpZHRoIHx8IGF1dG9XaWR0aCkge1xcbiAgICAgICAgeCArPSBkaXN0O1xcbiAgICAgICAgeCArPSAncHgnO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcGVyY2VudGFnZVggPSBUUkFOU0ZPUk0gPyBkaXN0ICogaXRlbXMgKiAxMDAgLyAoKHZpZXdwb3J0ICsgZ3V0dGVyKSAqIHNsaWRlQ291bnROZXcpIDogZGlzdCAqIDEwMCAvICh2aWV3cG9ydCArIGd1dHRlcik7XFxuICAgICAgICB4ICs9IHBlcmNlbnRhZ2VYO1xcbiAgICAgICAgeCArPSAnJSc7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnRhaW5lci5zdHlsZVt0cmFuc2Zvcm1BdHRyXSA9IHRyYW5zZm9ybVByZWZpeCArIHggKyB0cmFuc2Zvcm1Qb3N0Zml4O1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvblBhbkVuZChlKSB7XFxuICAgIGlmIChwYW5TdGFydCkge1xcbiAgICAgIGlmIChyYWZJbmRleCkge1xcbiAgICAgICAgY2FmKHJhZkluZGV4KTtcXG4gICAgICAgIHJhZkluZGV4ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNhcm91c2VsKSB7XFxuICAgICAgICByZXNldER1cmF0aW9uKGNvbnRhaW5lciwgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYW5TdGFydCA9IGZhbHNlO1xcbiAgICAgIHZhciAkID0gZ2V0RXZlbnQoZSk7XFxuICAgICAgbGFzdFBvc2l0aW9uLnggPSAkLmNsaWVudFg7XFxuICAgICAgbGFzdFBvc2l0aW9uLnkgPSAkLmNsaWVudFk7XFxuICAgICAgdmFyIGRpc3QgPSBnZXREaXN0KGxhc3RQb3NpdGlvbiwgaW5pdFBvc2l0aW9uKTtcXG5cXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdCkpIHtcXG4gICAgICAgIC8vIGRyYWcgdnMgY2xpY2tcXG4gICAgICAgIGlmICghaXNUb3VjaEV2ZW50KGUpKSB7XFxuICAgICAgICAgIC8vIHByZXZlbnQgXFxcImNsaWNrXFxcIlxcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGUpO1xcbiAgICAgICAgICBhZGRFdmVudHModGFyZ2V0LCB7XFxuICAgICAgICAgICAgJ2NsaWNrJzogZnVuY3Rpb24gcHJldmVudENsaWNrKGUpIHtcXG4gICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0QmVoYXZpb3IoZSk7XFxuICAgICAgICAgICAgICByZW1vdmVFdmVudHModGFyZ2V0LCB7XFxuICAgICAgICAgICAgICAgICdjbGljayc6IHByZXZlbnRDbGlja1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjYXJvdXNlbCkge1xcbiAgICAgICAgICByYWZJbmRleCA9IHJhZihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGhvcml6b250YWwgJiYgIWF1dG9XaWR0aCkge1xcbiAgICAgICAgICAgICAgdmFyIGluZGV4TW92ZWQgPSAtZGlzdCAqIGl0ZW1zIC8gKHZpZXdwb3J0ICsgZ3V0dGVyKTtcXG4gICAgICAgICAgICAgIGluZGV4TW92ZWQgPSBkaXN0ID4gMCA/IE1hdGguZmxvb3IoaW5kZXhNb3ZlZCkgOiBNYXRoLmNlaWwoaW5kZXhNb3ZlZCk7XFxuICAgICAgICAgICAgICBpbmRleCArPSBpbmRleE1vdmVkO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB2YXIgbW92ZWQgPSAtKHRyYW5zbGF0ZUluaXQgKyBkaXN0KTtcXG5cXG4gICAgICAgICAgICAgIGlmIChtb3ZlZCA8PSAwKSB7XFxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXhNaW47XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vdmVkID49IHNsaWRlUG9zaXRpb25zW3NsaWRlQ291bnROZXcgLSAxXSkge1xcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4TWF4O1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xcblxcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNsaWRlQ291bnROZXcgJiYgbW92ZWQgPj0gc2xpZGVQb3NpdGlvbnNbaV0pIHtcXG4gICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkID4gc2xpZGVQb3NpdGlvbnNbaV0gJiYgZGlzdCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIGkrKztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZW5kZXIoZSwgZGlzdCk7XFxuICAgICAgICAgICAgZXZlbnRzLmVtaXQoaXNUb3VjaEV2ZW50KGUpID8gJ3RvdWNoRW5kJyA6ICdkcmFnRW5kJywgaW5mbyhlKSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKG1vdmVEaXJlY3Rpb25FeHBlY3RlZCkge1xcbiAgICAgICAgICAgIG9uQ29udHJvbHNDbGljayhlLCBkaXN0ID4gMCA/IC0xIDogMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gLy8gcmVzZXRcXG5cXG5cXG4gICAgaWYgKG9wdGlvbnMucHJldmVudFNjcm9sbE9uVG91Y2ggPT09ICdhdXRvJykge1xcbiAgICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3dpcGVBbmdsZSkge1xcbiAgICAgIG1vdmVEaXJlY3Rpb25FeHBlY3RlZCA9ICc/JztcXG4gICAgfVxcblxcbiAgICBpZiAoYXV0b3BsYXkgJiYgIWFuaW1hdGluZykge1xcbiAgICAgIHNldEF1dG9wbGF5VGltZXIoKTtcXG4gICAgfVxcbiAgfSAvLyA9PT0gUkVTSVpFIEZVTkNUSU9OUyA9PT0gLy9cXG4gIC8vIChzbGlkZVBvc2l0aW9ucywgaW5kZXgsIGl0ZW1zKSA9PiB2ZXJ0aWNhbF9jb25lbnRXcmFwcGVyLmhlaWdodFxcblxcblxcbiAgZnVuY3Rpb24gdXBkYXRlQ29udGVudFdyYXBwZXJIZWlnaHQoKSB7XFxuICAgIHZhciB3cCA9IG1pZGRsZVdyYXBwZXIgPyBtaWRkbGVXcmFwcGVyIDogaW5uZXJXcmFwcGVyO1xcbiAgICB3cC5zdHlsZS5oZWlnaHQgPSBzbGlkZVBvc2l0aW9uc1tpbmRleCArIGl0ZW1zXSAtIHNsaWRlUG9zaXRpb25zW2luZGV4XSArICdweCc7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRQYWdlcygpIHtcXG4gICAgdmFyIHJvdWdoID0gZml4ZWRXaWR0aCA/IChmaXhlZFdpZHRoICsgZ3V0dGVyKSAqIHNsaWRlQ291bnQgLyB2aWV3cG9ydCA6IHNsaWRlQ291bnQgLyBpdGVtcztcXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGguY2VpbChyb3VnaCksIHNsaWRlQ291bnQpO1xcbiAgfVxcbiAgLypcXG4gICAqIDEuIHVwZGF0ZSB2aXNpYmxlIG5hdiBpdGVtcyBsaXN0XFxuICAgKiAyLiBhZGQgXFxcImhpZGRlblxcXCIgYXR0cmlidXRlcyB0byBwcmV2aW91cyB2aXNpYmxlIG5hdiBpdGVtc1xcbiAgICogMy4gcmVtb3ZlIFxcXCJoaWRkZW5cXFwiIGF0dHJ1YnV0ZXMgdG8gbmV3IHZpc2libGUgbmF2IGl0ZW1zXFxuICAgKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZU5hdlZpc2liaWxpdHkoKSB7XFxuICAgIGlmICghbmF2IHx8IG5hdkFzVGh1bWJuYWlscykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAocGFnZXMgIT09IHBhZ2VzQ2FjaGVkKSB7XFxuICAgICAgdmFyIG1pbiA9IHBhZ2VzQ2FjaGVkLFxcbiAgICAgICAgICBtYXggPSBwYWdlcyxcXG4gICAgICAgICAgZm4gPSBzaG93RWxlbWVudDtcXG5cXG4gICAgICBpZiAocGFnZXNDYWNoZWQgPiBwYWdlcykge1xcbiAgICAgICAgbWluID0gcGFnZXM7XFxuICAgICAgICBtYXggPSBwYWdlc0NhY2hlZDtcXG4gICAgICAgIGZuID0gaGlkZUVsZW1lbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcXG4gICAgICAgIGZuKG5hdkl0ZW1zW21pbl0pO1xcbiAgICAgICAgbWluKys7XFxuICAgICAgfSAvLyBjYWNoZSBwYWdlc1xcblxcblxcbiAgICAgIHBhZ2VzQ2FjaGVkID0gcGFnZXM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGluZm8oZSkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxcbiAgICAgIHNsaWRlSXRlbXM6IHNsaWRlSXRlbXMsXFxuICAgICAgbmF2Q29udGFpbmVyOiBuYXZDb250YWluZXIsXFxuICAgICAgbmF2SXRlbXM6IG5hdkl0ZW1zLFxcbiAgICAgIGNvbnRyb2xzQ29udGFpbmVyOiBjb250cm9sc0NvbnRhaW5lcixcXG4gICAgICBoYXNDb250cm9sczogaGFzQ29udHJvbHMsXFxuICAgICAgcHJldkJ1dHRvbjogcHJldkJ1dHRvbixcXG4gICAgICBuZXh0QnV0dG9uOiBuZXh0QnV0dG9uLFxcbiAgICAgIGl0ZW1zOiBpdGVtcyxcXG4gICAgICBzbGlkZUJ5OiBzbGlkZUJ5LFxcbiAgICAgIGNsb25lQ291bnQ6IGNsb25lQ291bnQsXFxuICAgICAgc2xpZGVDb3VudDogc2xpZGVDb3VudCxcXG4gICAgICBzbGlkZUNvdW50TmV3OiBzbGlkZUNvdW50TmV3LFxcbiAgICAgIGluZGV4OiBpbmRleCxcXG4gICAgICBpbmRleENhY2hlZDogaW5kZXhDYWNoZWQsXFxuICAgICAgZGlzcGxheUluZGV4OiBnZXRDdXJyZW50U2xpZGUoKSxcXG4gICAgICBuYXZDdXJyZW50SW5kZXg6IG5hdkN1cnJlbnRJbmRleCxcXG4gICAgICBuYXZDdXJyZW50SW5kZXhDYWNoZWQ6IG5hdkN1cnJlbnRJbmRleENhY2hlZCxcXG4gICAgICBwYWdlczogcGFnZXMsXFxuICAgICAgcGFnZXNDYWNoZWQ6IHBhZ2VzQ2FjaGVkLFxcbiAgICAgIHNoZWV0OiBzaGVldCxcXG4gICAgICBpc09uOiBpc09uLFxcbiAgICAgIGV2ZW50OiBlIHx8IHt9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB2ZXJzaW9uOiAnMi45LjQnLFxcbiAgICBnZXRJbmZvOiBpbmZvLFxcbiAgICBldmVudHM6IGV2ZW50cyxcXG4gICAgZ29UbzogZ29UbyxcXG4gICAgcGxheTogcGxheSxcXG4gICAgcGF1c2U6IHBhdXNlLFxcbiAgICBpc09uOiBpc09uLFxcbiAgICB1cGRhdGVTbGlkZXJIZWlnaHQ6IHVwZGF0ZUlubmVyV3JhcHBlckhlaWdodCxcXG4gICAgcmVmcmVzaDogaW5pdFNsaWRlclRyYW5zZm9ybSxcXG4gICAgZGVzdHJveTogZGVzdHJveSxcXG4gICAgcmVidWlsZDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB0bnMoZXh0ZW5kKG9wdGlvbnMsIG9wdGlvbnNFbGVtZW50cykpO1xcbiAgICB9XFxuICB9O1xcbn07XFxuXFxuZXhwb3J0cy50bnMgPSB0bnM7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rpbnktc2xpZGVyL2Rpc3QvdGlueS1zbGlkZXIuanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1wiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogX19leHRlbmRzLCBfX2Fzc2lnbiwgX19yZXN0LCBfX2RlY29yYXRlLCBfX3BhcmFtLCBfX21ldGFkYXRhLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yLCBfX2NyZWF0ZUJpbmRpbmcsIF9fZXhwb3J0U3RhciwgX192YWx1ZXMsIF9fcmVhZCwgX19zcHJlYWQsIF9fc3ByZWFkQXJyYXlzLCBfX2F3YWl0LCBfX2FzeW5jR2VuZXJhdG9yLCBfX2FzeW5jRGVsZWdhdG9yLCBfX2FzeW5jVmFsdWVzLCBfX21ha2VUZW1wbGF0ZU9iamVjdCwgX19pbXBvcnRTdGFyLCBfX2ltcG9ydERlZmF1bHQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzVHNsaWJUc2xpYkVzNkpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2V4dGVuZHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZXh0ZW5kczsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hc3NpZ25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXNzaWduOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX3Jlc3RcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcmVzdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19kZWNvcmF0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19kZWNvcmF0ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19wYXJhbVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19wYXJhbTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19tZXRhZGF0YVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19tZXRhZGF0YTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hd2FpdGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2F3YWl0ZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fZ2VuZXJhdG9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2dlbmVyYXRvcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19jcmVhdGVCaW5kaW5nXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NyZWF0ZUJpbmRpbmc7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fZXhwb3J0U3RhclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19leHBvcnRTdGFyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX3ZhbHVlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX192YWx1ZXM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fcmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19yZWFkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX3NwcmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fc3ByZWFkQXJyYXlzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3NwcmVhZEFycmF5czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hd2FpdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hd2FpdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hc3luY0dlbmVyYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY0dlbmVyYXRvcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hc3luY0RlbGVnYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY0RlbGVnYXRvcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19hc3luY1ZhbHVlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY1ZhbHVlczsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19tYWtlVGVtcGxhdGVPYmplY3RcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fbWFrZVRlbXBsYXRlT2JqZWN0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJfX2ltcG9ydFN0YXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9faW1wb3J0U3RhcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19pbXBvcnREZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7IH0pO1xcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxcclxcblxcclxcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxcclxcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cXHJcXG5cXHJcXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxcclxcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxcclxcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcXHJcXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cXHJcXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxcclxcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcXHJcXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXFxyXFxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cXHJcXG5cXHJcXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcXHJcXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcclxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcclxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XFxyXFxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcclxcbn07XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcXHJcXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXHJcXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XFxyXFxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXHJcXG59XFxyXFxuXFxyXFxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XFxyXFxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xcclxcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gdDtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcXHJcXG4gICAgdmFyIHQgPSB7fTtcXHJcXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXFxyXFxuICAgICAgICB0W3BdID0gc1twXTtcXHJcXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXFxcImZ1bmN0aW9uXFxcIilcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXFxyXFxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xcclxcbiAgICAgICAgfVxcclxcbiAgICByZXR1cm4gdDtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xcclxcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xcclxcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcXFwiZnVuY3Rpb25cXFwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XFxyXFxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XFxyXFxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XFxyXFxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xcclxcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cXHJcXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxyXFxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XFxyXFxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcXFwidGhyb3dcXFwiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XFxyXFxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxcclxcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xcclxcbiAgICB9KTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xcclxcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xcclxcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXFxcInRocm93XFxcIjogdmVyYigxKSwgXFxcInJldHVyblxcXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcXHJcXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XFxyXFxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcXHJcXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXFxcIik7XFxyXFxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcXHJcXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1xcXCJyZXR1cm5cXFwiXSA6IG9wWzBdID8geVtcXFwidGhyb3dcXFwiXSB8fCAoKHQgPSB5W1xcXCJyZXR1cm5cXFwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XFxyXFxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xcclxcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcXHJcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cXHJcXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xcclxcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcclxcbiAgICBvW2syXSA9IG1ba107XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XFxyXFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcXHJcXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XFxyXFxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xcclxcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFxcXCJudW1iZXJcXFwiKSByZXR1cm4ge1xcclxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcXFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cXFwiIDogXFxcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcXHJcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXHJcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXHJcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXHJcXG4gICAgfVxcclxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXHJcXG4gICAgZmluYWxseSB7XFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBhcjtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XFxyXFxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxcclxcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xcclxcbiAgICByZXR1cm4gYXI7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xcclxcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcXHJcXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxcclxcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXFxyXFxuICAgICAgICAgICAgcltrXSA9IGFbal07XFxyXFxuICAgIHJldHVybiByO1xcclxcbn07XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XFxyXFxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xcclxcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXHJcXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcXHJcXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcXFwibmV4dFxcXCIpLCB2ZXJiKFxcXCJ0aHJvd1xcXCIpLCB2ZXJiKFxcXCJyZXR1cm5cXFwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xcclxcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cXHJcXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxcclxcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cXHJcXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH1cXHJcXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcXFwidGhyb3dcXFwiLCB2YWx1ZSk7IH1cXHJcXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcXHJcXG4gICAgdmFyIGksIHA7XFxyXFxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXFxcIm5leHRcXFwiKSwgdmVyYihcXFwidGhyb3dcXFwiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcXFwicmV0dXJuXFxcIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XFxyXFxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFxcXCJyZXR1cm5cXFwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xcclxcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXHJcXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcXHJcXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcXFwibmV4dFxcXCIpLCB2ZXJiKFxcXCJ0aHJvd1xcXCIpLCB2ZXJiKFxcXCJyZXR1cm5cXFwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcXHJcXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxcclxcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XFxyXFxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXFxcInJhd1xcXCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxcclxcbiAgICByZXR1cm4gY29va2VkO1xcclxcbn07XFxyXFxuXFxyXFxuZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xcclxcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xcclxcbiAgICB2YXIgcmVzdWx0ID0ge307XFxyXFxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XFxyXFxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xcclxcbiAgICByZXR1cm4gcmVzdWx0O1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XFxyXFxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcXHJcXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcXHJcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcXFwiKTtcXHJcXG4gICAgfVxcclxcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xcclxcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xcclxcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVxcXCIpO1xcclxcbiAgICB9XFxyXFxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XFxyXFxuICAgIHJldHVybiB2YWx1ZTtcXHJcXG59XFxyXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzV2VicGFja0J1aWxkaW5HbG9iYWxKcyhtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBldmFsKFwidmFyIGc7XFxuXFxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcXG5nID0gKGZ1bmN0aW9uKCkge1xcblxcdHJldHVybiB0aGlzO1xcbn0pKCk7XFxuXFxudHJ5IHtcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcXG5cXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG59IGNhdGNoIChlKSB7XFxuXFx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcXG5cXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXFxcIm9iamVjdFxcXCIpIGcgPSB3aW5kb3c7XFxufVxcblxcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGc7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz9cIik7XG5cbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXCIuL3NyYy9zY3JpcHRzL2dlbmVyYWwuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL3NyYy9zY3JpcHRzL2dlbmVyYWwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBHZW5lcmFsQ2xhc3MgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gc3JjU2NyaXB0c0dlbmVyYWxKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiR2VuZXJhbENsYXNzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBHZW5lcmFsQ2xhc3M7IH0pO1xcblxcclxcblxcclxcbmNsYXNzIEdlbmVyYWxDbGFzcyB7XFxyXFxuXFxyXFxuICAgIFNldElzTW9iaWxlKCkge1xcclxcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG5cXHJcXG4gICAgYXN5bmMgUmVxdWVzdERhdGEoeyBmb3JtLCBzZXJ2aWNlIH0pIHtcXHJcXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xcclxcbiAgICAgICAgY29uc3QgeyBHZXRMYW5ndWFnZSB9ID0gbmV3IEdlbmVyYWxDbGFzcygpO1xcclxcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBHZXRMYW5ndWFnZSgpO1xcclxcbiAgICAgICAgY29uc3QgZGF0YVRvU2VuZCA9IHtsYW5ndWFnZX07XFxyXFxuICAgICAgICBjb25zdCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcygnZGV2c2l0ZScpIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdsb2NhbCcpID8gJ2h0dHBzOi8vc2VydmljZXMuc3RnLm11YmFyby5teC9zZXJ2aWNlcy9tdWJhcm8vJyA6ICdodHRwczovL3NlcnZpY2VzLm11YmFyby5teC9zZXJ2aWNlcy9tdWJhcm8vJztcXHJcXG5cXHJcXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xcclxcbiAgICAgICAgICAgIGRhdGFUb1NlbmRbbmFtZV0gPSB2YWx1ZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGZvcm1Cb2R5ID0gT2JqZWN0LmtleXMoZGF0YVRvU2VuZClcXHJcXG4gICAgICAgICAgICAubWFwKFxcclxcbiAgICAgICAgICAgICAgICAoa2V5KSA9PlxcclxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVRvU2VuZFtrZXldKVxcclxcbiAgICAgICAgICAgIClcXHJcXG4gICAgICAgICAgICAuam9pbignJicpLFxcclxcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dXJsfSR7c2VydmljZX0ucGhwYCwge1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCcsXFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcclxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtQm9keSxcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZ28gc2FsaVxceEYzIG1hbC4gVmVyaWZpY2EgbG9zIGRhdG9zIHkgdnVlbHZlIGEgaW50ZW50YXJsby4nKTtcXHJcXG4gICAgICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyb3IpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcXHJcXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBTZXRDb29raWUoKSB7XFxyXFxuICAgICAgICBjb25zdCBkaXNjbGFpbWVyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Rpc2NsYWltZXInKTtcXHJcXG4gICAgICAgIGNvbnN0IHsgR2V0TGFuZ3VhZ2UgfSA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gR2V0TGFuZ3VhZ2UoKTtcXHJcXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBsYW5ndWFnZSA9PT0gJ2VuJyA/IGBZb3UgYXJlIGJyb3dzaW5nIGEgd2Vic2l0ZSB3aXRoIGl0XFx1MjAxOXMgb3duIGFuZCB0aGlyZC1wYXJ0eSBjb29raWVzIHRvIG9mZmVyIHlvdSBhbiBvcHRpbWFsIGV4cGVyaWVuY2UuIFRvIGNvbnRpbnVlIGJyb3dzaW5nLCBjbGljayBBY2NlcHQuIElmIHlvdSB3YW50IG1vcmUgaW5mb3JtYXRpb24gZW50ZXIgb3VyIFByaXZhY3kgUG9saWN5YDogYEVzdFxceEUxcyBuYXZlZ2FuZG8gZW4gdW4gc2l0aW8gY29uIGNvb2tpZXMgcHJvcGlhcyB5IGRlIHRlcmNlcm9zLCBwYXJhIG9mcmVjZXJ0ZSB1bmEgZXhwZXJpZW5jaWEgXFx4RjNwdGltYS4gPGJyLz5QYXJhIGNvbnRpbnVhciBuYXZlZ2FuZG8sIGRhbGUgQWNlcHRhci4gPGJyLz5TaSBkZXNlYXMgbVxceEUxcyBpbmZvcm1hY2lcXHhGM24gZW50cmEgYSBudWVzdHJhIHBvbFxceEVEdGljYSBkZSBwcml2YWNpZGFkLiBgO1xcclxcbiAgICAgICAgY29uc3QgZGVueVRleHQgPSBsYW5ndWFnZSA9PT0gJ2VuJyA/ICdEZW55JyA6ICdObyBhY2VwdG8nO1xcclxcbiAgICAgICAgY29uc3QgYWNjZXB0VGV4dCA9IGxhbmd1YWdlID09PSAnZW4nID8gJ0FjY2VwdCcgOiAnQWNlcHRvJztcXHJcXG5cXHJcXG4gICAgICAgIGlmICghZGlzY2xhaW1lcikge1xcclxcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZV93cnAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXHJcXG4gICAgICAgICAgICAgICAgY29va2llX21hcmt1cCA9IGBcXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29va2llcy1jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29va2llcy13cnAgdGV4dC1jZW50ZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPiR7bWVzc2FnZX08L3A+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGNvb2tpZXMtYnRuLXdycCBteC1hdXRvXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdHlwZT1cXFwieWVzXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1ibHVlIGJ0bi1jb29raWVcXFwiPiR7YWNjZXB0VGV4dH08L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdHlwZT1cXFwibm9cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWJsdWUgYnRuLWNvb2tpZSBidG5cXFwiPiR7ZGVueVRleHR9PC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+YDtcXHJcXG4gICAgICAgICAgICBjb29raWVfd3JwLmNsYXNzTGlzdC5hZGQoJ2Nvb2tpZXMtZGlzY2xhaW0nKTtcXHJcXG4gICAgICAgICAgICBjb29raWVfd3JwLmlubmVySFRNTCA9IGNvb2tpZV9tYXJrdXA7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb29raWVfd3JwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBjb25zdCBjb29raWVfYnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJ0bi1jb29raWUnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoY29va2llX2J0biwgKGMpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgYy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGd0ID0gZS5jdXJyZW50VGFyZ2V0LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0Z3QuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAneWVzJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdkaXNjbGFpbWVyJywgdHJ1ZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29va2llcy1kaXNjbGFpbScpLnJlbW92ZSgpO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBHZXRRdWVyeVN0cmluZyhuYW1lLCB1cmwpIHtcXHJcXG4gICAgICAgIGlmICghdXJsKSB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcXHJcXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFxcW1xcXFxdXS9nLCAnXFxcXFxcXFwkJicpO1xcclxcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnWz8mXScgKyBuYW1lICsgJyg9KFteJiNdKil8JnwjfCQpJyksXFxyXFxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcXHJcXG4gICAgICAgIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XFxyXFxuICAgICAgICBpZiAoIXJlc3VsdHNbMl0pIHJldHVybiAnJztcXHJcXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1syXS5yZXBsYWNlKC9cXFxcKy9nLCAnICcpKTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBEZWNvZGUoc3RyKSB7XFxyXFxuXFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4RTEnLCAnYScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEMxJywgJ0EnKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhFOScsICdlJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4QzknLCAnRScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEVEJywgJ2knKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhDRCcsICdJJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4RjMnLCAnbycpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEQzJywgJ08nKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhGQScsICd1Jyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4REEnLCAnVScpO1xcclxcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJ1xceEYxJywgJ24nKTtcXHJcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCdcXHhEMScsICdOJyk7XFxyXFxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnXFx4QUUnLCAnJyk7XFxyXFxuXFxyXFxuICAgICAgICByZXR1cm4gc3RyO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGFzeW5jIEdldERhdGEocGF0aCkge1xcclxcbiAgICAgICAgY29uc3QgU0VSVklDRVNfVVJMID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoJ2RldnNpdGUnKSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcygnbG9jYWwnKSA/ICcnIDogJyc7XFxyXFxuICAgICAgICBjb25zdCB1cmwgPSBTRVJWSUNFU19VUkwgKyAnLycgKyBwYXRoLFxcclxcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKSxcXHJcXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xcclxcblxcclxcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XFxyXFxuICAgICAgICByZXR1cm4gZGF0YTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBDaGFyc0FsbG93ZWQodmFsdWUpIHtcXHJcXG4gICAgICAgIGNvbnN0IGFsbG93ZWRDaGFycyA9IG5ldyBSZWdFeHAoL15bYS16QS1aXFx4RjFcXHhEMVxcXFxzXSskLylcXHJcXG4gICAgICAgIHJldHVybiBhbGxvd2VkQ2hhcnMudGVzdCh2YWx1ZSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgQ2xlYW5Gb3JtSW5mbygpIHtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZXF1aXJlZC1maWVsZCcpO1xcclxcbiAgICAgICAgY29uc3Qgc2VsZiA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IHsgR2V0TGFuZ3VhZ2UsIFJlbW92ZUFsbEVycm9ycyB9ID0gbmV3IEdlbmVyYWxDbGFzcygpO1xcclxcblxcclxcbiAgICAgICAgY29uc3QgbGFuZyA9IEdldExhbmd1YWdlKCk7XFxyXFxuXFxyXFxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLCAoZSwgaW5kZXgpID0+IHtcXHJcXG5cXHJcXG4gICAgICAgICAgICBsZXQgdGd0ID0gZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB0Z3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCRlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIFJlbW92ZUFsbEVycm9ycygpO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgIHRndC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsICgkZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0Z3QudmFsdWU7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0Z3QuZ2V0QXR0cmlidXRlKCduYW1lJyk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG1heGxlbmd0aCA9IDEwO1xcclxcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Bob25lJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiBtYXhsZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0Z3QudmFsdWUgPSB2YWwuc3Vic3RyKDAsIG1heGxlbmd0aCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB0Z3QuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoJGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgUmVtb3ZlQWxsRXJyb3JzKCk7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGd0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgUmVtb3ZlQWxsRXJyb3JzKCk7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0Z3QuZ2V0QXR0cmlidXRlKCduYW1lJyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xcclxcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JfbWVzc2FnZSA9IG5hbWUgPT09ICdwaG9uZScgPyBsYW5nID09PSAnZXMnID8gJ1NvbG8gc2UgYWRtaXRlbiBuXFx4RkFtZXJvcycgOiAnT25seSBudW1iZXJzJyA6IG5hbWUgPT09ICdlbWFpbCcgPyBsYW5nID09PSAnZXMnID8gJ0luZ3Jlc2EgdW4gY29ycmVvIGVsZWN0clxceEYzbmljbyB2XFx4RTFsaWRvJyA6ICdFbWFpbCcgOiBsYW5nID09PSAnZXMnID8gJ1NvbG8gc2UgYWRtaXRlbiBsZXRyYXMnIDogJ09ubHkgbGV0dGVycyc7XFxyXFxuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IG5hbWUgPT09ICdwaG9uZScgPyAvXlswLTldKyQvIDogbmFtZSA9PT0gJ2VtYWlsJyA/IC9bQS1aMC05Ll8lKy1dK0BbQS1aMC05Li1dK1xcXFwuW0EtWl17Miw0fS9naSA6IC9eW0EtWmEtelxceEMxLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHhGRlxcXFxzXSokL1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvL1ZhbGlkYXRlIFRleHRCb3ggdmFsdWUgYWdhaW5zdCB0aGUgUmVnZXguXFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB0Z3QudmFsdWUgPyByZWdleC50ZXN0KHRndC52YWx1ZSkgOiB0cnVlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQgJiYgIW5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZGF0ZScpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwLmlubmVySFRNTCA9IGVycm9yX21lc3NhZ2U7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0Z3QucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIFJlbW92ZUFsbEVycm9ycygpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgIHRndC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsICgkZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBSZW1vdmVBbGxFcnJvcnMoKTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG5cXHJcXG5cXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFJlbW92ZUFsbEVycm9ycygpIHtcXHJcXG4gICAgICAgIC8vIGNvbnN0IHJlbW92ZUVycm9ycyA9ICgpID0+IHtcXHJcXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5lcnJvcicpO1xcclxcblxcclxcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGVycm9ycywgKGUsIGluZGV4KSA9PiB7XFxyXFxuICAgICAgICAgICAgZS5yZW1vdmUoKTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgLy99XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgVmFsaWRhdGVGb3JtKCkge1xcclxcbiAgICAgICAgY29uc3QgbGFiZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxhYmVsJyksXFxyXFxuICAgICAgICAgICAgZXJyb3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmVycm9yJyksXFxyXFxuICAgICAgICAgICAgZW1haWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtZW1haWwnKSxcXHJcXG4gICAgICAgICAgICBwaG9uZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1waG9uZScpLFxcclxcbiAgICAgICAgICAgIGVtYWlsVmFsID0gZW1haWwgPyBlbWFpbC52YWx1ZS5zZWFyY2goL1tBLVowLTkuXyUrLV0rQFtBLVowLTkuLV0rXFxcXC5bQS1aXXsyLDR9L2dpKSA+IC0xIDogbnVsbCxcXHJcXG4gICAgICAgICAgICBwaG9uZVZhbCA9IHBob25lID8gcGhvbmUudmFsdWUuc2VhcmNoKC9cXFxcWzAtOV0vKSA6IG51bGwsXFxyXFxuICAgICAgICAgICAgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlcXVpcmVkLWZpZWxkJyk7XFxyXFxuXFxyXFxuICAgICAgICBjb25zdCB7IEdldExhbmd1YWdlIH0gPSBuZXcgR2VuZXJhbENsYXNzKCk7XFxyXFxuXFxyXFxuICAgICAgICBjb25zdCBsYW5nID0gR2V0TGFuZ3VhZ2UoKTtcXHJcXG5cXHJcXG4gICAgICAgIGxldCByZXF1aXJlZCA9IGZpZWxkcy5sZW5ndGgsXFxyXFxuICAgICAgICAgICAgZmllbGRFcnJvciA9IFtdLFxcclxcbiAgICAgICAgICAgIGZpbGxlZCA9IFtdLFxcclxcbiAgICAgICAgICAgIGVtbCA9IDAsXFxyXFxuICAgICAgICAgICAgcGhuID0gMDtcXHJcXG5cXHJcXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChmaWVsZHMsIChmLCBpbmRleCkgPT4ge1xcclxcblxcclxcbiAgICAgICAgICAgIGxldCB0Z3QgPSBmLFxcclxcbiAgICAgICAgICAgICAgICB2YWwsXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlO1xcclxcblxcclxcbiAgICAgICAgICAgIHZhbCA9IGYudmFsdWU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnLTEnKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnN0IG1zaiA9IGxhYmVsc1tpbmRleF0uaW5uZXJIVE1MLnJlcGxhY2UoJzonLCAnJykudG9Mb3dlckNhc2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbXNqLm5vcm1hbGl6ZSgnTkZEJykucmVwbGFjZSgvKFtcXFxcdTAzMDAtXFxcXHUwMzZmXXxbXjAtOWEtekEtWl0pL2csICcnKS5yZXBsYWNlKC8oW15cXFxcd10rfFxcXFxzKykvZywgJy0nKTtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XFxyXFxuICAgICAgICAgICAgICAgIHAuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcXHJcXG4gICAgICAgICAgICAgICAgcC5jbGFzc0xpc3QuYWRkKGBlcnJvci0ke3BhcnNlZH1gKTtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBsYW5nID09PSAnZXMnID8gYFBvciBmYXZvciwgaW5ncmVzYSBjb3JyZWN0YW1lbnRlICR7bXNqfS5gIDogYEZpbGwgY29ycmVjdGx5ICR7bXNqfS5gO1xcclxcbiAgICAgICAgICAgICAgICBwLmlubmVySFRNTCA9IHRpdGxlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZXJyb3JzLCAoZSwgaW5kZXgpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlKCk7XFxyXFxuICAgICAgICAgICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICB0Z3QucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvci5wdXNoKHRpdGxlKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBmaWxsZWQucHVzaCh0Z3QpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgaWYgKGVtYWlsICYmICFlbWFpbFZhbCkge1xcclxcbiAgICAgICAgICAgIGxldCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xcclxcbiAgICAgICAgICAgIHAuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcXHJcXG4gICAgICAgICAgICBwLmlubmVySFRNTCA9IGxhbmcgPT09ICdlcycgPyAnUG9yIGZhdm9yLCBpbmdyZXNhIGNvcnJlY3RhbWVudGUgdHUgY29ycmVvIGVsZWN0clxceEYzbmljby4nIDogJ1BsZWFzZSwgZmlsbCB5b3VyIGVtYWlsJztcXHJcXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLWNvcnJlb2VsZWN0cm9uaWNvJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLWVtYWlsJykpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1lbWFpbC13cnAnKS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZW1sID0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgZW1sID0gMTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChwaG9uZSAmJiAhcGhvbmVWYWwpIHtcXHJcXG4gICAgICAgICAgICBsZXQgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcXHJcXG4gICAgICAgICAgICBwLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XFxyXFxuICAgICAgICAgICAgcC5pbm5lckhUTUwgPSBsYW5nID09PSAnZXMnID8gJ1BvciBmYXZvciwgaW5ncmVzYSBjb3JyZWN0YW1lbnRlIHR1IHRlbFxceEU5Zm9uby4nIDogJ1BsZWFzZSBmaWxsIHlvdXIgcGhvbmUgY29ycmVjdGx5JztcXHJcXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLXRlbGVmb25vJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVycm9yLXBob25lbnVtYmVyJykpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1waG9uZS13cnAnKS5hcHBlbmRDaGlsZChwKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcGhuID0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgcGhuID0gMTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiByZXF1aXJlZCA9PT0gZmlsbGVkLmxlbmd0aCAmJiBlbWwgPT09IDEgJiYgcGhuID09PSAxO1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIEdldExhbmd1YWdlKCkge1xcclxcbiAgICAgICAgbGV0IGxhbmc7XFxyXFxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoJy9lbi8nKSkge1xcclxcbiAgICAgICAgICAgIGxhbmcgPSAnZW4nO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBsYW5nID0gJ2VzJztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xhbmcnKSkgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhbmcnLCBsYW5nKTtcXHJcXG4gICAgICAgIHJldHVybiBsYW5nO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFNldEFuaW1hdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnN0IGJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJveCcpO1xcclxcbiAgICAgICAgaWYgKGJveGVzKSB7XFxyXFxuICAgICAgICAgIGNvbnN0IHRyaWdnZXJCb3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IC8gNSkgKiA0O1xcclxcbiAgICBcXHJcXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ib3guaW5pdCcpKSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm94LmluaXQnKS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XFxyXFxuICAgIFxcclxcbiAgICAgICAgICBib3hlcy5mb3JFYWNoKChib3gpID0+IHtcXHJcXG4gICAgICAgICAgICBjb25zdCBib3hUb3AgPSBib3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xcclxcbiAgICAgICAgICAgIC8vIEZvciBjaGVja2luZyB3aGVuIHRvIHNob3cgYW5kIGhpZGUgdGhlIGJveFxcclxcbiAgICAgICAgICAgIGlmIChib3hUb3AgPCB0cmlnZ2VyQm90dG9tKSB7XFxyXFxuICAgICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xcclxcbiAgICAgICAgICAgIH0gXFxyXFxuICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBTaG93TW9kYWwoeyBjaGlsZHJlbiwgb25PcGVuLCBvbkFjY2VwdCwgb25DYW5jZWwgfSkge1xcclxcblxcclxcbiAgICAgICAgY29uc3Qgb2wgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb2wtbWFpbicpO1xcclxcbiAgICAgICAgY29uc3Qgc2VsZiA9IG5ldyBHZW5lcmFsQ2xhc3MoKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChvbCkge1xcclxcbiAgICAgICAgICAgIG9sLnJlbW92ZSgpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgbGV0IG9sX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcclxcblxcclxcbiAgICAgICAgb2xfZGl2LmlkID0gJ29sLW1haW4nO1xcclxcblxcclxcbiAgICAgICAgb2xfZGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVxcXCJvbC1tb2RhbC13cmFwcGVyIG9sLW1vZGFsLWNvbnRcXFwiID5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJvbC1tb2RhbC1jb250YWluZXIgb2wtbW9kYWwtY29udFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm9sLW1vZGFsLXBhbmVsLWJveFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICR7Y2hpbGRyZW59XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+YDtcXHJcXG5cXHJcXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob2xfZGl2KTtcXHJcXG5cXHJcXG4gICAgICAgIGNvbnN0IGNhbmNlbF9idG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub2wtY2FuY2VsLWJveCcpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vbC1jbG9zZS1ib3gnKTtcXHJcXG4gICAgICAgIGNvbnN0IGFjY2VwdF9idG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub2wtYWNjZXB0LWJveCcpO1xcclxcblxcclxcbiAgICAgICAgaWYgKG9uT3Blbikge1xcclxcbiAgICAgICAgICAgIG9uT3BlbigpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgY2FuY2VsX2J0biAmJiBjYW5jZWxfYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcXHJcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgICAgaWYgKG9uQ2FuY2VsKSB7XFxyXFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsKCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHNlbGYuQ2xvc2VNb2RhbCgpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICBhY2NlcHRfYnRuICYmIGFjY2VwdF9idG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xcclxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAob25BY2NlcHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgb25BY2NlcHQoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBDbG9zZU1vZGFsKCkge1xcclxcbiAgICAgICAgY29uc3Qgb2xfd3JwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9sLW1vZGFsLXdyYXBwZXInKTtcXHJcXG4gICAgICAgIG9sX3dycC5yZW1vdmUoKTtcXHJcXG4gICAgfVxcclxcblxcclxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9nZW5lcmFsLmpzP1wiKTtcblxuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cIi4vc3JjL3NjcmlwdHMvbWFpbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vc3JjL3NjcmlwdHMvbWFpbi5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cbiAgLyoqKi9cbiAgZnVuY3Rpb24gc3JjU2NyaXB0c01haW5Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZW5lcmFsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dlbmVyYWwgKi8gXFxcIi4vc3JjL3NjcmlwdHMvZ2VuZXJhbC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzbW9vdGhfc2Nyb2xsYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzbW9vdGgtc2Nyb2xsYmFyICovIFxcXCIuL25vZGVfbW9kdWxlcy9zbW9vdGgtc2Nyb2xsYmFyL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHRpbnlfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0aW55LXNsaWRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdGlueS1zbGlkZXIvZGlzdC90aW55LXNsaWRlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB0aW55X3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHRpbnlfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcbmNsYXNzIFNlY3Rpb25DbGFzcyBleHRlbmRzIF9nZW5lcmFsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIkdlbmVyYWxDbGFzc1xcXCJdIHtcXHJcXG4gIGNvbnN0cnVjdG9yKCkge1xcclxcbiAgICBzdXBlcigpO1xcclxcbiAgICB0aGlzLkxhdW5jaFNlY3Rpb24oKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIExhdW5jaFNlY3Rpb24oKSB7XFxyXFxuICAgIGNvbnN0IGdlbmVyYWxDbGFzcyA9IG5ldyBfZ2VuZXJhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJHZW5lcmFsQ2xhc3NcXFwiXSgpO1xcclxcbiAgICBjb25zdCB7IFNldElzTW9iaWxlLCBTZXRDb29raWUsIFNldEFuaW1hdGlvbiwgR2V0TGFuZ3VhZ2UgfSA9IGdlbmVyYWxDbGFzcztcXHJcXG4gICAgY29uc3QgaXNNb2JpbGUgPSBTZXRJc01vYmlsZSgpO1xcclxcbiAgICAvLyBjb25zdCBzZW5kX2Zvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtc2VuZC1ncmFsLWZvcm0nKTtcXHJcXG4gICAgY29uc3QgbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYWluLXNjcm9sbGJhcicpO1xcclxcbiAgICBjb25zdCBoYW1idXJnZXJfYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnanMtaGFtYnVyZ2VyJylbMF07XFxyXFxuICAgIGNvbnN0IGhlYWRlcl9uYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdGlvbi1uYXYnKTtcXHJcXG4gICAgY29uc3QgbWFpbl93cmFwcGVyID0gZG9jdW1lbnQuYm9keTtcXHJcXG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcicpXFxyXFxuICAgIGNvbnN0IG1haW5fY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4tY29udGFpbmVyJyk7XFxyXFxuICAgIGNvbnN0IHRuc0Nhcm91c2VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdhbGxlcnknKTtcXHJcXG4gICAgY29uc3QgZWxlbVRvQW5pbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbmltYXRlJyk7XFxyXFxuICAgIGNvbnN0IG1vYl9zbGlkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9iLXNsaWRlcicpO1xcclxcbiAgICBjb25zdCBob21lX3ZpZGVvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhvbWUtdmlkZW8nKTtcXHJcXG4gICAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xcclxcbiAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy52aWRlbycpO1xcclxcbiAgICBjb25zdCB0b3BfbWFpbiA9IDE0MDtcXHJcXG4gICAgbGV0IHNjcm9sbGJhciA9IG51bGw7XFxyXFxuXFxyXFxuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcXHJcXG5cXHJcXG4gICAgaWYodmlkZW8pIHtcXHJcXG4gICAgICAvKiBzb3VyY2Uuc3JjID0gdmlkZW9TcmM7XFxyXFxuICAgICAgICBzb3VyY2UudHlwZSA9ICd2aWRlby9tcDQnOyAqL1xcclxcbiAgICAgICAgdmlkZW8udm9sdW1lID0gMDtcXHJcXG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xcclxcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdsb29wJywgJ3RydWUnKTtcXHJcXG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpO1xcclxcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICdmYWxzZScpO1xcclxcbiAgICAgICAgLy8gdmlkZW8uYXBwZW5kQ2hpbGQoc291cmNlKTtcXHJcXG4gICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSB2aWRlbyBpcyBhdmFpbGFibGUgdG8gcGxheSwgdHJpZ2dlciB0aGUgdmlkZW9cXHJcXG4gICAgICAgIC8vIGZvciBwbGF5YmFjay5cXHJcXG4gICAgICAgIHZpZGVvLnBsYXkoKTtcXHJcXG4gICAgfVxcclxcbiAgICBpZihtb2Jfc2xpZGVyLmxlbmd0aCkge1xcclxcbiAgICAgIG1vYl9zbGlkZXIuZm9yRWFjaCgoaXRlbSkgPT4ge1xcclxcbiAgICAgICAgY29uc3Qgc2xpZGVyID0gT2JqZWN0KHRpbnlfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInRuc1xcXCJdKSh7XFxyXFxuICAgICAgICAgIGNvbnRhaW5lcjogaXRlbSxcXHJcXG4gICAgICAgICAgaXRlbXM6IDEsXFxyXFxuICAgICAgICAgIHNsaWRlQnk6IDEsXFxyXFxuICAgICAgICAgIGNvbnRyb2xzOiB0cnVlLFxcclxcbiAgICAgICAgICBlZGdlUGFkZGluZzogMCxcXHJcXG4gICAgICAgICAgbG9vcDogZmFsc2UsXFxyXFxuICAgICAgICAgIG1vdXNlRHJhZzogZmFsc2UsXFxyXFxuICAgICAgICAgIGNlbnRlcjogZmFsc2UsXFxyXFxuICAgICAgICAgIGd1dHRlcjogMCxcXHJcXG4gICAgICAgICAgcmVzcG9uc2l2ZToge1xcclxcbiAgICAgICAgICAgICAgNjgwOiB7XFxyXFxuICAgICAgICAgICAgICAgIGNvbnRyb2xzOiBmYWxzZSxcXHJcXG4gICAgICAgICAgICAgICAgaXRlbXM6IDMsXFxyXFxuICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH0sXFxyXFxuICAgICAgfSk7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbWFpbl9jb250YWluZXIuc3R5bGUucGFkZGluZ1RvcCA9IGAke2hlYWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHR9cHhgO1xcclxcbiAgICBpZihob21lX3ZpZGVvKSB7XFxyXFxuICAgICAgaG9tZV92aWRlby5zdHlsZS5oZWlnaHQgPSBgJHt3aW5kb3cub3V0ZXJIZWlnaHQqLjggLSBoZWFkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fXB4YDtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpZiAoaXNNb2JpbGUpIHtcXHJcXG4gICAgICBtYWluX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZGVrdG9wJyk7XFxyXFxuICAgICAgbWFpbl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2lzLW1vYmlsZScpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIG1haW5fd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdpcy1tb2JpbGUnKTtcXHJcXG4gICAgICBtYWluX3dyYXBwZXIuY2xhc3NMaXN0LmFkZCgnaXMtZGVrdG9wJyk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XFxyXFxuICAgICAgc2Nyb2xsYmFyID0gc21vb3RoX3Njcm9sbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0uaW5pdChtYWluLCB7XFxyXFxuICAgICAgICBkYW1waW5nOiAwLjIsXFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgLy8gc2Nyb2xsYmFyLnRyYWNrLnhBeGlzLmhpZGUoKTtcXHJcXG5cXHJcXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcXHJcXG4gICAgICAgIGlmIChoYXNoKSB7XFxyXFxuICAgICAgICAgIHNjcm9sbGJhci5zY3JvbGxJbnRvVmlldyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGhhc2gpLCB7XFxyXFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiB0b3BfbWFpbixcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSwgMTIwMCk7XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdsb2dyb3MnKSkge1xcclxcbiAgICAgICAgaWYgKGVsZW1Ub0FuaW1bMF0pIHtcXHJcXG4gICAgICAgICAgZWxlbVRvQW5pbVswXS5jbGFzc0xpc3QuYWRkKCdpbml0Jyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmlsdGVyX190YXJnZXQtLWFjaGlldmVtZW50JykuZm9yRWFjaCgobGluaykgPT4ge1xcclxcbiAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcXHJcXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X2hhc2ggPSBlLnRhcmdldC5oYXNoO1xcclxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGN1cnJlbnRfaGFzaCk7XFxyXFxuICAgICAgICAgICAgc2Nyb2xsYmFyLnNjcm9sbEludG9WaWV3KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY3VycmVudF9oYXNoKSwge1xcclxcbiAgICAgICAgICAgICAgb2Zmc2V0VG9wOiB0b3BfbWFpbixcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgc2Nyb2xsYmFyLmFkZExpc3RlbmVyKCgpID0+IHtcXHJcXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHNjcm9sbGJhci5vZmZzZXQueTtcXHJcXG4gICAgICAgIGNvbnN0IHN0aWNreSA9IGhlYWRlci5vZmZzZXRUb3A7XFxyXFxuXFxyXFxuICAgICAgICBpZiAob2Zmc2V0ID4gc3RpY2t5KSB7XFxyXFxuICAgICAgICAgIGhlYWRlci5jbGFzc0xpc3QuYWRkKCdzdGlja3knKTtcXHJcXG4gICAgICAgICAgbWFpbl9jb250YWluZXIuc3R5bGUucGFkZGluZ1RvcCA9IGAke2hlYWRlci5vZmZzZXRIZWlnaHR9cHhgO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgaGVhZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreScpO1xcclxcbiAgICAgICAgICBtYWluX2NvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gYCR7aGVhZGVyLm9mZnNldEhlaWdodH1weGA7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIG1haW5fY29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3AgPSBgJHtoZWFkZXIub2Zmc2V0SGVpZ2h0fXB4YDtcXHJcXG4gICAgICAgICAgaWYoaG9tZV92aWRlbykge1xcclxcbiAgICAgICAgICAgIGhvbWVfdmlkZW8uc3R5bGUuaGVpZ2h0ID0gYCR7d2luZG93Lm91dGVySGVpZ2h0Ki44IC0gaGVhZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodH1weGA7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcclxcbiAgICAgICAgICBlbGVtVG9BbmltLmZvckVhY2goKGVsZW0pID0+IHtcXHJcXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh7IGVsZW0gfSlcXHJcXG4gICAgICAgICAgICBpZiAodGhpcy5Jc0luVmlldyhlbGVtLCBvZmZzZXQsIGhlYWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpKSB7XFxyXFxuICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoJ2luaXQnKTtcXHJcXG4gICAgICAgICAgICB9IC8qIGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCdpbml0Jyk7XFxyXFxuICAgICAgICAgICAgfSAqL1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICBtYWluX2NvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gYCR7aGVhZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodH1weGA7XFxyXFxuICAgICAgICAgICAgLyppZihob21lX3ZpZGVvKSB7XFxyXFxuICAgICAgICAgICAgICBob21lX3ZpZGVvLnN0eWxlLmhlaWdodCA9IGAke3dpbmRvdy5vdXRlckhlaWdodCouOCAtIGhlYWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHR9cHhgO1xcclxcbiAgICAgICAgICAgIH0qL1xcclxcbiAgICAgICAgfSwgMTUwKTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFNldEFuaW1hdGlvbigpO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICB9LCA1MDApO1xcclxcblxcclxcbiAgICAvLyB9XFxyXFxuXFxyXFxuICAgIGlmICh0bnNDYXJvdXNlbC5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgdG5zQ2Fyb3VzZWwuZm9yRWFjaChzbGlkZXIgPT4ge1xcclxcbiAgICAgICAgT2JqZWN0KHRpbnlfc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInRuc1xcXCJdKSh7XFxyXFxuICAgICAgICAgIGNvbnRhaW5lcjogc2xpZGVyLFxcclxcbiAgICAgICAgICBpdGVtczogMSxcXHJcXG4gICAgICAgICAgc2xpZGVCeTogMSxcXHJcXG4gICAgICAgICAgY29udHJvbHM6IHRydWUsXFxyXFxuICAgICAgICAgIGVkZ2VQYWRkaW5nOiAwLFxcclxcbiAgICAgICAgICBsb29wOiBmYWxzZSxcXHJcXG4gICAgICAgICAgbW91c2VEcmFnOiBmYWxzZSxcXHJcXG4gICAgICAgICAgY2VudGVyOiB0cnVlLFxcclxcbiAgICAgICAgICBndXR0ZXI6IDAsXFxyXFxuICAgICAgICAgIGF1dG9XaWR0aDogZmFsc2UsXFxyXFxuICAgICAgICAgIC8vIGF1dG9wbGF5OiB0cnVlXFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuXFxyXFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcclxcbiAgICAgIGlmICghaXNNb2JpbGUpIFNldEFuaW1hdGlvbigpO1xcclxcbiAgICB9LCA4MDApO1xcclxcblxcclxcbiAgICBoYW1idXJnZXJfYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcXHJcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuXFxyXFxuICAgICAgaGFtYnVyZ2VyX2J0bi5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcXHJcXG4gICAgICBoZWFkZXJfbmF2LmNsYXNzTGlzdC50b2dnbGUoJ3Nob3duJyk7XFxyXFxuICAgICAgLy9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoJ292LWhpZGRlbicpO1xcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgLyppZiAoc2VuZF9mb3JtKSB7XFxyXFxuICAgICAgc2VuZF9mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcXHJcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgIGNvbnN0IGVtYWlsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnVzZXItZW1haWwnKS52YWx1ZTtcXHJcXG4gICAgICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudXNlci1uYW1lJykudmFsdWU7XFxyXFxuICAgICAgICBjb25zdCBsYXN0TmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51c2VyLWxhc3ROYW1lJykudmFsdWU7XFxyXFxuICAgICAgICBjb25zdCBwaG9uZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51c2VyLXBob25lJykudmFsdWU7XFxyXFxuICAgICAgICBjb25zdCBkYXRhID0gW107XFxyXFxuICAgICAgICBpZiAoZW1haWwgIT09ICcnKSB7XFxyXFxuICAgICAgICAgIGRhdGEucHVzaCh7IGVtYWlsIH0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XFxyXFxuICAgICAgICAgIGRhdGEucHVzaCh7IG5hbWUgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAobGFzdE5hbWUgIT09ICcnKSB7XFxyXFxuICAgICAgICAgIGRhdGEucHVzaCh7IGxhc3ROYW1lIH0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgaWYgKHBob25lICE9PSAnJykge1xcclxcbiAgICAgICAgICBkYXRhLnB1c2goeyBwaG9uZSB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmb3JtdmFsJywgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xcclxcblxcclxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XFxyXFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gbGFuZ3VhZ2UgPT09ICdlbicgPyAnL2VuL3F1b3RlLmh0bWwnIDogJy9jb3RpemFjaW9uLmh0bWwnO1xcclxcbiAgICAgICAgfSwgMzAwKTtcXHJcXG5cXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSAqL1xcclxcblxcclxcbiAgICB0aGlzLlNldElzQWN0aXZlU2VjKCk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBJc0luVmlldyhlbGVtLCBvZmZzZXRZLCBoZWFkZXIpIHtcXHJcXG4gICAgLy8gY29uc29sZS5sb2coZWxlbSwgKGVsZW0ub2Zmc2V0VG9wIC0gb2Zmc2V0WSksIGVsZW0ub2Zmc2V0SGVpZ2h0KTtcXHJcXG4gICAgcmV0dXJuIGVsZW0ub2Zmc2V0VG9wIC0gb2Zmc2V0WSA8IGVsZW0ub2Zmc2V0SGVpZ2h0IC0gaGVhZGVyO1xcclxcbiAgfVxcclxcblxcclxcbiAgU2V0SXNBY3RpdmVTZWMoKSB7XFxyXFxuICAgIGNvbnN0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XFxyXFxuICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcXHJcXG4gICAgY29uc3QgbG9jID0gbG9jYXRpb24uc3BsaXQoJy8nKTtcXHJcXG4gICAgY29uc3QgbGFzdEl0ZW0gPSBoYXNoID8gbG9jW2xvYy5sZW5ndGggLSAyXSA6IGxvY2F0aW9uLnJlcGxhY2UoLy4qXFxcXC8oXFxcXHcrKVxcXFwvPyQvLCAnJDEnKTtcXHJcXG4gICAgY29uc3QgYW5jaG9yX2ludiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXZpZ2F0aW9uX19saW5rJyk7XFxyXFxuXFxyXFxuICAgIGZvciAoY29uc3QgbGluayBvZiBhbmNob3JfaW52KSB7XFxyXFxuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9PT0gJy8nIHx8XFxyXFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZignaW5kZXgnKSA+IC0xKSB7XFxyXFxuICAgICAgICBhbmNob3JfaW52WzBdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAobGluay5ocmVmLmluY2x1ZGVzKGxhc3RJdGVtKSkge1xcclxcbiAgICAgICAgbGluay5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gIH1cXHJcXG5cXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcXHJcXG4gICdET01Db250ZW50TG9hZGVkJyxcXHJcXG4gICgpID0+IHtcXHJcXG4gICAgbGV0IG1haW4gPSBuZXcgU2VjdGlvbkNsYXNzKCk7XFxyXFxuICB9LFxcclxcbiAgZmFsc2VcXHJcXG4pO1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9zY3JpcHRzL21haW4uanM/XCIpO1xuXG4gICAgLyoqKi9cbiAgfVxuXG4gIC8qKioqKiovXG59KTsiXX0=
